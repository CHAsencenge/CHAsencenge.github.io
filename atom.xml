<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>解字</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chasencenge.github.io/"/>
  <updated>2020-10-13T00:35:17.367Z</updated>
  <id>https://chasencenge.github.io/</id>
  
  <author>
    <name>CHAsencenge</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UE学习文档</title>
    <link href="https://chasencenge.github.io/2020/10/12/UE%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/"/>
    <id>https://chasencenge.github.io/2020/10/12/UE学习文档/</id>
    <published>2020-10-12T08:43:46.000Z</published>
    <updated>2020-10-13T00:35:17.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目打包"><a href="#项目打包" class="headerlink" title="项目打包"></a>项目打包</h1><h2 id="项目打包注意事项"><a href="#项目打包注意事项" class="headerlink" title="项目打包注意事项"></a>项目打包注意事项</h2><h3 id="启动地图"><a href="#启动地图" class="headerlink" title="启动地图"></a>启动地图</h3><p>构建项目时会从游戏默认地图开始，需要点击project settings — maps &amp; modes 设置game default map</p><p><img src="/2020/10/12/UE学习文档/map.png" alt="设置启动地图"></p><h3 id="选择目标平台"><a href="#选择目标平台" class="headerlink" title="选择目标平台"></a>选择目标平台</h3><p><img src="/2020/10/12/UE学习文档/platform.png" alt="设置平台"></p><p>还要记得选择目标硬件(target hardware)</p><h3 id="编辑器查看方式"><a href="#编辑器查看方式" class="headerlink" title="编辑器查看方式"></a>编辑器查看方式</h3><p><img src="/2020/10/12/UE学习文档/editorview.png" alt="选择编辑器视口"></p><h3 id="细化平台性能控制"><a href="#细化平台性能控制" class="headerlink" title="细化平台性能控制"></a>细化平台性能控制</h3><p><img src="/2020/10/12/UE学习文档/deviceprofile.png" alt="查看和修改设备描述"></p><p>打开device profiles以后点击想要修改的设备型号后面的扳手即可对其值进行修改</p><p><img src="/2020/10/12/UE学习文档/everydevice.png" alt="对其修改"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;项目打包&quot;&gt;&lt;a href=&quot;#项目打包&quot; class=&quot;headerlink&quot; title=&quot;项目打包&quot;&gt;&lt;/a&gt;项目打包&lt;/h1&gt;&lt;h2 id=&quot;项目打包注意事项&quot;&gt;&lt;a href=&quot;#项目打包注意事项&quot; class=&quot;headerlink&quot; title=&quot;项
      
    
    </summary>
    
    
      <category term="GameDev" scheme="https://chasencenge.github.io/categories/GameDev/"/>
    
    
      <category term="GameDev" scheme="https://chasencenge.github.io/tags/GameDev/"/>
    
  </entry>
  
  <entry>
    <title>实时计算机图形学笔记</title>
    <link href="https://chasencenge.github.io/2020/10/02/%E5%AE%9E%E6%97%B6%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://chasencenge.github.io/2020/10/02/实时计算机图形学笔记/</id>
    <published>2020-10-02T12:04:03.000Z</published>
    <updated>2020-10-02T12:13:46.595Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="图形学" scheme="https://chasencenge.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
      <category term="GameDev" scheme="https://chasencenge.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/GameDev/"/>
    
    
      <category term="GameDev" scheme="https://chasencenge.github.io/tags/GameDev/"/>
    
      <category term="图形学" scheme="https://chasencenge.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>腾讯游戏开发精粹笔记</title>
    <link href="https://chasencenge.github.io/2020/09/25/%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E7%B2%BE%E7%B2%B9%E7%AC%94%E8%AE%B0/"/>
    <id>https://chasencenge.github.io/2020/09/25/腾讯游戏开发精粹笔记/</id>
    <published>2020-09-25T06:07:13.000Z</published>
    <updated>2020-10-02T12:02:17.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、游戏数学"><a href="#一、游戏数学" class="headerlink" title="一、游戏数学"></a>一、游戏数学</h1><h2 id="1-基于SDF的摇杆移动"><a href="#1-基于SDF的摇杆移动" class="headerlink" title="1.基于SDF的摇杆移动"></a>1.基于SDF的摇杆移动</h2><h3 id="SDF："><a href="#SDF：" class="headerlink" title="SDF："></a>SDF：</h3><p>SDF全称Signed Distance Field（有号距离场），定义为空间中的点到形状表面的最小距离，并用正值表示点在形状外部，负值表示点在形状内部。</p><h3 id="为什么要使用SDF？"><a href="#为什么要使用SDF？" class="headerlink" title="为什么要使用SDF？"></a>为什么要使用SDF？</h3><p>空间换时间，在O(1)时间复杂度计算出是否碰撞。</p><h3 id="如何判断碰撞？"><a href="#如何判断碰撞？" class="headerlink" title="如何判断碰撞？"></a>如何判断碰撞？</h3><p>基于已有SDF信息的栅格，使用其邻近四个角的SD信息进行插值，得到当前点的SD，若SD&lt;=0, 则判定该点和碰撞物发生了碰撞。</p><h3 id="插值获得任意点的SD值："><a href="#插值获得任意点的SD值：" class="headerlink" title="插值获得任意点的SD值："></a>插值获得任意点的SD值：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//计算位置pos的SD值</span><br><span class="hljs-comment">//每个栅格的实际尺寸为grid，横向栅格数量为width</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">Sample</span><span class="hljs-params">(Vector2 pos)</span><br></span>&#123;<br>    pos = pos / grid;<br>    <span class="hljs-keyword">int</span> fx = Mathf.FloorToInt(pos.x);<br>    <span class="hljs-keyword">int</span> fy = Mathf.FloorToInt(pos.y);<br>    <span class="hljs-keyword">float</span> rx = pos.x - fx;<br>    <span class="hljs-keyword">float</span> ry = pos.y - fy;<br>    <span class="hljs-keyword">int</span> i = fy * width + fx;<br>    <span class="hljs-keyword">return</span> (sdf[i]*(<span class="hljs-number">1</span>-rx) + sdf[i+<span class="hljs-number">1</span>]*rx)*(<span class="hljs-number">1</span>-ry) + (sdf[i+width]*(<span class="hljs-number">1</span>-rx) + sdf[i+width+<span class="hljs-number">1</span>]*rx)*ry;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何实现发生碰撞后绕障碍物滑行？"><a href="#如何实现发生碰撞后绕障碍物滑行？" class="headerlink" title="如何实现发生碰撞后绕障碍物滑行？"></a>如何实现发生碰撞后绕障碍物滑行？</h3><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/1.6%E6%BB%91%E8%A1%8C.png" alt="1.6滑行"></p><p>v表示摇杆方向，与障碍物发生碰撞后需要沿着v’方向滑行，n为碰撞法线，v’和v有以上关系。</p><h4 id="如何获取碰撞法线n？"><a href="#如何获取碰撞法线n？" class="headerlink" title="如何获取碰撞法线n？"></a>如何获取碰撞法线n？</h4><p>利用SDF的梯度作为碰撞法线。</p><h4 id="求梯度方向："><a href="#求梯度方向：" class="headerlink" title="求梯度方向："></a>求梯度方向：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">public</span> Vector2 <span class="hljs-title">Gradient</span><span class="hljs-params">(Vector2 pos)</span><br></span>&#123;<br>    <span class="hljs-keyword">float</span> delta = <span class="hljs-number">1f</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0.5f</span> * <span class="hljs-keyword">new</span> Vector2(<br>    Sample(<span class="hljs-keyword">new</span> Vector2(pos.x+delta, pos.y)) - Sample(<span class="hljs-keyword">new</span> Vector2(pos.x-delta, pos.y)), <br>    Sample(<span class="hljs-keyword">new</span> Vector2(pos.x, pos.y+delta)) - Sample(<span class="hljs-keyword">new</span> Vector2(pos.x, pos.y-delta))<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="发生碰撞后实际移动方向代码："><a href="#发生碰撞后实际移动方向代码：" class="headerlink" title="发生碰撞后实际移动方向代码："></a>发生碰撞后实际移动方向代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//获取在移动过程使用SDF得到的最佳位置</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Vector2 <span class="hljs-title">GetValidPositionBySDF</span><span class="hljs-params">(Vector2 pos, Vector2 dir, <span class="hljs-keyword">float</span> speed)</span><br></span>&#123;<br>    Vector2 newPos = pos + dir * speed;<br>    <span class="hljs-keyword">float</span> SD = Sample(newPos);<br>    <br>    <span class="hljs-comment">//不可行走</span><br>    <span class="hljs-keyword">if</span>(SD &lt; playerRadius)<br>    &#123;<br>        Vector2 gradient = Gradient(newPos);<br>        Vector2 adjustDir = dir - gradient * Vector2.Dot(gradient, dir);<br>        newPos = pos + adjustDir.normalized * speed;<br>    &#125;<br>    <br>    <span class="hljs-comment">//多次迭代</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>    &#123;<br>        SD = Sample(newPos);<br>        <span class="hljs-keyword">if</span>(SD &gt;= playerRadius)<br>            <span class="hljs-keyword">break</span>;<br>        newPos += Gradient(newPos) * (playerRadius - SD);<br>    &#125;<br>    <br>    <span class="hljs-comment">//避免往返</span><br>    <span class="hljs-keyword">if</span>(Vector2.Dot(newPos - pos, dir) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        newPos = pos;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newPos;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="角色不能越过障碍物的远距离移动"><a href="#角色不能越过障碍物的远距离移动" class="headerlink" title="角色不能越过障碍物的远距离移动"></a>角色不能越过障碍物的远距离移动</h3><p>用于当校色进行瞬时远距离移动但不能越过障碍物的情况。</p><p>使用连续碰撞检测规避穿越障碍物的情况，具体方法是<strong>圆盘投射（Disk Casting）</strong>。</p><h4 id="使用圆盘投射计算位置："><a href="#使用圆盘投射计算位置：" class="headerlink" title="使用圆盘投射计算位置："></a>使用圆盘投射计算位置：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//oriPos:原始位置，dir:冲刺方向，radius:角色半径，maxDist:最大冲刺距离</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Vector2 <span class="hljs-title">DiskCast</span><span class="hljs-params">(Vector2 origin, Vector2 dir, <span class="hljs-keyword">float</span> radius, <span class="hljs-keyword">float</span> maxDist)</span><br></span>&#123;<br>    <span class="hljs-keyword">float</span> t = <span class="hljs-number">0f</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>    &#123;<br>        Vector2 p = origin + dir * t;<br>        <span class="hljs-keyword">float</span> sd = Sample(p);<br>        <span class="hljs-keyword">if</span>(sd &lt;= radius)<br>            <span class="hljs-keyword">return</span> p;<br>        t += sd - radius;<br>        <span class="hljs-keyword">if</span>(t &gt;= maxDist)<br>            <span class="hljs-keyword">return</span> origin + dir * maxDist;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态地图"><a href="#动态地图" class="headerlink" title="动态地图"></a>动态地图</h3><p>在均匀网格地图上，当角色在一帧内的行走距离不会超过单个网格大小时，可以通过检测每一帧与玩家所在网格相邻的8个网格的碰撞来实现规避障碍物的功能。</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/1.16%E8%A7%92%E8%89%B2%E5%9C%A8%E5%9D%87%E5%8C%80%E7%BD%91%E6%A0%BC%E5%9C%B0%E5%9B%BE%E7%A7%BB%E5%8A%A8.png" alt="1.16角色在均匀网格地图移动"></p><p>红色为障碍物区域，虚线圆圈为角色。</p><h4 id="实现规避障碍物："><a href="#实现规避障碍物：" class="headerlink" title="实现规避障碍物："></a>实现规避障碍物：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">EvalSDF</span><span class="hljs-params">(Vector2 p)</span><br></span>&#123;<br>    <span class="hljs-comment">//坐标离散成网格</span><br>    <span class="hljs-keyword">int</span> x = posToGridX(p);<br>    <span class="hljs-keyword">int</span> y = posToGridY(p);<br>    <span class="hljs-keyword">float</span> dist = cellSize;<br>    <span class="hljs-keyword">int</span> center = grid[y * width + x];<br>    <span class="hljs-comment">//WALL格子不可行走</span><br>    <span class="hljs-comment">//检测与玩家最近的距离</span><br>    <span class="hljs-keyword">if</span>(center == WALL)<br>    &#123;<br>        dist = min(dist, sdBox(centerPos - vecTopLeft, cellExtents));<br>    &#125;<br>    <span class="hljs-keyword">int</span> topleft = grid[(y - <span class="hljs-number">1</span>) * width + (x - <span class="hljs-number">1</span>)];<br>    <span class="hljs-keyword">if</span>(topleft == WALL)<br>    &#123;<br>        dist = min(dist, sdBox(centerPos - vecTop, cellExtents));<br>    &#125;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">return</span> dist;<br>&#125;<br><br><span class="hljs-function">Vector2 <span class="hljs-title">EvalGradient</span><span class="hljs-params">(Vector2 p)</span><br></span>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-comment">//新目标位置</span><br>    Vector2 nextPlayerPos = playerPos + moveDir * moveSpeed;<br>    <span class="hljs-comment">//目标位置的最近距离</span><br>    <span class="hljs-keyword">float</span> d = EvalSDF(nextPlayerPos);<br>    <span class="hljs-comment">//距离小于玩家半径，有穿插</span><br>    <span class="hljs-keyword">if</span>(d &lt; playerRadius)<br>    &#123;<br>        <span class="hljs-comment">//计算最近表面的法线</span><br>        Vector2 n = EvalGradient(nextPlayerPos);<br>        <span class="hljs-comment">//将玩家推出障碍区域</span><br>        nextPlayerPos = nextPlayerPos + n * (playerRadius - d);<br>    &#125;<br>    playerPos = nextPlayerPos;<br>&#125;<br></code></pre></td></tr></table></figure><p>场景中的其他障碍物，如较大的汽车、其他玩家等，可通过<strong>矩形、圆形的SDF函数</strong>来表示，并将结果与网格地图取出的SDF做<strong>交集</strong>操作。</p><h4 id="圆盘SDF"><a href="#圆盘SDF" class="headerlink" title="圆盘SDF:"></a>圆盘SDF:</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//x为任意点坐标，c为圆盘中心，r为圆盘半径</span><br><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">sdCircle</span><span class="hljs-params">(Vector2 x, Vector2 c, <span class="hljs-keyword">float</span> r)</span><br></span>&#123;<br>    <span class="hljs-keyword">return</span> (x - c).length() - r;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="矩形SDF"><a href="#矩形SDF" class="headerlink" title="矩形SDF:"></a>矩形SDF:</h4><p>d = (x - c)R(-θ) - b</p><p>Φ<del>x</del> = min(max(d<del>x</del>, d<del>y</del>), 0) + ||max(d, 0)||</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/1.14%E7%9F%A9%E5%BD%A2SDF.png" alt="1.14矩形SDF"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//x为任意点坐标，c为矩形中心，rot为矩形旋转角度，b为矩形边长</span><br><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">sdBox</span><span class="hljs-params">(Vector2 x, Vector c, Vector2 rot, Vector2 b)</span><br></span>&#123;<br>    Vector2 p = Vector2.Dot(x - c, -rot);<br>    Vector2 d = Vector2.Abs(p) - b;<br>    <span class="hljs-keyword">return</span> Mathf.Min(Mathf.Max(d.x, d.y), <span class="hljs-number">0f</span>) + Vector2.Max(d, Vector2.zero).Length(); <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-高性能的定点数实现方案"><a href="#2-高性能的定点数实现方案" class="headerlink" title="2. 高性能的定点数实现方案"></a>2. 高性能的定点数实现方案</h2><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>解决不同平台上的浮点数运算结果不同而导致的对帧同步的严重影响。</p><h3 id="32位浮点数结构"><a href="#32位浮点数结构" class="headerlink" title="32位浮点数结构"></a>32位浮点数结构</h3><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/32%E4%BD%8D%E6%B5%AE%E7%82%B9%E6%95%B0%E7%BB%93%E6%9E%84.png" alt="32位浮点数结构"></p><p>S=0时为正数，S=1时为负数</p><h3 id="基于整数的二进制表示的定点数原理"><a href="#基于整数的二进制表示的定点数原理" class="headerlink" title="基于整数的二进制表示的定点数原理"></a>基于整数的二进制表示的定点数原理</h3><p>设a为定点数，f(a)为这个定点数对应的整数值</p><p>a = 2^-n^f(a)</p><h3 id="32和64位定点数表示原理"><a href="#32和64位定点数表示原理" class="headerlink" title="32和64位定点数表示原理"></a>32和64位定点数表示原理</h3><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/%E5%AE%9A%E7%82%B9%E6%95%B0%E7%BB%93%E6%9E%84.png" alt="定点数结构"></p><p>32位定点数表示的范围：[-2^21^, 2^21^ - 2^-10^]</p><p>64位定点数表示的范围：[-2^31^, 2^31^ - 2^-32^]</p><h3 id="定点数四则运算"><a href="#定点数四则运算" class="headerlink" title="定点数四则运算"></a>定点数四则运算</h3><p>a + b = 2^-n^ (f(a) + f(b))</p><p>a - b = 2^-n^ (f(a) - f(b))</p><p>ab = (2^-n^)^2^ f(a) f(b) = 2^-n^ (2^-n^ f(a) f(b))</p><p>a / b = 2^-n^ (2^n^ f(a) / f(b))</p><h1 id="二、游戏物理"><a href="#二、游戏物理" class="headerlink" title="二、游戏物理"></a>二、游戏物理</h1><h2 id="1-一种高效的弧长参数化路径系统"><a href="#1-一种高效的弧长参数化路径系统" class="headerlink" title="1. 一种高效的弧长参数化路径系统"></a>1. 一种高效的弧长参数化路径系统</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>在跑酷游戏中，人物的移动靠路径引导；想要实现“弧长参数化”的特性—即令曲线参数t与曲线长度为L为线性关系，从而将参数t的线性变化映射到长度的线性变化上，实现曲线上的匀线速度运动。</p><h4 id="曲线路径系统需求："><a href="#曲线路径系统需求：" class="headerlink" title="曲线路径系统需求："></a>曲线路径系统需求：</h4><p>路径布置简单，最直观的就是布置路点。</p><p>修改具有局部性，修改一个路点只会影响上下游。</p><p>曲线至少具有C1连续性，满足基本的光滑需求。</p><p>两个路点之间的曲线可以是异面曲线，等同于可以自由控制邻接路点曲线的方向。</p><p>与曲线相关的计算尽量简单，尽量少地进行迭代计算。</p><h3 id="端点间二次样条的构建"><a href="#端点间二次样条的构建" class="headerlink" title="端点间二次样条的构建"></a>端点间二次样条的构建</h3><h4 id="为什么要拼接两条二次曲线？"><a href="#为什么要拼接两条二次曲线？" class="headerlink" title="为什么要拼接两条二次曲线？"></a>为什么要拼接两条二次曲线？</h4><p>要求两个路点可以自由控制位置和朝向（切线方向），单一的一段二次曲线自由度不够。</p><h4 id="二次样条曲线："><a href="#二次样条曲线：" class="headerlink" title="二次样条曲线："></a>二次样条曲线：</h4><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/3.1%E4%BA%8C%E6%AC%A1%E6%A0%B7%E6%9D%A1%E6%9B%B2%E7%BA%BF%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="3.1二次样条曲线示意图"></p><p>起点P<del>0</del>、起点切线T<del>0</del>、终点P<del>1</del>、终点切线T<del>1</del>。</p><p>f<del>1</del>(t) = a<del>1</del>t^2^ + b<del>1</del>t + c<del>1</del></p><p>f<del>2</del>(t) = a<del>2</del>t^2^ + b<del>2</del>t + c<del>2</del></p><p>为了将分段曲线当作一段曲线使用，需将两段曲线的参数t归一化到统一的[0, 1]范围内，f<del>s</del>(0) = P<del>0</del>，f<del>s</del>(1) = P<del>1</del>。</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/%E5%8F%82%E6%95%B0t%E5%BD%92%E4%B8%80%E5%8C%96%E5%90%8E%E7%9A%84%E5%88%86%E6%AE%B5%E4%BA%8C%E6%AC%A1%E6%9B%B2%E7%BA%BF.png" alt="参数t归一化后的分段二次曲线"></p><p>例如当L<del>1</del>长度为4，L<del>2</del>长度为6，归一化t = 0.3时，f<del>s</del>(t) = f<del>s</del>(0.3) = f<del>1</del>(0.3 x 10 / 4) = f<del>1</del>(3/4)，恰好对应L<del>1</del>的四分之三位置。</p><h3 id="路径的构建"><a href="#路径的构建" class="headerlink" title="路径的构建"></a>路径的构建</h3><p>路径为路点间曲线的拼接，切线的设置模仿Catmull-Rom这类Cardinal曲线的做法：路点i处的切线由路点i-1和路点i+1的位置决定：</p><p>T<del>i</del> = τ(P<del>i+1</del> - P<del>i-1</del>), τ为切线的缩放因子（张弛因子）</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/3.2Cardinal%E6%9B%B2%E7%BA%BF%E5%88%87%E7%BA%BF%E8%AE%BE%E7%BD%AE.png" alt="3.2Cardinal曲线切线设置"></p><p>使用邻接路点的信息构建曲线时，将邻接路点转换到自己的<strong>局部坐标系</strong>下，在上图的构建中，P<del>i</del>处于坐标原点且旋转为(0, 0, 0)，最后在使用路径时，每段曲线的计算结果要做一次<strong>从局部到世界坐标系的转换</strong>，<strong>好处</strong>是路径作为一个整体不受刚体变换的影响，适合游戏中场景动态拼接的需求。</p><h3 id="弧长的重参数化（arc-length-parametrization）"><a href="#弧长的重参数化（arc-length-parametrization）" class="headerlink" title="弧长的重参数化（arc-length parametrization）"></a>弧长的重参数化（arc-length parametrization）</h3><h4 id="为什么要做弧长的重参数化？"><a href="#为什么要做弧长的重参数化？" class="headerlink" title="为什么要做弧长的重参数化？"></a>为什么要做弧长的重参数化？</h4><p>可近似理解为在曲线上，每一点处的<strong>速度</strong>不同，相同的Δt内对应“走过”的弧长也不相同。</p><p>例如，对于曲线：</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/%E6%9B%B2%E7%BA%BF.png" alt="曲线"></p><p>直接用t取点，具有明显不均匀现象：</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/%E7%9B%B4%E6%8E%A5t%E5%8F%96%E7%82%B9.png" alt="直接t取点"></p><h4 id="arc-length"><a href="#arc-length" class="headerlink" title="arc-length:"></a>arc-length:</h4><p>定义一个映射Δ: [a, b] -&gt; [0, L], 获取原弧线参数t的定义域到弧长区间上的一个满射：</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/%E6%BB%A1%E5%B0%84.png" alt="满射"></p><p>其反函数设为Φ(s)，那么在给定s位置下，对应曲线参数为Φ(s)，对于上述曲线，先求Δ(t)，再求其反函数：</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/%E9%87%8D%E5%8F%82%E6%95%B01.png" alt="重参数1"></p><p>其反函数：</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/%E9%87%8D%E5%8F%82%E6%95%B02.png" alt="重参数2"></p><p>重参数化形式：</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/%E9%87%8D%E5%8F%82%E6%95%B03.png" alt="重参数3"></p><p>arc-length参数化后结果：</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/%E9%87%8D%E5%8F%82%E6%95%B04.png" alt="重参数4"></p><h3 id="曲线上的简单运动"><a href="#曲线上的简单运动" class="headerlink" title="曲线上的简单运动"></a>曲线上的简单运动</h3><p>法平面定义：过空间曲线的切点并且与切线垂直的平面。</p><h3 id="相邻路径的切换"><a href="#相邻路径的切换" class="headerlink" title="相邻路径的切换"></a>相邻路径的切换</h3><p>路径切换的过程中，使用当前路径上的基准点的法平面与另一路径的交点（等位点），由于路径的切换不能瞬时完成，将当前基准点变换到相邻路径基准点的局部坐标系下，将变换后的值和(O, X, Y, Z)插值的结果转换到世界坐标系，作为当前基准点及其关联的局部坐标系输入给物理模块。</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/3.4%E8%B7%AF%E5%BE%84%E5%88%87%E6%8D%A2%E6%8F%92%E5%80%BC%E8%BD%A8%E8%BF%B9.png" alt="3.4路径切换插值轨迹"></p><h3 id="曲线上的旋转插值"><a href="#曲线上的旋转插值" class="headerlink" title="曲线上的旋转插值"></a>曲线上的旋转插值</h3><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/3.5%E6%97%8B%E8%BD%AC%E6%8F%92%E5%80%BC%E5%AF%B9%E6%AF%94.png" alt="3.5旋转插值对比"></p><h2 id="2-船的物理模拟及同步设计"><a href="#2-船的物理模拟及同步设计" class="headerlink" title="2. 船的物理模拟及同步设计"></a>2. 船的物理模拟及同步设计</h2><h3 id="船的两种刚体"><a href="#船的两种刚体" class="headerlink" title="船的两种刚体"></a>船的两种刚体</h3><p>移动碰撞体：用于计算浮力的动态刚体</p><p>射击碰撞体：用来做射击检测的动力学动态刚体</p><h3 id="浮力计算中计算多面体入水体积"><a href="#浮力计算中计算多面体入水体积" class="headerlink" title="浮力计算中计算多面体入水体积"></a>浮力计算中计算多面体入水体积</h3><p>分成三角面判断，一个三角面只有三种状态：完全入水、完全出水、部分出水。</p><p>三角面完全入水，则三角面可以和P形成四面体为入水体积（点P必须在水面上）。</p><p>三角面完全出水，丢弃。</p><p>三角面部分入水，分两种情况，两点入水和一点入水。两点入水，分成的三个三角形，将水面上部的丢弃；一点入水，分成的三个三角形将水面上的两个三角形丢弃。</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/%E4%B8%89%E8%A7%92%E9%9D%A2%E9%83%A8%E5%88%86%E5%85%A5%E6%B0%B4.png" alt="三角面部分入水"></p><p><strong>于是，入水体积的求解收敛为两个问题：</strong></p><p>求一个四面体的体积。</p><p>已知三角形的顶点A, B, C, 求与水面的交点问题。</p><h3 id="浮力系统物理更新机制"><a href="#浮力系统物理更新机制" class="headerlink" title="浮力系统物理更新机制"></a>浮力系统物理更新机制</h3><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/%E7%AC%AC%E4%B8%80%E6%96%B9%E5%92%8C%E7%AC%AC%E4%B8%89%E6%96%B9Component.png" alt="第一方和第三方Component"></p><p>三种第三方位置同步方法：</p><p>设置位置：会造成物体瞬移。</p><p>设置速度：通过计算位移差求出速度，在物理引擎进行物理模拟前应用到动态刚体上。</p><p>设置力：增加了一层间接性。</p><h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><p>第三方同步组件会每帧更新刚体的速度，浮力组件会每帧更新刚体受到的力，会造成位置的不一致（例如第三方刚体本来以速度v移动到位置X，但是浮力组件在速度方向上施加了阻力、浮力和升力，从而使物理系统算出的速度和v有偏差，导致最终物理模拟结束时物体的位置不是X）。</p><h4 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h4><p>浮力系统根据是否是第一方选择最终计算结果是力还是速度。</p><h4 id="Component物理更新的过程："><a href="#Component物理更新的过程：" class="headerlink" title="Component物理更新的过程："></a>Component物理更新的过程：</h4><p>第一方通过引擎组件(EngineComponent)计算出驱动力，通过浮力组件(BuoyancyComponent)计算出浮力，将这些力在物理引擎进行物理模拟之前统一施加在刚体组件(PhyComponent)上；</p><p>第三方通过同步组件(SyncComponent)计算出下一帧的同步速度，通过浮力组件计算出的浮力推算出下一帧的浮力速度，将这两个速度糅合后，在物理引擎进行物理模拟之前设置在刚体组件上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、游戏数学&quot;&gt;&lt;a href=&quot;#一、游戏数学&quot; class=&quot;headerlink&quot; title=&quot;一、游戏数学&quot;&gt;&lt;/a&gt;一、游戏数学&lt;/h1&gt;&lt;h2 id=&quot;1-基于SDF的摇杆移动&quot;&gt;&lt;a href=&quot;#1-基于SDF的摇杆移动&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="GameDev" scheme="https://chasencenge.github.io/categories/GameDev/"/>
    
    
      <category term="GameDev" scheme="https://chasencenge.github.io/tags/GameDev/"/>
    
  </entry>
  
  <entry>
    <title>容器</title>
    <link href="https://chasencenge.github.io/2020/09/15/%E5%AE%B9%E5%99%A8/"/>
    <id>https://chasencenge.github.io/2020/09/15/容器/</id>
    <published>2020-09-15T13:50:54.000Z</published>
    <updated>2020-09-15T14:18:33.577Z</updated>
    
    <content type="html"><![CDATA[<h3 id="容器与镜像"><a href="#容器与镜像" class="headerlink" title="容器与镜像"></a>容器与镜像</h3><p>进程可见、可相互通信、共享一份文件系统</p><p>高级权限的进程可能破环低权限的进程</p><p>资源抢占</p><p>Linux通过 <code>chroot</code> 可将一个子目录变成根目录</p><p><code>namespace</code>在资源视图上进行隔离</p><p><code>cgroup</code>限制资源使用率</p><h4 id="容器："><a href="#容器：" class="headerlink" title="容器："></a>容器：</h4><p>容器是一个视图隔离、资源可限制、独立文件系统的进程集合</p><h4 id="镜像："><a href="#镜像：" class="headerlink" title="镜像："></a>镜像：</h4><p>运行容器需要的所有文件集合</p><p>构建步骤所带来的文件系统的变化叫做changeset</p><p>镜像可进行分层复用</p><h4 id="如何构建镜像？"><a href="#如何构建镜像？" class="headerlink" title="如何构建镜像？"></a>如何构建镜像？</h4><p>编写Dockerfile</p><p>// 表示以下的步骤是基于golang构建的</p><p><code>FROM golang:1.12-alpine</code> </p><p>// 类似于cd</p><p><code>WORKDIR /go/src/app</code></p><p>// 把数据拷入到容器内</p><p><code>COPY</code></p><p>//下载依赖</p><p><code>RUN go get -d -v ./...</code></p><p>//创建应用并安装</p><p><code>RUN go install -v ./...</code></p><p>//使用镜像默认程序的名字是什么</p><p><code>CMD [&quot;app&quot;]</code></p><p>有了这样一个Dockerfile<code>之后就可以通过docker build</code>构建镜像（存储到本地的）</p><p>docker registry进行镜像数据的存储和转发，通过 <code>docker push</code>可以将本地的镜像推送到镜像仓库中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;容器与镜像&quot;&gt;&lt;a href=&quot;#容器与镜像&quot; class=&quot;headerlink&quot; title=&quot;容器与镜像&quot;&gt;&lt;/a&gt;容器与镜像&lt;/h3&gt;&lt;p&gt;进程可见、可相互通信、共享一份文件系统&lt;/p&gt;
&lt;p&gt;高级权限的进程可能破环低权限的进程&lt;/p&gt;
&lt;p&gt;资源抢占&lt;/
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://chasencenge.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://chasencenge.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>贪心专题</title>
    <link href="https://chasencenge.github.io/2020/09/15/%E8%B4%AA%E5%BF%83%E4%B8%93%E9%A2%98/"/>
    <id>https://chasencenge.github.io/2020/09/15/贪心专题/</id>
    <published>2020-09-15T11:24:25.000Z</published>
    <updated>2020-09-15T12:23:12.278Z</updated>
    
    <content type="html"><![CDATA[<h4 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12. 整数转罗马数字"></a>12. 整数转罗马数字</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 处理上有优先级，对于当前的数，优先处理大于1000的部分，然后处理900，500，400.....（每一部分的处理方式也有固定的对应） --&gt; 贪心算法</span><br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">intToRoman</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>    <span class="hljs-built_in">string</span> res;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; store&#123; <span class="hljs-number">1000</span>, <span class="hljs-number">900</span>, <span class="hljs-number">500</span>, <span class="hljs-number">400</span>, <span class="hljs-number">100</span>, <span class="hljs-number">90</span>, <span class="hljs-number">50</span>, <span class="hljs-number">40</span>, <span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span> &#125;;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; strs&#123; <span class="hljs-string">"M"</span>, <span class="hljs-string">"CM"</span>, <span class="hljs-string">"D"</span>, <span class="hljs-string">"CD"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"XC"</span>, <span class="hljs-string">"L"</span>, <span class="hljs-string">"XL"</span>, <span class="hljs-string">"X"</span>, <span class="hljs-string">"IX"</span>, <span class="hljs-string">"V"</span>, <span class="hljs-string">"IV"</span>, <span class="hljs-string">"I"</span> &#125;;<br>    <span class="hljs-keyword">int</span> n = store.size();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (num &gt;= store[i])<br>        &#123;<br>            res.append(strs[i]);<br>            num -= store[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a>13. 罗马数字转整数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">romanToInt</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; hash&#123; &#123;<span class="hljs-string">'M'</span>, <span class="hljs-number">1000</span>&#125;, &#123;<span class="hljs-string">'D'</span>, <span class="hljs-number">500</span>&#125;, &#123;<span class="hljs-string">'C'</span>, <span class="hljs-number">100</span>&#125;, &#123;<span class="hljs-string">'L'</span>, <span class="hljs-number">50</span>&#125;, &#123;<span class="hljs-string">'X'</span>, <span class="hljs-number">10</span>&#125;, &#123;<span class="hljs-string">'V'</span>, <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-string">'I'</span>, <span class="hljs-number">1</span>&#125; &#125;;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.size(); i++)<br>    &#123;<br>        <span class="hljs-comment">// s.size()为'\0',将'\0'赋给int型变量时，变量值为0；</span><br>        <span class="hljs-keyword">if</span> (hash[s[i]] &lt; hash[s[i + <span class="hljs-number">1</span>]])<br>            res -= hash[s[i]];<br>        <span class="hljs-keyword">else</span><br>            res += hash[s[i]];<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; s[s.size()];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;12-整数转罗马数字&quot;&gt;&lt;a href=&quot;#12-整数转罗马数字&quot; class=&quot;headerlink&quot; title=&quot;12. 整数转罗马数字&quot;&gt;&lt;/a&gt;12. 整数转罗马数字&lt;/h4&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;t
      
    
    </summary>
    
    
      <category term="C++" scheme="https://chasencenge.github.io/categories/C/"/>
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/C/Algorithm/"/>
    
    
      <category term="C++" scheme="https://chasencenge.github.io/tags/C/"/>
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>递归专题</title>
    <link href="https://chasencenge.github.io/2020/09/08/%E5%9B%9E%E6%BA%AF%E4%B8%93%E9%A2%98/"/>
    <id>https://chasencenge.github.io/2020/09/08/回溯专题/</id>
    <published>2020-09-08T06:17:54.000Z</published>
    <updated>2020-09-11T07:23:20.666Z</updated>
    
    <content type="html"><![CDATA[<h3 id="回溯算法的写法："><a href="#回溯算法的写法：" class="headerlink" title="回溯算法的写法："></a>回溯算法的写法：</h3><h5 id="画出递归树，找到状态变量（回溯函数的参数）"><a href="#画出递归树，找到状态变量（回溯函数的参数）" class="headerlink" title="画出递归树，找到状态变量（回溯函数的参数）"></a>画出递归树，找到状态变量（回溯函数的参数）</h5><h5 id="根据题意确立结束条件"><a href="#根据题意确立结束条件" class="headerlink" title="根据题意确立结束条件"></a>根据题意确立结束条件</h5><h5 id="找准选择列表"><a href="#找准选择列表" class="headerlink" title="找准选择列表"></a>找准选择列表</h5><h5 id="判断是否需要剪枝（去掉重复的集合，即去掉递归树上的某些分支）"><a href="#判断是否需要剪枝（去掉重复的集合，即去掉递归树上的某些分支）" class="headerlink" title="判断是否需要剪枝（去掉重复的集合，即去掉递归树上的某些分支）"></a>判断是否需要剪枝（去掉重复的集合，即去掉递归树上的某些分支）</h5><h5 id="做出选择，递归调用，进入下一层"><a href="#做出选择，递归调用，进入下一层" class="headerlink" title="做出选择，递归调用，进入下一层"></a>做出选择，递归调用，进入下一层</h5><h5 id="撤销选择"><a href="#撤销选择" class="headerlink" title="撤销选择"></a>撤销选择</h5><h4 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a>77. 组合</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//给出n，k返回可能的组合</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; temp;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span><br></span>&#123;<br>    <span class="hljs-comment">// 如果[cur, n]中元素的个数加上temo中元素的个数少于k，无法构成需要的组合</span><br>    <span class="hljs-keyword">if</span> (temp.size() + (n - cur + <span class="hljs-number">1</span>) &lt; k)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果temp的size == k，说明找到了组合，插入res</span><br>    <span class="hljs-keyword">if</span> (temp.size() == k)<br>    &#123;<br>        res.push_back(temp);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 小于k的话继续往里添加元素</span><br>    <span class="hljs-keyword">if</span> (temp.size() &lt; k)<br>    &#123;<br>        <span class="hljs-comment">// 考虑选择当前位置</span><br>        temp.push_back(cur);<br>        dfs(cur + <span class="hljs-number">1</span>, n, k);<br>        temp.pop_back();<br>        <span class="hljs-comment">// 考虑不选择当前位置</span><br>        dfs(cur + <span class="hljs-number">1</span>, n, k);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">combine</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    dfs(<span class="hljs-number">1</span>, n, k);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 因为是数据可重复选择的情况，所以在回溯中，可选择跳过和不跳过当前数值，这样就会包括某一个值重复选择的情况，在不跳过当前值的选择中，需要确定当前数值没有超过所需值</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; temp;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; candidates, <span class="hljs-keyword">int</span> remain)</span><br></span>&#123;        <br>    <span class="hljs-keyword">if</span>(cur == n)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(remain == <span class="hljs-number">0</span>)<br>    &#123;<br>        res.push_back(temp);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 不选择当前位置，直接跳过</span><br>    dfs(cur + <span class="hljs-number">1</span>, n, candidates, remain);<br>    <span class="hljs-comment">// 选择当前数，不跳过，不跳过的话需要判断当前数是否还能选择</span><br>    <span class="hljs-keyword">if</span>(candidates[cur] &lt;= remain)<br>    &#123;<br>        temp.push_back(candidates[cur]);<br>        remain -= candidates[cur]; <br>        dfs(cur, n, candidates, remain);<br>        temp.pop_back();<br>    &#125;<br>       <br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">combinationSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; candidates, <span class="hljs-keyword">int</span> target)</span> <br></span>&#123;<br>    <span class="hljs-keyword">int</span> n = candidates.size();<br>    dfs(<span class="hljs-number">0</span>, n,candidates, target);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="401-二进制手表"><a href="#401-二进制手表" class="headerlink" title="401. 二进制手表"></a>401. 二进制手表</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;string&gt; res;<br>unordered_map&lt;int, int&gt; hashdata = &#123;&#123;0,1&#125;,&#123;1,2&#125;,&#123;2,4&#125;,&#123;3,8&#125;,&#123;4,1&#125;,&#123;5,2&#125;,&#123;6,4&#125;,&#123;7,8&#125;,&#123;8,16&#125;,&#123;9,32&#125;&#125;;<br>void backtrack(int num,int start,pair&lt;int,int&gt;&amp; time)&#123;<br>    // 结束条件<br>    if(num == 0)<br>    &#123;<br>        if(time.first &gt; 11 || time.second &gt; 59)<br>        &#123;<br>            return;<br>        &#125;<br>        string temp_hour = to_string(time.first);<br>        string temp_minute = to_string(time.second);<br>        if(temp_minute.size() == 1)<br>        &#123;<br>            temp_minute.insert(0, "0");<br>        &#125;<br>        res.push_back(temp_hour + ":" + temp_minute);<br>        return;<br>    &#125;<br>    for(int i = start; i &lt; 10; i++)<br>    &#123;<br>        if(time.first &gt; 11 || time.second &gt; 59)<br>        &#123;<br>            continue;<br>        &#125;<br>        // 在本层中创建一个变量store用来存储当前的time值，回退时使用<br>        pair&lt;int, int&gt; store = time;<br>        if(i &lt; 4)<br>        &#123;<br>            time.first += hashdata[i];<br>        &#125;<br>        else<br>        &#123;<br>            time.second += hashdata[i];<br>        <br>        &#125;<br>        backtrack(num - 1, i + 1, time);<br>        // 在同层回退时把前面存好的store再赋给time，时time恢复到原状态<br>        time = store;<br>        <br>    &#125;<br>&#125;<br><br>vector&lt;string&gt; readBinaryWatch(int num) &#123;<br>    pair&lt;int, int&gt; time(0, 0);<br>    backtrack(num, 0, time);<br>    return res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="40-组合总数2"><a href="#40-组合总数2" class="headerlink" title="40. 组合总数2"></a>40. 组合总数2</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 去重复结果组合使用pair计数，将给的数组里的相同数值的数放在一起去递归处理</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; temp;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br><span class="hljs-built_in">vector</span>&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; freq;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos, <span class="hljs-keyword">int</span> rest)</span><br></span>&#123;<br>    <span class="hljs-keyword">if</span>(rest == <span class="hljs-number">0</span>)<br>    &#123;<br>        res.push_back(temp);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pos == freq.size() || rest &lt; freq[pos].first)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br><br>    dfs(pos+<span class="hljs-number">1</span>, rest);<br><span class="hljs-comment">// most用来判断处理相同数值的数时，进行几次递归，例如有五个2，但是target是7，那么只进行对2这个数值只进行三次递归</span><br>    <span class="hljs-keyword">int</span> most = min(rest / freq[pos].first, freq[pos].second);    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>; a &lt;= most; a++)<br>    &#123;<br>        temp.push_back(freq[pos].first);<br>        dfs(pos+<span class="hljs-number">1</span>, rest - a * freq[pos].first);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> b = <span class="hljs-number">1</span>; b &lt;= most; b++)<br>    &#123;<br>        temp.pop_back();<br>    &#125;<br>  <br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">combinationSum2</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; candidates, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-comment">// vector&lt;pair&lt;int, int&gt;&gt; freq;</span><br>    sort(candidates.begin(), candidates.end());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : candidates)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(freq.empty() || num != freq.back().first)<br>        &#123;<br>            <span class="hljs-comment">// 用push_back的话需要make_pair，用emplace_back则不需要</span><br>            <span class="hljs-comment">// freq.push_back(make_pair(num, 1));</span><br>            freq.emplace_back(num, <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            ++freq.back().second;<br>        &#125;<br>    &#125;<br>    dfs(<span class="hljs-number">0</span>, target);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="216-组合总数3"><a href="#216-组合总数3" class="headerlink" title="216. 组合总数3"></a>216. 组合总数3</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; temp;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> remain, <span class="hljs-keyword">int</span> k)</span><br></span>&#123;<br>    <span class="hljs-keyword">if</span>(remain == <span class="hljs-number">0</span> &amp;&amp; temp.size() == k)<br>    &#123;<br>        res.push_back(temp);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(cur &gt; remain || temp.size() == k || cur &gt; <span class="hljs-number">9</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    temp.push_back(cur);<br>    dfs(cur+<span class="hljs-number">1</span>, remain-cur, k);<br>    temp.pop_back();<br>    dfs(cur+<span class="hljs-number">1</span>, remain, k);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">combinationSum3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    dfs(<span class="hljs-number">1</span>, n, k);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;回溯算法的写法：&quot;&gt;&lt;a href=&quot;#回溯算法的写法：&quot; class=&quot;headerlink&quot; title=&quot;回溯算法的写法：&quot;&gt;&lt;/a&gt;回溯算法的写法：&lt;/h3&gt;&lt;h5 id=&quot;画出递归树，找到状态变量（回溯函数的参数）&quot;&gt;&lt;a href=&quot;#画出递归树，找到
      
    
    </summary>
    
    
      <category term="C++" scheme="https://chasencenge.github.io/categories/C/"/>
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/C/Algorithm/"/>
    
    
      <category term="C++" scheme="https://chasencenge.github.io/tags/C/"/>
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>查找专题</title>
    <link href="https://chasencenge.github.io/2020/09/03/%E6%9F%A5%E6%89%BE%E4%B8%93%E9%A2%98/"/>
    <id>https://chasencenge.github.io/2020/09/03/查找专题/</id>
    <published>2020-09-03T12:56:48.000Z</published>
    <updated>2020-09-03T13:30:16.428Z</updated>
    
    <content type="html"><![CDATA[<h4 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a>4. 寻找两个正序数组的中位数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//二分查找</span><br><span class="hljs-comment">//写一个查找第k大的函数，k值在运行过程中会慢慢减小</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthElement</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2, <span class="hljs-keyword">int</span> k)</span><br></span>&#123;<br>    <span class="hljs-keyword">int</span> m = nums1.size();<br>    <span class="hljs-keyword">int</span> n = nums2.size();<br>    <span class="hljs-keyword">int</span> index1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> index2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-comment">//nums1中的指针位置已经到了末尾，直接在num2中找剩下的第k大</span><br>        <span class="hljs-keyword">if</span> (index1 == m)<br>        &#123;<br>            <span class="hljs-keyword">return</span> nums2[index2 + k - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (index2 == n)<br>        &#123;<br>            <span class="hljs-keyword">return</span> nums1[index1 + k - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> min(nums1[index1], nums2[index2]);<br>        &#125;<br><span class="hljs-comment">//边界检测，index如果加了k / 2 - 1越界了，就直接将新的index设置为数组的最后一位</span><br>        <span class="hljs-keyword">int</span> newIndex1 = min(index1 + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>, m - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">int</span> newIndex2 = min(index2 + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">int</span> pivot1 = nums1[newIndex1];<br>        <span class="hljs-keyword">int</span> pivot2 = nums2[newIndex2];<br>        <span class="hljs-keyword">if</span> (pivot1 &lt;= pivot2)<br>        &#123;<br>            <span class="hljs-comment">//更新k和index</span><br>            k -= newIndex1 - index1 + <span class="hljs-number">1</span>;<br>            index1 = newIndex1 + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            k -= newIndex2 - index2 + <span class="hljs-number">1</span>;<br>            index2 = newIndex2 + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> totalLength = nums1.size() + nums2.size();<br>    <span class="hljs-keyword">if</span> (totalLength % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>    &#123;<span class="hljs-comment">//奇数总数和偶数总数分开讨论</span><br>        <span class="hljs-keyword">return</span> findKthElement(nums1, nums2, (totalLength + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> (findKthElement(nums1, nums2, totalLength / <span class="hljs-number">2</span>) + findKthElement(nums1, nums2, totalLength / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>)) / <span class="hljs-number">2.0</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;4-寻找两个正序数组的中位数&quot;&gt;&lt;a href=&quot;#4-寻找两个正序数组的中位数&quot; class=&quot;headerlink&quot; title=&quot;4. 寻找两个正序数组的中位数&quot;&gt;&lt;/a&gt;4. 寻找两个正序数组的中位数&lt;/h4&gt;&lt;figure class=&quot;highligh
      
    
    </summary>
    
    
      <category term="C++" scheme="https://chasencenge.github.io/categories/C/"/>
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/C/Algorithm/"/>
    
    
      <category term="C++" scheme="https://chasencenge.github.io/tags/C/"/>
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口专题</title>
    <link href="https://chasencenge.github.io/2020/09/03/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%93%E9%A2%98/"/>
    <id>https://chasencenge.github.io/2020/09/03/滑动窗口专题/</id>
    <published>2020-09-03T11:18:54.000Z</published>
    <updated>2020-09-03T11:26:29.186Z</updated>
    
    <content type="html"><![CDATA[<h4 id="3-无重复的最长字串"><a href="#3-无重复的最长字串" class="headerlink" title="3.  无重复的最长字串"></a>3.  无重复的最长字串</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//右指针</span><br>    <span class="hljs-keyword">int</span> rp = <span class="hljs-number">-1</span>;<br>    <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt; seri;<br>    <span class="hljs-comment">//i是左指针</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.size(); i++)<br>    &#123;<br>        <span class="hljs-comment">//每次循环开始的时候把上一次左指针指向的值删掉</span><br>        <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>)<br>        &#123;<br>            seri.erase(s[i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-comment">//例如abcdcefgh，到了第二个c会产生重复，rp会停在d这里，然后删掉a继续循环，发现仍不满足!seri.count(s[rp + 1])，因为c并没被删掉，所以跳过while继续循环，删掉b，知道删掉第一个c，while中才满足!seri.count(s[rp + 1])，这时才能进入while，rp继续向后走</span><br>        <span class="hljs-keyword">while</span> (rp + <span class="hljs-number">1</span> &lt; s.size() &amp;&amp; !seri.count(s[rp + <span class="hljs-number">1</span>]))<br>        &#123;<br>            seri.insert(s[rp + <span class="hljs-number">1</span>]);<br>            rp++;<br>        &#125;<br>        res = max(res, rp - i + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;3-无重复的最长字串&quot;&gt;&lt;a href=&quot;#3-无重复的最长字串&quot; class=&quot;headerlink&quot; title=&quot;3.  无重复的最长字串&quot;&gt;&lt;/a&gt;3.  无重复的最长字串&lt;/h4&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;
      
    
    </summary>
    
    
      <category term="C++" scheme="https://chasencenge.github.io/categories/C/"/>
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/C/Algorithm/"/>
    
    
      <category term="C++" scheme="https://chasencenge.github.io/tags/C/"/>
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer</title>
    <link href="https://chasencenge.github.io/2020/08/24/%E5%89%91%E6%8C%87offer/"/>
    <id>https://chasencenge.github.io/2020/08/24/剑指offer/</id>
    <published>2020-08-24T06:51:21.000Z</published>
    <updated>2020-08-28T08:47:57.550Z</updated>
    
    <content type="html"><![CDATA[<h4 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29. 顺时针打印矩阵"></a>29. 顺时针打印矩阵</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">处理移动四个移动方向用：<br>vector&lt;vector&lt;int&gt;&gt; move&#123; &#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125; &#125;;<br>或者：<br>static constexpr int directions[4][2] = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;<br>标记矩阵的已访问元素和未访问元素用一个相同大小的bool矩阵visit<br>输入一个空matrix时，如果对其求matrix[0].size()会报错，因为没有matrix[0]<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; order;<br><br>    <span class="hljs-keyword">if</span> (matrix.size() == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].size() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> rowRange = matrix.size();<br>    <span class="hljs-keyword">int</span> colRange = matrix[<span class="hljs-number">0</span>].size();<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-title">visit</span><span class="hljs-params">(rowRange, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(colRange))</span></span>;<br>    <span class="hljs-keyword">int</span> total = rowRange * colRange;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; move&#123; &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125; &#125;;<br>    <span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> moveIndex = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> nextRow, nextCol;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; total; i++)<br>    &#123;<br>        order.push_back(matrix[row][col]);<br>        visit[row][col] = <span class="hljs-literal">true</span>;<br>        nextRow = row + move[moveIndex][<span class="hljs-number">0</span>];<br>        nextCol = col + move[moveIndex][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (nextRow &gt;= rowRange || nextRow &lt; <span class="hljs-number">0</span> || nextCol &gt;= colRange || nextCol &lt; <span class="hljs-number">0</span> || visit[nextRow][nextCol])<br>        &#123;<br>            moveIndex = (moveIndex + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;<br>        &#125;<br>        row += move[moveIndex][<span class="hljs-number">0</span>];<br>        col += move[moveIndex][<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> order;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="47-礼物的最大价值"><a href="#47-礼物的最大价值" class="headerlink" title="47. 礼物的最大价值"></a>47. 礼物的最大价值</h4><p>构造“矩阵最优路径的寻径问题”的dp矩阵，dp矩阵每个元素的含义是到当前点的最大收益</p><p>转移方程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j];<br></code></pre></td></tr></table></figure><p>这样的话就需要填充边界：使dp矩阵的维度加一，填充0</p><p>本题的优化：可将dp矩阵维度降为一维，在每一个外层循环中覆盖更新dp</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;29-顺时针打印矩阵&quot;&gt;&lt;a href=&quot;#29-顺时针打印矩阵&quot; class=&quot;headerlink&quot; title=&quot;29. 顺时针打印矩阵&quot;&gt;&lt;/a&gt;29. 顺时针打印矩阵&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;
      
    
    </summary>
    
    
      <category term="C++" scheme="https://chasencenge.github.io/categories/C/"/>
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/C/Algorithm/"/>
    
    
      <category term="C++" scheme="https://chasencenge.github.io/tags/C/"/>
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>dp专题</title>
    <link href="https://chasencenge.github.io/2020/08/18/dp%E4%B8%93%E9%A2%98/"/>
    <id>https://chasencenge.github.io/2020/08/18/dp专题/</id>
    <published>2020-08-18T07:54:15.000Z</published>
    <updated>2020-09-15T11:25:56.625Z</updated>
    
    <content type="html"><![CDATA[<h4 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5.最长回文子串"></a>5.最长回文子串</h4><p>单独处理长度为1和2的字符串</p><p>状态转移：字串加上相同的首尾</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">dp[i][j] = (s[i] == s[j] &amp;&amp; dp[i+1][j-1]);<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>    <span class="hljs-built_in">string</span> ans;<br>    <span class="hljs-keyword">int</span> n = s.size();<br>    <span class="hljs-comment">//初始化二维vector，初始值为0</span><br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n))</span></span>;<br>    <span class="hljs-comment">//外层循环用的是字串的长度，dp矩阵对角线（i==j）代表字串长度为1，对角线两侧的斜线代表字串长度为2，依次往外扩展更新</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>; len &lt; n; len++)<br>    &#123;c<br>        <span class="hljs-comment">//对于dbabcad，首轮更新d, b, a, b, c, a, d对应的dp; 第二轮更新db, ba, ab, bc, ca, ad对应的dp; 然后是dba, bab, abc......（它根据首轮的更新的dp做s[i] == s[j] &amp;&amp; dp[i + 1][j - 1]判断）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - len; i++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> j = i + len;<br>            <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>)<br>            &#123;<br>                dp[i][j] = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>)<br>            &#123;<br>                dp[i][j] = s[i] == s[j];<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                dp[i][j] = (s[i] == s[j] &amp;&amp; dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);<br>            &#125;<br>            <span class="hljs-comment">//如果找到了更长的字串，更新新的字串</span><br>            <span class="hljs-keyword">if</span> (dp[i][j] &amp;&amp; len + <span class="hljs-number">1</span> &gt; ans.size())<br>            &#123;<br>                <span class="hljs-comment">//substr(i, j): 从下标i开始截取j位</span><br>                ans = s.substr(i, len + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a>53. 最大子序和</h4><p>状态转移：nums[i]为当前遍历到的数，比较在已有数组上加上当前数值（数组里加当前数值）和当前数值的大小（开一个新数组）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">max(f[i-1]+nums[i], nums[i])<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; f;<br>        <span class="hljs-keyword">if</span>(nums.empty())<br>        &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>        f.push_back(nums[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.size(); i++)<br>        &#123;<br>            f.push_back(max(f[i<span class="hljs-number">-1</span>]+nums[i], nums[i]));<br>        &#125;<br>        <span class="hljs-keyword">int</span> compare = f[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:f)<br>        &#123;<br>            compare = max(x, compare);<br>        &#125;<br>        <span class="hljs-keyword">return</span> compare;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="超级码力复赛-3-秋叶收藏集"><a href="#超级码力复赛-3-秋叶收藏集" class="headerlink" title="超级码力复赛 3.秋叶收藏集"></a>超级码力复赛 3.秋叶收藏集</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">要将叶子调整为“红黄红”排列，r为红，y为黄，每次可将r调整为y，也可将y调整为r，求调整所需最小次数<br><br>示例：<br>输入：leaves = &quot;rrryyyrryyyrr&quot;<br>输出：2<br>解释：调整两次，将中间的两片红叶替换成黄叶，得到 &quot;rrryyyyyyyyrr&quot;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minimumOperations</span><span class="hljs-params">(<span class="hljs-built_in">string</span> leaves)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = leaves.size();<br>    <span class="hljs-comment">//cout &lt;&lt; "n" &lt;&lt;n &lt;&lt; endl;</span><br>    <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> end = leaves.size() - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n - <span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n - <span class="hljs-number">2</span>, <span class="hljs-number">100000</span>))</span></span>;<br>    <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (leaves[<span class="hljs-number">0</span>] == <span class="hljs-string">'y'</span>)<br>    &#123;<br>        temp++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (leaves[<span class="hljs-number">1</span>] == <span class="hljs-string">'r'</span>)<br>    &#123;<br>        temp++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (leaves[i] == <span class="hljs-string">'y'</span>)<br>        &#123;<br>            temp++;<br>        &#125;<br>    &#125;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = temp;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> y = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span> (x != n - <span class="hljs-number">3</span>)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (y != n - <span class="hljs-number">2</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (leaves[y] == <span class="hljs-string">'y'</span>)<br>                dp[x][y] = dp[x][y - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                dp[x][y] = dp[x][y - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            y++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (x + <span class="hljs-number">2</span> == n - <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//cout &lt;&lt; "test" &lt;&lt; endl;</span><br>        <span class="hljs-keyword">if</span> (leaves[x+<span class="hljs-number">1</span>] == <span class="hljs-string">'y'</span>)<br>            dp[x + <span class="hljs-number">1</span>][x + <span class="hljs-number">2</span>] = dp[x][x + <span class="hljs-number">2</span>] + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            dp[x + <span class="hljs-number">1</span>][x + <span class="hljs-number">2</span>] = dp[x][x + <span class="hljs-number">2</span>] - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//cout &lt;&lt; "test2" &lt;&lt; endl;</span><br>        x++;<br>        y = x + <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//cout &lt;&lt; "x y " &lt;&lt; x &lt;&lt; y &lt;&lt; endl;</span><br>        <span class="hljs-comment">/*for (int a = 0; a &lt; dp.size(); a++)<br>        &#123;<br>            for (int b = 0; b &lt; dp[0].size(); b++)<br>            &#123;<br>                cout &lt;&lt; dp[a][b] &lt;&lt; " ";<br>            &#125;<br>            cout &lt;&lt; endl;<br>        &#125;*/</span><br>    &#125;<br>    <span class="hljs-keyword">int</span> res = dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>; a &lt; dp.size(); a++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>; b &lt; dp[<span class="hljs-number">0</span>].size(); b++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (dp[a][b] &lt; res)<br>            &#123;<br>                res = dp[a][b];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// cout &lt;&lt; res;</span><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;5-最长回文子串&quot;&gt;&lt;a href=&quot;#5-最长回文子串&quot; class=&quot;headerlink&quot; title=&quot;5.最长回文子串&quot;&gt;&lt;/a&gt;5.最长回文子串&lt;/h4&gt;&lt;p&gt;单独处理长度为1和2的字符串&lt;/p&gt;
&lt;p&gt;状态转移：字串加上相同的首尾&lt;/p&gt;
&lt;figu
      
    
    </summary>
    
    
      <category term="Dynamic Programming" scheme="https://chasencenge.github.io/categories/Dynamic-Programming/"/>
    
      <category term="C++" scheme="https://chasencenge.github.io/categories/Dynamic-Programming/C/"/>
    
    
      <category term="C++" scheme="https://chasencenge.github.io/tags/C/"/>
    
      <category term="Dynamic Programming" scheme="https://chasencenge.github.io/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode每日刷题</title>
    <link href="https://chasencenge.github.io/2020/08/03/LeetCode%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/"/>
    <id>https://chasencenge.github.io/2020/08/03/LeetCode每日刷题/</id>
    <published>2020-08-03T15:29:34.000Z</published>
    <updated>2020-09-09T14:00:26.360Z</updated>
    
    <content type="html"><![CDATA[<h4 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a>415. 字符串相加</h4><p>实现两个字符串的数值相加，不能用类型转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">addStrings</span><span class="hljs-params">(<span class="hljs-built_in">string</span> num1, <span class="hljs-built_in">string</span> num2)</span> </span>&#123;<br>    <span class="hljs-comment">//双指针，双指针的“指针”不一定非得是指针类型，能做flag标记就行</span><br><span class="hljs-keyword">int</span> i = num1.length() - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> j = num2.length() - <span class="hljs-number">1</span>;<br><span class="hljs-built_in">string</span> res;<br><span class="hljs-keyword">int</span> multi = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//进位</span><br><span class="hljs-keyword">int</span> add = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span> || add &gt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>)<br>&#123;<br>            <span class="hljs-comment">//两者相减得到的是int型</span><br>x = num1[i] - <span class="hljs-string">'0'</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (j &gt;= <span class="hljs-number">0</span>)<br>&#123;<br>y = num2[j] - <span class="hljs-string">'0'</span>;<br>&#125;<br><span class="hljs-keyword">int</span> result = x + y + add;<br>res.push_back(<span class="hljs-string">'0'</span> + result % <span class="hljs-number">10</span>);<br>add = result / <span class="hljs-number">10</span>;<br>i--;<br>j--;<br>&#125;<br>    <span class="hljs-comment">//因为每次push_back是从低位到高位的，所以结果要翻转</span><br>reverse(res.begin(), res.end());<br><span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a>207. 课程表</h4><p>你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。</p><p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]</p><p>给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入: <span class="hljs-number">2</span>, [[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]] <br>输出: <span class="hljs-literal">true</span><br>解释: 总共有<span class="hljs-number">2</span>门课程。学习课程<span class="hljs-number">1</span>之前，你需要完成课程<span class="hljs-number">0</span>。所以这是可能的<br><br>输入: <span class="hljs-number">2</span>, [[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]]<br>输出: <span class="hljs-literal">false</span><br>解释: 总共有<span class="hljs-number">2</span>门课程。学习课程<span class="hljs-number">1</span>之前，你需要先完成课程<span class="hljs-number">0</span>；并且学习课程<span class="hljs-number">0</span>之前，你还应先完成课程<span class="hljs-number">1</span>。这是不可能的<br></code></pre></td></tr></table></figure><p>我们就可以将本题建模成一个求拓扑排序的问题了：</p><p>我们将每一门课看成一个节点</p><p>如果想要学习课程 A之前必须完成课程 B，那么我们从B到A连接一条有向边。这样以来，在拓扑排序中，B一定出现在 A的前面</p><p><strong>思路：</strong></p><p>考虑拓扑排序中最前面的节点，该节点一定不会有任何入边，也就是它没有任何的先修课程要求。当我们将一个节点加入答案中后，我们就可以移除它的所有出边，代表着它的相邻节点少了一门先修课程的要求。如果某个相邻节点变成了「没有任何入边的节点」，那么就代表着这门课可以开始学习了。按照这样的流程，我们不断地将没有入边的节点加入答案，直到答案中包含所有的节点（得到了一种拓扑排序）或者不存在没有入边的节点（图中包含环）</p><p><strong>算法：</strong></p><p>使用一个队列来进行广度优先搜索。初始时，所有入度为 00 的节点都被放入队列中，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。</p><p>在广度优先搜索的每一步中，我们取出队首的节点u：</p><p>我们将u放入答案中</p><p>我们移除 u的所有出边，也就是将u的所有相邻节点的入度减少1。如果某个相邻节点v的入度变为0，那么我们就将v放入队列中</p><p>在广度优先搜索的过程结束后。如果答案中包含了这n个节点，那么我们就找到了一种拓扑排序，否则说明图中存在环，也就不存在拓扑排序了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numCourses, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br>    <span class="hljs-comment">//入度 in degree</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; indeg;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; edges;<br>    <span class="hljs-comment">//resize内的默认初始化值为0</span><br>    indeg.resize(numCourses);<br>    edges.resize(numCourses);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; info : prerequisites)<br>    &#123;<br>        <span class="hljs-comment">//以info[1]为起始的边，指向info[0]</span><br>        edges[info[<span class="hljs-number">1</span>]].push_back(info[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">//info[0]的入度加一，指向它的是info[1]</span><br>        ++indeg[info[<span class="hljs-number">0</span>]];<br>    &#125;<br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++)<br>    &#123;<br>        <span class="hljs-comment">//把最开始入度为0的点push进去</span><br>        <span class="hljs-keyword">if</span> (indeg[i] == <span class="hljs-number">0</span>)<br>        &#123;<br>            q.push(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> visited = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!q.empty())<br>    &#123;<br>        visited++;<br>        <span class="hljs-keyword">int</span> u = q.front();<br>        q.pop();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v : edges[u])<br>        &#123;<br>            --indeg[v];<br>            <span class="hljs-comment">//如果去掉指向它的u之后，v点的入度变为0，那么push进队列</span><br>            <span class="hljs-keyword">if</span> (indeg[v] == <span class="hljs-number">0</span>)<br>            &#123;<br>                q.push(v);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> visited == numCourses;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="657-机器人能否返回原点"><a href="#657-机器人能否返回原点" class="headerlink" title="657. 机器人能否返回原点"></a>657. 机器人能否返回原点</h4><p>string的遍历不需要迭代器，利用size()和类似数组下标可以直接遍历string</p><h4 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a>347. 前 K 个高频元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 这里的static的添加是因为sory()第三个参数是个函数指针，然而cmp函数是一个非静态成员函数，非静态成员函数指针和普通函数指针是有区别的，为防止报错在类内的成员函数定义前添加static，或者把cmp函数定义写在类外</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; a, pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; b)</span><br>    </span>&#123;<br>        <span class="hljs-keyword">return</span> a.second &gt; b.second;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; countMap;<br>        <span class="hljs-keyword">int</span> n = nums.size();<br>        <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;::iterator it;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-comment">// 判断map中某个key是否存在，使用find()，（find()返回的是迭代器）</span><br>            it = countMap.find(nums[i]);<br>            <span class="hljs-keyword">if</span>(it != countMap.end())<br>            &#123;<br>                countMap[nums[i]]++;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">// map中插入新的&lt;key, value&gt;对</span><br>                countMap.insert(pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;(nums[i], <span class="hljs-number">1</span>));<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// map没有sort()函数，因为map不是线性结构，所以为了排序，将map中的pair形式的成员放到vector中再进行排序</span><br>        <span class="hljs-built_in">vector</span>&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; vec;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;::iterator it = countMap.begin(); it != countMap.end(); it++)<br>        &#123;<br>            vec.push_back(pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;(it-&gt;first, it-&gt;second));<br>        &#125;<br>        sort(vec.begin(), vec.end(), cmp);<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-built_in">vector</span>&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt;::iterator iter = vec.begin();<br>        <span class="hljs-keyword">while</span>(k)<br>        &#123;<br>            res.push_back(iter-&gt;first);<br>            iter++;<br>            k--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="8-字符串转换整数"><a href="#8-字符串转换整数" class="headerlink" title="8. 字符串转换整数"></a>8. 字符串转换整数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 有限自动机，写一个有限自动机类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Automation</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; table = &#123;<br>        &#123;<span class="hljs-string">"start"</span>, &#123;<span class="hljs-string">"start"</span>, <span class="hljs-string">"signed"</span>, <span class="hljs-string">"in_number"</span>, <span class="hljs-string">"end"</span>&#125;&#125;,<br>        &#123;<span class="hljs-string">"signed"</span>, &#123;<span class="hljs-string">"end"</span>, <span class="hljs-string">"end"</span>, <span class="hljs-string">"in_number"</span>, <span class="hljs-string">"end"</span>&#125;&#125;,<br>        &#123;<span class="hljs-string">"in_number"</span>, &#123;<span class="hljs-string">"end"</span>, <span class="hljs-string">"end"</span>, <span class="hljs-string">"in_number"</span>, <span class="hljs-string">"end"</span>&#125;&#125;,<br>        &#123;<span class="hljs-string">"end"</span>, &#123;<span class="hljs-string">"end"</span>, <span class="hljs-string">"end"</span>, <span class="hljs-string">"end"</span>, <span class="hljs-string">"end"</span>&#125;&#125;<br>    &#125;;<br>    <span class="hljs-built_in">string</span> status = <span class="hljs-string">"start"</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_col</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span><br>    </span>&#123;<br>        <span class="hljs-keyword">if</span>(c == <span class="hljs-string">' '</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(c == <span class="hljs-string">'+'</span> || c == <span class="hljs-string">'-'</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isdigit</span>(c))<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> sign = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span><br>    </span>&#123;<br>        status = table[status][get_col(c)];<br>        <span class="hljs-keyword">if</span>(status == <span class="hljs-string">"in_number"</span>)<br>        &#123;<br>            res =  res * <span class="hljs-number">10</span> + (c - <span class="hljs-string">'0'</span>);<br>            res = sign == <span class="hljs-number">1</span> ? min(res, (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)INT_MAX) : min(res, -(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)INT_MIN);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(status == <span class="hljs-string">"signed"</span>)<br>        &#123;<br>            sign = c == <span class="hljs-string">'+'</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str)</span> </span>&#123;<br>        Automation atmn;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : str)<br>        &#123;<br>            atmn.get(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> atmn.sign * atmn.res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9. 回文数"></a>9. 回文数</h4><p>用栈把前半部分push进去，后半部分边判断边pop</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;415-字符串相加&quot;&gt;&lt;a href=&quot;#415-字符串相加&quot; class=&quot;headerlink&quot; title=&quot;415. 字符串相加&quot;&gt;&lt;/a&gt;415. 字符串相加&lt;/h4&gt;&lt;p&gt;实现两个字符串的数值相加，不能用类型转换&lt;/p&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
    
      <category term="C++" scheme="https://chasencenge.github.io/categories/C/"/>
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/C/Algorithm/"/>
    
    
      <category term="C++" scheme="https://chasencenge.github.io/tags/C/"/>
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode top100刷题</title>
    <link href="https://chasencenge.github.io/2020/08/03/LeetCode-top%E5%88%B7%E9%A2%98/"/>
    <id>https://chasencenge.github.io/2020/08/03/LeetCode-top刷题/</id>
    <published>2020-08-03T15:15:27.000Z</published>
    <updated>2020-08-04T16:36:01.715Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//暴力循环</span><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; resV&#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;;<br><span class="hljs-keyword">int</span> find;<br><span class="hljs-keyword">int</span> hasFound = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size() - <span class="hljs-number">1</span>; i++)<br>&#123;<br>resV[<span class="hljs-number">0</span>] = i;<br>find = target - nums[i];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.size(); j++)<br>&#123;<br><span class="hljs-keyword">if</span> (nums[j] == find)<br>&#123;<br>resV[<span class="hljs-number">1</span>] = j;<br>hasFound = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (hasFound == <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> resV;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//先排序，再利用双指针遍历，初始i放首部，j放尾部，两数之和大于target的话j--，小于target的话i++，找到对应的i和j</span><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; resV&#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; copyV = nums;<br>    <span class="hljs-keyword">int</span> find;<br>    <span class="hljs-keyword">int</span> hasFound = <span class="hljs-number">0</span>;<br>    sort(nums.begin(), nums.end());<br>    <span class="hljs-comment">// for(int k = 0; k &lt; nums.size(); k++)</span><br>    <span class="hljs-comment">// &#123;cout &lt;&lt; nums[k] &lt;&lt; " ";&#125;</span><br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> j = nums.size() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i != j &amp;&amp; hasFound == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (target &gt; nums[i] + nums[j])<br>        &#123;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &lt; nums[i] + nums[j])<br>        &#123;<br>            j--;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">//找到i和j还没结束，要根据nums[i], nums[j]找到排序前的数组中对应的原始下标</span><br>            <span class="hljs-comment">//found1防止数组中有相同的值k使得k + k = target导致只能（进入下面的if）更新resV[0]的值</span><br>            <span class="hljs-comment">//这样，如果在原数组中找到第一个k值时进入if，之后继续找到第二个k值的时候便不会再进入if重复更新resV[0]而导致resV[j]不被更新</span><br>            <span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>, found1 = <span class="hljs-number">0</span>, label = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (label != <span class="hljs-number">2</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (copyV[flag] == nums[i] &amp;&amp; found1 == <span class="hljs-number">0</span>)<br>                &#123;<br>                    label++;<br>                    resV[<span class="hljs-number">0</span>] = flag;<br>                    found1 = <span class="hljs-number">1</span>;<br>                    flag++;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (copyV[flag] == nums[j])<br>                &#123;<br>                    label++;<br>                    resV[<span class="hljs-number">1</span>] = flag;<br>                    flag++;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    flag++;<br>                &#125;<br>            &#125;<br>            hasFound = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> resV;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h4><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入：(<span class="hljs-number">2</span> -&gt; <span class="hljs-number">4</span> -&gt; <span class="hljs-number">3</span>) + (<span class="hljs-number">5</span> -&gt; <span class="hljs-number">6</span> -&gt; <span class="hljs-number">4</span>)<br>输出：<span class="hljs-number">7</span> -&gt; <span class="hljs-number">0</span> -&gt; <span class="hljs-number">8</span><br>原因：<span class="hljs-number">342</span> + <span class="hljs-number">465</span> = <span class="hljs-number">807</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>    <span class="hljs-comment">//结构体指针初始化的时候要new一个（创建不在栈上的对象用new）</span><br>    ListNode* res = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">-1</span>);<br>    <span class="hljs-comment">//temp用来移动，res保证最后return的时候找得到链表头部</span><br>    ListNode* temp = res;<br>    ListNode* p = l1;<br>    ListNode* q = l2;<br>    <span class="hljs-keyword">int</span> add = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-comment">//处理对称长度部分</span><br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span> &amp;&amp; q != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        i = (p-&gt;val + q-&gt;val + add) % <span class="hljs-number">10</span>;<br>        <span class="hljs-comment">//每个next节点都需要new一下，确定有下一位再new下一位</span><br>        temp-&gt;next = <span class="hljs-keyword">new</span> ListNode(i);<br>        add = (p-&gt;val + q-&gt;val + add) / <span class="hljs-number">10</span>;<br>        temp = temp-&gt;next;<br>        p = p-&gt;next;<br>        q = q-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">//处理不对称部分</span><br>    <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">nullptr</span> &amp;&amp; q == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            i = (p-&gt;val + add) % <span class="hljs-number">10</span>;<br>            temp-&gt;next = <span class="hljs-keyword">new</span> ListNode(i);<br>            add = (p-&gt;val + add) / <span class="hljs-number">10</span>;<br>            temp = temp-&gt;next;<br>            p = p-&gt;next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q != <span class="hljs-literal">nullptr</span> &amp;&amp; p == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (q != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            i = (q-&gt;val + add) % <span class="hljs-number">10</span>;<br>            temp-&gt;next = <span class="hljs-keyword">new</span> ListNode(i);<br>            add = (q-&gt;val + add) / <span class="hljs-number">10</span>;<br>            temp = temp-&gt;next;<br>            q = q-&gt;next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">//这个if是处理l1和l2长度相同的情况下，最高位的进位</span><br>        <span class="hljs-keyword">if</span> (add != <span class="hljs-number">0</span>)<br>        &#123;<br>            temp-&gt;next = <span class="hljs-keyword">new</span> ListNode(add);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//这个if是处理l1和l2长度不相同的情况下，最高位的进位，也就是在上面if或者else if跑完之后进行的判断</span><br>    <span class="hljs-keyword">if</span> (add != <span class="hljs-number">0</span>)<br>    &#123;<br>        temp-&gt;next = <span class="hljs-keyword">new</span> ListNode(add);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-两数之和&quot;&gt;&lt;a href=&quot;#1-两数之和&quot; class=&quot;headerlink&quot; title=&quot;1. 两数之和&quot;&gt;&lt;/a&gt;1. 两数之和&lt;/h4&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
      
    
    </summary>
    
    
      <category term="C++" scheme="https://chasencenge.github.io/categories/C/"/>
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/C/Algorithm/"/>
    
    
      <category term="C++" scheme="https://chasencenge.github.io/tags/C/"/>
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode200周赛</title>
    <link href="https://chasencenge.github.io/2020/08/02/LeetCode%E5%91%A8%E8%B5%9B/"/>
    <id>https://chasencenge.github.io/2020/08/02/LeetCode周赛/</id>
    <published>2020-08-02T14:18:15.000Z</published>
    <updated>2020-08-10T15:41:51.654Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个整数数组 arr ，以及 a、b 、c 三个整数。请你统计其中好三元组的数量</p><p>如果三元组 (arr[i], arr[j], arr[k]) 满足下列全部条件，则认为它是一个 好三元组 </p><p>0 &lt;= i &lt; j &lt; k &lt; arr.length</p><p>|arr[i] - arr[j]| &lt;= a</p><p>|arr[j] - arr[k]| &lt;= b</p><p>|arr[i] - arr[k]| &lt;= c</p><p>其中 |x| 表示 x 的绝对值</p><p>返回 好三元组的数量 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">输入：arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3<br>输出：4<br>解释：一共有 4 个好三元组：[(3,0,1), (3,0,1), (3,1,1), (0,1,1)]<br><br>输入：arr = [1,1,2,2,3], a = 0, b = 0, c = 1<br>输出：0<br>解释：不存在满足所有条件的三元组<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countGoodTriplets</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br><span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.size() - <span class="hljs-number">2</span>; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.size() - <span class="hljs-number">1</span>; j++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = j + <span class="hljs-number">1</span>; k &lt; arr.size(); k++)<br>&#123;<br>                <span class="hljs-comment">//使用abs()需引用cmath头文件</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(arr[i] - arr[j]) &lt;= a &amp;&amp; <span class="hljs-built_in">abs</span>(arr[j] - arr[k]) &lt;= b &amp;&amp; <span class="hljs-built_in">abs</span>(arr[i] - arr[k]) &lt;= c)<br>&#123;<br>res++;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>给你一个由 不同 整数组成的整数数组 arr 和一个整数 k </p><p>每回合游戏都在数组的前两个元素（即 arr[0] 和 arr[1] ）之间进行。比较 arr[0] 与 arr[1] 的大小，较大的整数将会取得这一回合的胜利并保留在位置 0 ，较小的整数移至数组的末尾。当一个整数赢得 k 个连续回合时，游戏结束，该整数就是比赛的 赢家 </p><p>返回赢得比赛的整数</p><p>题目数据 保证 游戏存在赢家</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入：arr = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>], k = <span class="hljs-number">10</span><br>输出：<span class="hljs-number">3</span><br>解释：<span class="hljs-number">3</span> 将会在前 <span class="hljs-number">10</span> 个回合中连续获胜<br>    <br>输入：arr = [<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], k = <span class="hljs-number">7</span><br>输出：<span class="hljs-number">9</span><br>    <br>输入：arr = [<span class="hljs-number">1</span>,<span class="hljs-number">11</span>,<span class="hljs-number">22</span>,<span class="hljs-number">33</span>,<span class="hljs-number">44</span>,<span class="hljs-number">55</span>,<span class="hljs-number">66</span>,<span class="hljs-number">77</span>,<span class="hljs-number">88</span>,<span class="hljs-number">99</span>], k = <span class="hljs-number">1000000000</span><br>输出：<span class="hljs-number">99</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//vector操作</span><br>a.erase(a.begin()+<span class="hljs-number">1</span>,a.begin()+<span class="hljs-number">3</span>); <span class="hljs-comment">//包前不包后，删除第1、2个元素</span><br>a.insert(a.begin()+<span class="hljs-number">1</span>,<span class="hljs-number">5</span>); <span class="hljs-comment">//在a的第1个元素（从第0个算起）的位置插入数值5</span><br>a.insert(a.begin()+<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>); <span class="hljs-comment">//在a的第1个元素（从第0个算起）的位置插入3个数，其值都为5</span><br>a.back(); <span class="hljs-comment">//返回a的最后一个元素</span><br>a.front(); <span class="hljs-comment">//返回a的第一个元素</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//按命题逻辑操作vector，遇到超长数组同时超大K值时会超时</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getWinner</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> res = arr[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">if</span> (k &gt; arr.size())<br>&#123;<br>k = arr.size();<br>&#125;<br><br><span class="hljs-keyword">while</span> (num &lt; k)<br>&#123;<br><span class="hljs-keyword">if</span> (arr[<span class="hljs-number">0</span>] &gt; arr[<span class="hljs-number">1</span>])<br>&#123;<br>num++;<br><span class="hljs-keyword">int</span> temp = arr[<span class="hljs-number">1</span>];<br>arr.erase(arr.begin() + <span class="hljs-number">1</span>, arr.begin() + <span class="hljs-number">2</span>);<br>arr.push_back(temp);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>num = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> temp = arr[<span class="hljs-number">0</span>];<br>res = arr[<span class="hljs-number">1</span>];<br>arr.erase(arr.begin(), arr.begin() + <span class="hljs-number">1</span>);<br>arr.push_back(temp);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//trick，不用按题述方式操作vector，从前向后遍历即可</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getWinner</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> res = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">if</span> (k &gt; arr.size())<br>    &#123;<br>    k = arr.size();<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.size(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(arr[i]&gt;arr[i+<span class="hljs-number">1</span>])<br>            &#123;<br>                <span class="hljs-comment">//直接修改arr[i+1]的值为arr[i]，这样继续和后面比较时仍是类似命题中的：上一组的较大者和新数值比较</span><br>                arr[i+<span class="hljs-number">1</span>] = arr[i];<br>                num++;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">//当遇到前者小于后者的情况，看此时的num值是否满足大于等于k的要求，符合即作为结果返回</span><br>                <span class="hljs-keyword">if</span>(num &gt;= k)<br>                &#123;<br>                    <span class="hljs-keyword">return</span> arr[i];<br>                &#125;<br>                <span class="hljs-comment">//不符合则设置num为1，不设置为0的原因是因为已经淘汰掉上一个值，已经赢了一回合</span><br>                res = arr[i+<span class="hljs-number">1</span>];<br>                num = <span class="hljs-number">1</span>; <br>            &#125;<br>        &#125;<br>    <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><p>给你一个 n x n 的二进制网格 grid，每一次操作中，你可以选择网格的 相邻两行 进行交换</p><p>一个符合要求的网格需要满足主对角线以上的格子全部都是 0 </p><p>请你返回使网格满足要求的最少操作次数，如果无法使网格符合要求，请你返回 -1 </p><p>主对角线指的是从 (1, 1) 到 (n, n) 的这些格子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">输入：grid = [[0,0,1],[1,1,0],[1,0,0]]<br>输出：3<br><br>输入：grid = [[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,1,1,0]]<br>输出：-1<br>解释：所有行都是一样的，交换相邻行无法使网格符合要求<br><br>输入：grid = [[1,0,0],[1,1,0],[1,1,1]]<br>输出：0<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//贪心</span><br><span class="hljs-comment">//从第一行开始，如果该行的后缀0满足条件，那么直接跳过进入下一行（因为需要的后缀0个数是从大到小的顺序（理解这一点非常重要），所以不必担心前面的会抢后面的，自己不够用的时候放心的去抢后面的，因为当前行的需求（优先级）比后面都高）</span><br><span class="hljs-comment">//如果该行后缀0个数不满足条件，那么就往下遍历找到最先（贪心，这是最小次数）满足条件的行，一行一行换上来，记录交换的次数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minSwaps</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; resV;<br><span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> n = grid.size();<br>    <span class="hljs-comment">//统计每行后缀0个数，存到resV中</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br><span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; grid[i].size(); j++)<br>&#123;<br><span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">0</span>)<br>&#123;<br>    num++;<br>&#125;<br><span class="hljs-keyword">else</span> <br>&#123;<br>    num = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>resV.push_back(num);<br>&#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)<br>    &#123;<br>        <span class="hljs-comment">//如果当前行的后缀0个数够用，直接往下遍历，不用担心抢了后面的，因为当前行的需求量比后面的都高</span><br>        <span class="hljs-keyword">if</span>(resV[i] &gt;= n - i - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(resV[j] &lt; n - i - <span class="hljs-number">1</span> )<br>            &#123;<br>                j++;<br>                <span class="hljs-comment">//找到最后都没有找到满足个数的后缀0，就直接退出</span><br>                <span class="hljs-keyword">if</span>(j == n)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            &#125;<br>            <span class="hljs-comment">//while之后到这里说明找到了一行满足当前行的后缀0的个数需求，把找到的行一行一行的往上换，换到当前行，每次swap的同时更新交换次数</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> m = j; m &gt; i; m--)<br>            &#123;<br>                swap(resV[m], resV[m - <span class="hljs-number">1</span>]);<br>                res++;<br>            &#125;    <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5484-找出第-N-个二进制字符串中的第-K-位"><a href="#5484-找出第-N-个二进制字符串中的第-K-位" class="headerlink" title="5484. 找出第 N 个二进制字符串中的第 K 位"></a>5484. 找出第 N 个二进制字符串中的第 K 位</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">输入：n = 3, k = 1<br>输出：&quot;0&quot;<br>解释：S3 为 &quot;0111001&quot;，其第 1 位为 &quot;0&quot; <br><br>输入：n = 4, k = 11<br>输出：&quot;1&quot;<br>解释：S4 为 &quot;011100110110001&quot;，其第 11 位为 &quot;1&quot;<br><br>输入：n = 1, k = 1<br>输出：&quot;0&quot;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// invert处理    </span><br><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">ch_not</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">'0'</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">'1'</span>; &#125;<br>        <span class="hljs-keyword">else</span>          &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">'0'</span>; &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">findKthBit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">'0'</span>; &#125;<br>        <span class="hljs-comment">// 1左移n-1位，pow(2, n-1)</span><br>        <span class="hljs-keyword">int</span> mid = (<span class="hljs-number">1</span>&lt;&lt;(n<span class="hljs-number">-1</span>));<br>        <span class="hljs-keyword">if</span>(k == mid) &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">'1'</span>; &#125;<br>        <span class="hljs-keyword">if</span>(k &lt; mid) &#123; <span class="hljs-keyword">return</span> findKthBit(n<span class="hljs-number">-1</span>, k); &#125;<br>        <span class="hljs-comment">// k &gt; mid的情况需要把k挪到对称位置：(1&lt;&lt;n) - k，并进行invert</span><br>        <span class="hljs-keyword">return</span> ch_not(findKthBit(n<span class="hljs-number">-1</span>, (<span class="hljs-number">1</span>&lt;&lt;n) - k)); <br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="5483-整理字符串"><a href="#5483-整理字符串" class="headerlink" title="5483. 整理字符串"></a>5483. 整理字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">输入：s = &quot;leEeetcode&quot;<br>输出：&quot;leetcode&quot;<br>解释：无论你第一次选的是 i = 1 还是 i = 2，都会使 &quot;leEeetcode&quot; 缩减为 &quot;leetcode&quot;<br><br>输入：s = &quot;abBAcC&quot;<br>输出：&quot;&quot;<br>解释：存在多种不同情况，但所有的情况都会导致相同的结果。例如：<br>&quot;abBAcC&quot; --&gt; &quot;aAcC&quot; --&gt; &quot;cC&quot; --&gt; &quot;&quot;<br>&quot;abBAcC&quot; --&gt; &quot;abBA&quot; --&gt; &quot;aA&quot; --&gt; &quot;&quot;<br><br>输入：s = &quot;s&quot;<br>输出：&quot;s&quot;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">makeGood</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i != s.length() - <span class="hljs-number">1</span>)<br>&#123;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; s.length() - <span class="hljs-number">1</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(s[i] - s[i + <span class="hljs-number">1</span>]) == <span class="hljs-number">32</span>)<br>        &#123;<br>            s.erase(i, <span class="hljs-number">2</span>);<br>            i = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(s.empty())<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//William Lin版</span><br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">makeGood</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span><br></span>&#123;<br>    <span class="hljs-keyword">bool</span> ch = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(ch)<br>    &#123;<br>        ch = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">string</span> t = s;<br>        <span class="hljs-comment">//size()返回类型是size_t, (unsigned) 和后面的int相减可能会溢出</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-keyword">int</span>)s.size() - <span class="hljs-number">1</span>; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i] + <span class="hljs-number">32</span> == s[i + <span class="hljs-number">1</span>] || s[i + <span class="hljs-number">1</span>] + <span class="hljs-number">32</span> == s[i])<br>            &#123;<br>                <span class="hljs-comment">//string的substr()使用，带首不带尾，单个参数默认从参数位置取到末尾</span><br>                t = s.substr(<span class="hljs-number">0</span>, i) + s.substr(i + <span class="hljs-number">2</span>);<br>            ch = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        s = t;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5468-第-k-个缺失的正整数"><a href="#5468-第-k-个缺失的正整数" class="headerlink" title="5468. 第 k 个缺失的正整数"></a>5468. 第 k 个缺失的正整数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">输入：arr = [2,3,4,7,11], k = 5<br>输出：9<br>解释：缺失的正整数包括 [1,5,6,8,9,10,12,13,...]<br><br>输入：arr = [1,2,3,4], k = 2<br>输出：6<br>解释：缺失的正整数包括 [5,6,7,...]<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthPositive</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> init = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> resNum = <span class="hljs-number">0</span>;<br>    res = arr[<span class="hljs-number">0</span>] - init <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(res &gt;= k)<br>    &#123;<br>        <span class="hljs-keyword">return</span> k;<br>    &#125;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; arr.size() &amp;&amp; res &lt; k)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(res + arr[i] - arr[i<span class="hljs-number">-1</span>] - <span class="hljs-number">1</span> &lt; k)<br>        &#123;<br>            res += arr[i] - arr[i<span class="hljs-number">-1</span>] - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            resNum = arr[i<span class="hljs-number">-1</span>] + (k - res); <br>            res = k;<br>        &#125;<br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(i == arr.size() &amp;&amp; res &lt; k)<br>    &#123;<br>        resNum = arr.back() + (k - res);<br>    &#125;<br>    <span class="hljs-keyword">return</span> resNum;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5469-K-次操作转变字符串"><a href="#5469-K-次操作转变字符串" class="headerlink" title="5469. K 次操作转变字符串"></a>5469. K 次操作转变字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">输入：s = &quot;input&quot;, t = &quot;ouput&quot;, k = 9<br>输出：true<br>解释：第 6 次操作时，我们将 &apos;i&apos; 切换 6 次得到 &apos;o&apos; 。第 7 次操作时，我们将 &apos;n&apos; 切换 7 次得到 &apos;u&apos;<br><br>输入：s = &quot;abc&quot;, t = &quot;bcd&quot;, k = 10<br>输出：false<br>解释：我们需要将每个字符切换 1 次才能得到 t 。我们可以在第 1 次操作时将 &apos;a&apos; 切换成 &apos;b&apos; ，但另外 2 个字母在剩余操作中无法再转变为 t 中对应字母<br><br>输入：s = &quot;aab&quot;, t = &quot;bbb&quot;, k = 27<br>输出：true<br>解释：第 1 次操作时，我们将第一个 &apos;a&apos; 切换 1 次得到 &apos;b&apos; 。在第 27 次操作时，我们将第二个字母 &apos;a&apos; 切换 27 次得到 &apos;b&apos;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//结果出现的位置有数组首之前，数组中间，数组末尾之后，分别处理</span><br><span class="hljs-comment">//创建一个数组存储每一位需要的操作数，将操作数按大小排好，一次遍历去对应k值看是否满足要求</span><br><span class="hljs-comment">//addNum记录某个操作数出现的次数，比如6在某一位上出现一次，某另一位的操作数也是6，那么操作数只能选择6 + 26，第三次出现时操作数为6 + 26 * 2</span><br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canConvertString</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> t, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s.length() != t.length())<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; resV;<br>        <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (t[i] - s[i] &gt;= <span class="hljs-number">0</span>)<br>            &#123;<br>                temp = t[i] - s[i];<br>                addNum[temp] += <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                temp = t[i] - <span class="hljs-string">'a'</span> + <span class="hljs-string">'z'</span> - s[i] + <span class="hljs-number">1</span>;<br>                addNum[temp] += <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">//操作数为0是可以重复的，不需要加重叠次数*26</span><br>            <span class="hljs-keyword">if</span> (temp != <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">int</span> pushNum = temp + <span class="hljs-number">26</span> * (addNum[temp] - <span class="hljs-number">1</span>);<br>                resV.push_back(pushNum);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                resV.push_back(temp);<br>            &#125;<br>        &#125;<br>        sort(resV.begin(), resV.end());<br>        <span class="hljs-keyword">while</span> (!resV.empty() &amp;&amp; resV.back() != <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (k &gt; resV.back())<br>            &#123;<br>                k = resV.back() - <span class="hljs-number">1</span>;<br>                resV.pop_back();<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == resV.back())<br>            &#123;<br>                resV.pop_back();<br>                k--;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="1546-和为目标值的最大数目不重叠非空子数组数目"><a href="#1546-和为目标值的最大数目不重叠非空子数组数目" class="headerlink" title="1546. 和为目标值的最大数目不重叠非空子数组数目"></a>1546. 和为目标值的最大数目不重叠非空子数组数目</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined">输入：nums = [1,1,1,1,1], target = 2<br>输出：2<br>解释：总共有 2 个不重叠子数组（加粗数字表示） [1,1,1,1,1] ，它们的和为目标值 2 <br><br>输入：nums = [-1,3,5,1,4,2,-9], target = 6<br>输出：2<br>解释：总共有 3 个子数组和为 6 。<br>([5,1], [4,2], [3,5,1,4,2,-9]) 但只有前 2 个是不重叠的<br><br>输入：nums = [-2,6,6,3,5,4,1,2,8], target = 10<br>输出：3<br><br>输入：nums = [0,0,0], target = 0<br>输出：3<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 贪心</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxNonOverlapping</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span><br></span>&#123;<br>    <span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; s;<br>    <span class="hljs-comment">//初始时累计值为0，保证在&#123;-1, 3, 5, 1&#125;中找target=6时能找去掉-1, 3，找到&#123;5, 1&#125;</span><br>    s.insert(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">int</span> ps = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//一个替代遍历vector中每个值的方法（不关注下标时可使用）</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a : nums)<br>    &#123;<br>        <span class="hljs-comment">//记录到每个当前值的累计值，其中的两个值相减就是两者之间的子数组中的各个值和</span><br>        ps += a;<br>        <span class="hljs-comment">//注意理解ps - target的含义，是在当前位置根据target找前面是否有能截断而得到要的子数组的位置</span><br>        <span class="hljs-keyword">if</span>(s.find(ps - target != s.end()))<br>        &#123;<br>            ++ans;<br>            s.clear();<br>        &#125;<br>        s.insert(ps);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给你一个整数数组 arr ，以及 a、b 、c 三个整数。请你统计其中好三元组的数量&lt;/p&gt;
&lt;p&gt;如果三元组 (arr[i], arr[j], arr[k]) 满足下列全部条件，则认为它是一个 好三元组 &lt;/p&gt;
&lt;p&gt;0 &amp;lt;= i &amp;lt; j &amp;lt; k &amp;l
      
    
    </summary>
    
    
      <category term="C++" scheme="https://chasencenge.github.io/categories/C/"/>
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/C/Algorithm/"/>
    
    
      <category term="C++" scheme="https://chasencenge.github.io/tags/C/"/>
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode广度优先搜索</title>
    <link href="https://chasencenge.github.io/2020/08/01/LeetCode%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <id>https://chasencenge.github.io/2020/08/01/LeetCode广度优先搜索/</id>
    <published>2020-08-01T10:13:29.000Z</published>
    <updated>2020-08-04T02:49:38.261Z</updated>
    
    <content type="html"><![CDATA[<h4 id="107-二叉树的层次遍历"><a href="#107-二叉树的层次遍历" class="headerlink" title="107. 二叉树的层次遍历"></a>107. 二叉树的层次遍历</h4><p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><h5 id="STL-queue："><a href="#STL-queue：" class="headerlink" title="STL queue："></a>STL queue：</h5><p>原理：队尾（rear）插入，队首（front）删除</p><p>头文件： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">#include&lt;queue&gt;<br></code></pre></td></tr></table></figure><p>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">push(): 推一个元素进队列<br>front(): 返回队首元素(栈对应的是top())<br>back(): 返回队尾元素<br>pop(): 移除队首元素<br>empty()<br>size()<br></code></pre></td></tr></table></figure><p>创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">queue&lt;string&gt; q;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**<br> * Definition for a binary tree node.<br> * struct TreeNode &#123;<br> *     int val;<br> *     TreeNode *left;<br> *     TreeNode *right;<br> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;<br> * &#125;;<br> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">levelOrderBottom</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; resV;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; levelNumV;<br>        TreeNode* cur = root;<br>        <span class="hljs-comment">//层次遍历借助队列实现</span><br>        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; q;<br>        q.push(cur);<br>        <span class="hljs-comment">//跳出遍历的条件为队列为空</span><br>        <span class="hljs-keyword">while</span>(!q.empty())<br>        &#123;<br>            <span class="hljs-keyword">int</span> size = q.size();<br>            <span class="hljs-keyword">while</span>(size-- &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                cur = q.front();<br>                <span class="hljs-comment">//砍头操作</span><br>                q.pop();<br>                <span class="hljs-keyword">if</span>(cur)<br>                &#123;<br>                levelNumV.push_back(cur-&gt;val);<br>                <span class="hljs-comment">//爆菊操作</span><br>                q.push(cur-&gt;left);<br>                q.push(cur-&gt;right);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!levelNumV.empty())<br>            &#123;<br>            <span class="hljs-comment">//输出格式不是规则的二维数组可选用vector&lt;vector&gt;，它的push_back内容为vector（不限制子vector长度）</span><br>            resV.push_back(levelNumV);<br>            levelNumV.clear();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//vector中reverse的使用</span><br>        reverse(resV.begin(), resV.end());<br>        <span class="hljs-keyword">return</span> resV;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a>207. 课程表</h4><p>你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。</p><p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]</p><p>给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入: <span class="hljs-number">2</span>, [[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]] <br>输出: <span class="hljs-literal">true</span><br>解释: 总共有<span class="hljs-number">2</span>门课程。学习课程<span class="hljs-number">1</span>之前，你需要完成课程<span class="hljs-number">0</span>。所以这是可能的<br><br>输入: <span class="hljs-number">2</span>, [[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]]<br>输出: <span class="hljs-literal">false</span><br>解释: 总共有<span class="hljs-number">2</span>门课程。学习课程<span class="hljs-number">1</span>之前，你需要先完成课程<span class="hljs-number">0</span>；并且学习课程<span class="hljs-number">0</span>之前，你还应先完成课程<span class="hljs-number">1</span>。这是不可能的<br></code></pre></td></tr></table></figure><p>我们就可以将本题建模成一个求拓扑排序的问题了：</p><p>我们将每一门课看成一个节点</p><p>如果想要学习课程 A之前必须完成课程 B，那么我们从B到A连接一条有向边。这样以来，在拓扑排序中，B一定出现在 A的前面</p><p><strong>思路：</strong></p><p>考虑拓扑排序中最前面的节点，该节点一定不会有任何入边，也就是它没有任何的先修课程要求。当我们将一个节点加入答案中后，我们就可以移除它的所有出边，代表着它的相邻节点少了一门先修课程的要求。如果某个相邻节点变成了「没有任何入边的节点」，那么就代表着这门课可以开始学习了。按照这样的流程，我们不断地将没有入边的节点加入答案，直到答案中包含所有的节点（得到了一种拓扑排序）或者不存在没有入边的节点（图中包含环）</p><p><strong>算法：</strong></p><p>使用一个队列来进行广度优先搜索。初始时，所有入度为 00 的节点都被放入队列中，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。</p><p>在广度优先搜索的每一步中，我们取出队首的节点u：</p><p>我们将u放入答案中</p><p>我们移除 u的所有出边，也就是将u的所有相邻节点的入度减少1。如果某个相邻节点v的入度变为0，那么我们就将v放入队列中</p><p>在广度优先搜索的过程结束后。如果答案中包含了这n个节点，那么我们就找到了一种拓扑排序，否则说明图中存在环，也就不存在拓扑排序了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numCourses, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br>    <span class="hljs-comment">//入度 in degree</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; indeg;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; edges;<br>    <span class="hljs-comment">//resize内的默认初始化值为0</span><br>    indeg.resize(numCourses);<br>    edges.resize(numCourses);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; info : prerequisites)<br>    &#123;<br>        <span class="hljs-comment">//以info[1]为起始的边，指向info[0]</span><br>        edges[info[<span class="hljs-number">1</span>]].push_back(info[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">//info[0]的入度加一，指向它的是info[1]</span><br>        ++indeg[info[<span class="hljs-number">0</span>]];<br>    &#125;<br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++)<br>    &#123;<br>        <span class="hljs-comment">//把最开始入度为0的点push进去</span><br>        <span class="hljs-keyword">if</span> (indeg[i] == <span class="hljs-number">0</span>)<br>        &#123;<br>            q.push(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> visited = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!q.empty())<br>    &#123;<br>        visited++;<br>        <span class="hljs-keyword">int</span> u = q.front();<br>        q.pop();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v : edges[u])<br>        &#123;<br>            --indeg[v];<br>            <span class="hljs-comment">//如果去掉指向它的u之后，v点的入度变为0，那么push进队列</span><br>            <span class="hljs-keyword">if</span> (indeg[v] == <span class="hljs-number">0</span>)<br>            &#123;<br>                q.push(v);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> visited == numCourses;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;107-二叉树的层次遍历&quot;&gt;&lt;a href=&quot;#107-二叉树的层次遍历&quot; class=&quot;headerlink&quot; title=&quot;107. 二叉树的层次遍历&quot;&gt;&lt;/a&gt;107. 二叉树的层次遍历&lt;/h4&gt;&lt;p&gt;给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按
      
    
    </summary>
    
    
      <category term="C++" scheme="https://chasencenge.github.io/categories/C/"/>
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/C/Algorithm/"/>
    
    
      <category term="C++" scheme="https://chasencenge.github.io/tags/C/"/>
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>字节夏令营20游戏程序笔试题</title>
    <link href="https://chasencenge.github.io/2020/08/01/%E5%AD%97%E8%8A%82%E5%A4%8F%E4%BB%A4%E8%90%A520%E6%B8%B8%E6%88%8F%E7%A8%8B%E5%BA%8F%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    <id>https://chasencenge.github.io/2020/08/01/字节夏令营20游戏程序笔试题/</id>
    <published>2020-08-01T03:42:48.000Z</published>
    <updated>2020-08-02T15:52:41.495Z</updated>
    
    <content type="html"><![CDATA[<p>给素材分类，若作品1中有素材1和素材2，则认为素材1和素材2为一类，若作品2中有素材2和素材3，那么此后认为素材1、2、3为一类</p><p>输入：第一行为作品数n，此后n行中每行第一位为该作品中的素材总数m，此后m个数字为素材名（int型）</p><p>输出：素材的分类，并且每一类素材，类内顺序由小到大，类外顺序按照类内最小值由小到大排序输出</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">输入：<br>4<br>2 1 3<br>3 0 5 6<br>3 2 3 4<br>1 7<br><br>输出：<br>0 5 6<br>1 2 3 4<br>7<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; resV;<br>    <span class="hljs-keyword">int</span> num;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; num;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> cat;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; cat;<br>        <span class="hljs-comment">//存放该作品内所有素材的vector</span><br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; tempV;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cat; j++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> mem;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; mem;<br>            tempV.push_back(mem);<br>            <span class="hljs-comment">//cout &lt;&lt; tempV[j];</span><br>        &#125;<br>        <span class="hljs-comment">//能否找到已存在的类，能找到就将tempV添加进去</span><br>        <span class="hljs-keyword">int</span> label = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; tempV.size(); k++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> out = <span class="hljs-number">0</span>; out &lt; resV.size(); out++)<br>            &#123;<br>                <span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> in = <span class="hljs-number">0</span>; in &lt; resV[out].size(); in++)<br>                &#123;<br>                    <br>                    <span class="hljs-keyword">if</span> (tempV[k] == resV[out][in])<br>                    &#123;<br>                        label = <span class="hljs-number">1</span>;<br>                        flag = <span class="hljs-number">1</span>;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> copy = <span class="hljs-number">0</span>; copy &lt; tempV.size(); copy++)<br>                        &#123;<br>                            <span class="hljs-comment">//检查重复素材，重复的素材不添加，只在已有的分类中添加还未加入的素材</span><br>                            <span class="hljs-keyword">if</span> (find(resV[out].begin(), resV[out].end(), tempV[copy]) == resV[out].end())<br>                                resV[out].push_back(tempV[copy]);<br>                        &#125;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;   <br>                &#125;<br>                <span class="hljs-comment">//不用再继续遍历后面的子vector了，添加进一个分类中就一定不会添加进另外一个分类</span><br>                <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//是新的素材分类</span><br>        <span class="hljs-keyword">if</span> (label == <span class="hljs-number">0</span>)<br>        &#123;<br>            resV.push_back(tempV);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//子vector按最小元素排序</span><br>    sort(resV.begin(), resV.end());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; resV.size(); i++)<br>    &#123;<br>        <span class="hljs-comment">//子vector内部排序</span><br>        sort(resV[i].begin(), resV[i].end());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; resV[i].size(); j++)<br>            <span class="hljs-built_in">cout</span> &lt;&lt; resV[i][j] &lt;&lt; <span class="hljs-string">" "</span>;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>计算给出时间和格林尼治时间之间的秒数，格式：YYYY/MM/DD hh:mm:ss</p><p>需要考虑平年和闰年</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-built_in">string</span> date, time;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; date &gt;&gt; time;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> year, month, day;<br>    <span class="hljs-comment">//切分成子字符串之后再转整型，赋给年月日时分秒</span><br>    <span class="hljs-comment">//atoi()的参数是 const char* ,因此对于一个字符串str我们必须调用c_str()的方法把这个string转换成const char*类型的</span><br>    <span class="hljs-comment">//substr(pos, num)两个参数是从起始位置和pos开始取的字符个数，而不是起始位置和末尾位置</span><br>    year = atoi(date.substr(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>).c_str());<br>    month = atoi(date.substr(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>).c_str());<br>    day = atoi(date.substr(<span class="hljs-number">8</span>, <span class="hljs-number">2</span>).c_str());<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> hour, minute, second;<br>    hour = atoi(time.substr(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>).c_str());<br>    minute = atoi(time.substr(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>).c_str());<br>    second = atoi(time.substr(<span class="hljs-number">6</span>, <span class="hljs-number">2</span>).c_str());<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> time1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//cout &lt;&lt; hour &lt;&lt; " " &lt;&lt; minute &lt;&lt; " " &lt;&lt; second;</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; year &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; month &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; day &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-comment">//cout &lt;&lt; second &lt;&lt; to_string(minute * 60) &lt;&lt; to_string(hour * 3600) &lt;&lt; second + minute * 60 + hour * 3600;</span><br>    <span class="hljs-comment">//给出的一天内的时间计算</span><br>    time1 = second + minute * <span class="hljs-number">60</span> + hour * <span class="hljs-number">3600</span>;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> time2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> run = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1970</span>; i &lt; year; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> ((i % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; i % <span class="hljs-number">100</span> != <span class="hljs-number">0</span>) || i % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>)<br>            run++;<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; run &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-comment">//给出的年月日的时间计算</span><br>    time2 += run * <span class="hljs-number">366</span> * <span class="hljs-number">3600</span> * <span class="hljs-number">24</span> + (year - <span class="hljs-number">1970</span> - run) * <span class="hljs-number">365</span> * <span class="hljs-number">3600</span> * <span class="hljs-number">24</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; time2 &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//最后一年单独计算，因为最后一年未满整一年</span><br>    <span class="hljs-comment">//最后一年是闰年还是平年</span><br>    <span class="hljs-keyword">if</span> ((year % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; year % <span class="hljs-number">100</span> != <span class="hljs-number">0</span>) || year % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>)<br>        temp = <span class="hljs-number">29</span>;<br>    <span class="hljs-keyword">else</span><br>        temp = <span class="hljs-number">28</span>;<br>    <span class="hljs-comment">//最后一年除掉最后一个月的时间，因为最后一个月未满整一个月</span><br>    <span class="hljs-keyword">switch</span> (month)<br>    &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">01</span>:<br>        time2 += <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">02</span>:<br>        time2 += <span class="hljs-number">31</span> * <span class="hljs-number">3600</span> * <span class="hljs-number">24</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">03</span>:<br>        time2 += (<span class="hljs-number">31</span> + temp) * <span class="hljs-number">3600</span> * <span class="hljs-number">24</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">04</span>:<br>        time2 += (<span class="hljs-number">62</span> + temp) * <span class="hljs-number">3600</span> * <span class="hljs-number">24</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">05</span>:<br>        time2 += (<span class="hljs-number">92</span> + temp) * <span class="hljs-number">3600</span> * <span class="hljs-number">24</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">06</span>:<br>        time2 += (<span class="hljs-number">123</span> + temp) * <span class="hljs-number">3600</span> * <span class="hljs-number">24</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">07</span>:<br>        time2 += (<span class="hljs-number">153</span> + temp) * <span class="hljs-number">3600</span> * <span class="hljs-number">24</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-comment">//8和9特殊，编译器在识别08和09时不会自动转换成8和9，而是提示错误的八进制数</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br>        time2 += (<span class="hljs-number">184</span> + temp) * <span class="hljs-number">3600</span> * <span class="hljs-number">24</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:<br>        time2 += (<span class="hljs-number">215</span> + temp) * <span class="hljs-number">3600</span> * <span class="hljs-number">24</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:<br>        time2 += (<span class="hljs-number">245</span> + temp) * <span class="hljs-number">3600</span> * <span class="hljs-number">24</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">11</span>:<br>        time2 += (<span class="hljs-number">276</span> + temp) * <span class="hljs-number">3600</span> * <span class="hljs-number">24</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">12</span>:<br>        time2 += (<span class="hljs-number">306</span> + temp) * <span class="hljs-number">3600</span> * <span class="hljs-number">24</span>;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">//cout &lt;&lt; time2 &lt;&lt; endl;</span><br>    time2 += (day - <span class="hljs-number">1</span>) * <span class="hljs-number">24</span> * <span class="hljs-number">3600</span>;<br>    <span class="hljs-comment">//整的年月日的时间计算加上最后一日内的时分秒时间计算</span><br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> res = time1 + time2;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//1970/02/01 00:00:00</span><br>    <span class="hljs-comment">//2716/02/02 00:00:00</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给素材分类，若作品1中有素材1和素材2，则认为素材1和素材2为一类，若作品2中有素材2和素材3，那么此后认为素材1、2、3为一类&lt;/p&gt;
&lt;p&gt;输入：第一行为作品数n，此后n行中每行第一位为该作品中的素材总数m，此后m个数字为素材名（int型）&lt;/p&gt;
&lt;p&gt;输出：素材的分
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/Algorithm/"/>
    
      <category term="C++" scheme="https://chasencenge.github.io/categories/Algorithm/C/"/>
    
    
      <category term="C++" scheme="https://chasencenge.github.io/tags/C/"/>
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>网易20秋招Unity工程师笔试编程题</title>
    <link href="https://chasencenge.github.io/2020/07/31/%E7%BD%91%E6%98%9320%E7%A7%8B%E6%8B%9BUnity%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    <id>https://chasencenge.github.io/2020/07/31/网易20秋招Unity工程师笔试编程题/</id>
    <published>2020-07-31T14:25:33.000Z</published>
    <updated>2020-07-31T16:12:44.900Z</updated>
    
    <content type="html"><![CDATA[<p>定义S(n)，表示n在十进制下的各位数字和。</p><p>现在给定一个x,请你求出最小正整数n，满足x&lt;=S(n)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-keyword">int</span> num;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; num;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; resV;<br>    <span class="hljs-built_in">string</span> a = <span class="hljs-string">"9"</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>; n &lt; num; n++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> x;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; x;<br>        <span class="hljs-comment">//long long int multi = 1;</span><br>        <span class="hljs-built_in">string</span> res;<br>        <span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">9</span>)<br>        &#123;<br>            x -= <span class="hljs-number">9</span>;<br>            res = a + res;<br>            <span class="hljs-comment">//multi *= 10;</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (x != <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">//res += multi * x;</span><br>            res = to_string(x) + res;<br>        &#125;<br>        resV.push_back(res);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>; n &lt; num; n++)<br>    &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; resV[n] &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>小易给定你数字A, B (A &lt; B)和系数p, q。每次操作你可以将A变成A + p或者将p变成p * q。问至少几次操作使得B &lt;= A。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-keyword">int</span> num;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; num;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span>&gt; resV;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>; n &lt; num; n++)<br>    &#123;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> a;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> b;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> p;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> q;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; p &gt;&gt; q;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (b - a &gt; p)<br>        &#123;<br>            <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> temp = b - a;<br>            <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> multiNum = p;<br><br>            <span class="hljs-keyword">while</span> (temp &gt; multiNum)<br>            &#123;<br>                multiNum *= q;<br>                res++;<br>            &#125;<br>            res++;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            res++;<br>        &#125;<br>        resV.push_back(res);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>; n &lt; num; n++)<br>    &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; resV[n] &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>小易定义一个数字序列是完美的，当且仅当对于任意2 &lt;= i &lt;= n，都满足<img src="https://www.nowcoder.com/equation?tex=%5Csum_%7B1%20%5Cleq%20j%20%3C%20i%7D%7BA_%7Bj%7D%7D%20%5Cleq%20A_%7Bi%7D" alt="img">，即每个数字都要大于等于前面所有数字的和。<br>现在给定数字序列A<del>i</del>，小易想请你从中找出最长的一段连续子序列，满足它是完美的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; resV;<br>    <span class="hljs-keyword">int</span> num;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; num;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> tempLength = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> maxLength = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; n;<br>        <span class="hljs-keyword">int</span> serialNum;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; serialNum;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; serialNum; j++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> data;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; data;<br>            n.push_back(data);<br>        &#125;<br>        <span class="hljs-keyword">int</span> compute = n[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt; serialNum; k++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (n[k] &gt;= compute)<br>            &#123;<br>                compute += n[k];<br>                tempLength++;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                maxLength = max(maxLength, tempLength);<br>                tempLength = <span class="hljs-number">1</span>;<br>                compute = n[k];<br>            &#125;<br>        &#125;<br>        resV.push_back(maxLength);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++)<br>    &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; resV[i] &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>小易的公司一共有n名员工, 第i个人每个月的薪酬是x<del>i</del>万元。<br>现在小易的老板向小易提了m次询问, 每次询问老板都会给出一个整数k, 小易要快速回答老板工资等于k的员工的数量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br><br>    <span class="hljs-keyword">int</span> people, question;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; people &gt;&gt; question;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">resV</span><span class="hljs-params">(question, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; salaryV;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; questionV;<br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">size_t</span>&gt; questionMap;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; people; i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> salary;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; salary;<br>        salaryV.push_back(salary);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; question; i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> data;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; data;<br>        questionV.push_back(data);<br>        questionMap[to_string(data)];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; people; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (questionMap.find(to_string(salaryV[i])) != questionMap.end())<br>        &#123;<br>            ++questionMap[to_string(salaryV[i])];<br>        &#125;<br>    &#125;<br><br>   <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; question; i++)<br>    &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; questionMap.find(to_string(questionV[i]))-&gt;second &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;定义S(n)，表示n在十进制下的各位数字和。&lt;/p&gt;
&lt;p&gt;现在给定一个x,请你求出最小正整数n，满足x&amp;lt;=S(n)。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/Algorithm/"/>
    
      <category term="C++" scheme="https://chasencenge.github.io/categories/Algorithm/C/"/>
    
    
      <category term="C++" scheme="https://chasencenge.github.io/tags/C/"/>
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Pyplot绘图</title>
    <link href="https://chasencenge.github.io/2020/07/27/Pyplot%E7%BB%98%E5%9B%BE/"/>
    <id>https://chasencenge.github.io/2020/07/27/Pyplot绘图/</id>
    <published>2020-07-27T12:56:31.000Z</published>
    <updated>2020-07-27T13:20:21.018Z</updated>
    
    <content type="html"><![CDATA[<h4 id="标识散点：plt-scatter-x-y"><a href="#标识散点：plt-scatter-x-y" class="headerlink" title="标识散点：plt.scatter(x, y)"></a>标识散点：plt.scatter(x, y)</h4><p>可选项s修改散点大小，color修改颜色</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.scatter(thisNodeLoc[<span class="hljs-number">0</span>], thisNodeLoc[<span class="hljs-number">1</span>], s=<span class="hljs-number">10</span>, color=<span class="hljs-string">'b'</span>)<br></code></pre></td></tr></table></figure><h4 id="连线：plt-plot-x1-y1-x2-y2"><a href="#连线：plt-plot-x1-y1-x2-y2" class="headerlink" title="连线：plt.plot([x1, y1], [x2, y2])"></a>连线：plt.plot([x1, y1], [x2, y2])</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.plot([thisNodeLoc[<span class="hljs-number">0</span>], sendToNodeLoc[<span class="hljs-number">0</span>]], [thisNodeLoc[<span class="hljs-number">1</span>], sendToNodeLoc[<span class="hljs-number">1</span>]])<br></code></pre></td></tr></table></figure><h4 id="注释文字：plt-annotate-txt-xy-xytext"><a href="#注释文字：plt-annotate-txt-xy-xytext" class="headerlink" title="注释文字：plt.annotate(txt, xy=(), xytext=())"></a>注释文字：plt.annotate(txt, xy=(), xytext=())</h4><p>xy处填注释点坐标，xytext处填文本位置，可加偏移offset</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.annotate(thisNodeLoc, xy=(thisNodeLoc[<span class="hljs-number">0</span>], thisNodeLoc[<span class="hljs-number">1</span>]), xytext=(thisNodeLoc[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>, thisNodeLoc[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><h4 id="限制坐标区间："><a href="#限制坐标区间：" class="headerlink" title="限制坐标区间："></a>限制坐标区间：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.xlim(<span class="hljs-number">-2200</span>,<span class="hljs-number">2200</span>)<br>plt.ylim(<span class="hljs-number">-2200</span>,<span class="hljs-number">2200</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, nodeNum):<br>    thisNodeLoc = [nodes[n].locX, nodes[n].locY]<br>    sendToNodeLoc = [nodes[n].sendTo.locX, nodes[n].sendTo.locY]<br>    plt.scatter(thisNodeLoc[<span class="hljs-number">0</span>], thisNodeLoc[<span class="hljs-number">1</span>], s=<span class="hljs-number">10</span>, color=<span class="hljs-string">'b'</span>)<br>    plt.plot([thisNodeLoc[<span class="hljs-number">0</span>], sendToNodeLoc[<span class="hljs-number">0</span>]], [thisNodeLoc[<span class="hljs-number">1</span>], sendToNodeLoc[<span class="hljs-number">1</span>]])<br>    plt.annotate(thisNodeLoc, xy=(thisNodeLoc[<span class="hljs-number">0</span>], thisNodeLoc[<span class="hljs-number">1</span>]), xytext=(thisNodeLoc[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>, thisNodeLoc[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>))<br><br>plt.xlim(<span class="hljs-number">-2200</span>,<span class="hljs-number">2200</span>)<br>plt.ylim(<span class="hljs-number">-2200</span>,<span class="hljs-number">2200</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p>最后记得用<code>plt.show()</code>将其显示出来</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;标识散点：plt-scatter-x-y&quot;&gt;&lt;a href=&quot;#标识散点：plt-scatter-x-y&quot; class=&quot;headerlink&quot; title=&quot;标识散点：plt.scatter(x, y)&quot;&gt;&lt;/a&gt;标识散点：plt.scatter(x, y)&lt;/
      
    
    </summary>
    
    
      <category term="Python" scheme="https://chasencenge.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://chasencenge.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>百度之星2020---1003.Permutation</title>
    <link href="https://chasencenge.github.io/2020/07/26/%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F2020-1003-Permutation/"/>
    <id>https://chasencenge.github.io/2020/07/26/百度之星2020-1003-Permutation/</id>
    <published>2020-07-26T10:04:53.000Z</published>
    <updated>2020-07-26T10:28:00.105Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Problem Description</strong></p><p>一开始有 n个数，他们按 1…n的顺序排列，要求交换最多 m对数字（同一个数字可以参与多次交换），使得逆序对数目最大。</p><p>对于一个序列 A，如果存在正整数 i, j使得1≤<em>i</em>&lt;<em>j</em>≤<em>n</em> 而且 A[i] &gt; A[j]，则 &lt;<em>A</em>[<em>i</em>],<em>A</em>[<em>j</em>]&gt; 这个有序对称为 A的一个逆序对。</p><p><strong>Input</strong></p><p>第一行一个正整数test (1≤test≤100000) 表示数据组数。</p><p>对于每组数据，一行两个整数 n，m (1≤<em>n</em>≤1000000,0≤<em>m</em>≤1000000) 表示数字个数和最多可以交换的数字对数。</p><p><strong>Output</strong></p><p>对于每组数据，一行一个整数表示答案。</p><p><strong>Sample Input</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">6<br>1 1<br>2 0<br>2 1<br>3 1<br>4 1<br>4 2<br></code></pre></td></tr></table></figure><p><strong>Sample Output</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">0<br>0<br>1<br>3<br>5<br>6<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 对每个（n, 1）结果都为：2 * n - 3</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">com</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span><br></span>&#123;<br>    <span class="hljs-keyword">int</span> com = <span class="hljs-number">2</span> * n - <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">return</span> com;<br>&#125;<br><br><span class="hljs-comment">// 把（n, m）转换为（n, 1）, (n -2, 1)...(n - 2m + 2, 1)之和的形式并利用com()计算结果</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">arr</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span><br></span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        res += com(n - <span class="hljs-number">2</span> * i);<br>        <span class="hljs-comment">//cout &lt;&lt; i &lt;&lt;" "&lt;&lt; res&lt;&lt;endl;</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">compute</span><span class="hljs-params">()</span> <br></span>&#123;<br>    <br>    <span class="hljs-keyword">int</span> groupNum;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; groupNum;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; output;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; groupNum; i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> n;<br>        <span class="hljs-keyword">int</span> m;<br>        <span class="hljs-comment">//cout &lt;&lt; "choiseNum:" &lt;&lt; choiseNum &lt;&lt; endl;</span><br>        <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>            <span class="hljs-comment">//cout &lt;&lt; "b:" &lt;&lt; b &lt;&lt; endl;</span><br>        <span class="hljs-built_in">cin</span> &gt;&gt; m;<br>            <span class="hljs-comment">//cout &lt;&lt; "c:" &lt;&lt; c &lt;&lt; endl;</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || m == <span class="hljs-number">0</span>)<br>        &#123;<br>            output.push_back(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * m &lt; n)<br>            &#123;<br>                <span class="hljs-keyword">int</span> res = arr(n, m);<br>                output.push_back(res);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <br>            &#123;<br>                m = n / <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">int</span> res = arr(n, m);<br>                output.push_back(res);<br>            &#125;<br>        &#125;<br>        &#125;<br>    <span class="hljs-keyword">return</span> output;<br>    &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res = compute();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; res.size(); i++)<br>    &#123;<br>        <span class="hljs-comment">//cout &lt;&lt; res[i];</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, res[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Problem Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一开始有 n个数，他们按 1…n的顺序排列，要求交换最多 m对数字（同一个数字可以参与多次交换），使得逆序对数目最大。&lt;/p&gt;
&lt;p&gt;对于一个序列 A，如果存在正整数 i, j使得1≤&lt;
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/Algorithm/"/>
    
      <category term="C++" scheme="https://chasencenge.github.io/categories/Algorithm/C/"/>
    
    
      <category term="C++" scheme="https://chasencenge.github.io/tags/C/"/>
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>百度之星2020---1002.Game</title>
    <link href="https://chasencenge.github.io/2020/07/26/%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F2020-1002-Game/"/>
    <id>https://chasencenge.github.io/2020/07/26/百度之星2020-1002-Game/</id>
    <published>2020-07-26T10:04:18.000Z</published>
    <updated>2020-07-26T10:27:47.180Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Problem Description</strong></p><p><em>Alice</em> 和 <em>Bob</em> 在玩游戏。</p><p>桌面上有两堆金币，少的那堆有 x 个金币，多的那堆有 2x 个金币。</p><p>假设金币可以被无限细分。<em>Alice</em> 和 <em>Bob</em> 事先都不知道 x是几，但是他们都知道 x是一个 (0, 1]之间均匀分布的随机实数。</p><p><em>Alice</em> 会等概率的被分配到其中的一堆金币，<em>Bob</em> 会得到另一堆。x的值和两堆金币的分配是相互独立的。</p><p>拿到金币以后，<em>Alice</em> 会马上数清自己拿到多少金币。然后 <em>Alice</em> 可以选择是否和 <em>Bob</em> 那堆换。</p><p>给定 <em>Alice</em> 拿到的金币数目，请问 <em>Alice</em> 要不要交换，使得她期望能得到的金币数目更多？</p><p>如果交换期望得到的金币数目多于不交换期望得到的金币数目，输出交换，否则不交换。</p><p><strong>Input</strong></p><p>第一行一个正整数test (1≤test≤200000) 表示数据组数。</p><p>接下来每行一个小数p(0&lt;p≤2)，p最多保留五位小数，表示 <em>Alice</em> 拿到的金币数目。</p><p><strong>Output</strong></p><p>对于每组数据，输出 <em>Yes</em> 表示需要交换，输出 <em>No</em> 表示不要交换。</p><p><strong>Sample Input</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">1<br>1.00000<br></code></pre></td></tr></table></figure><p><strong>Sample Output</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Yes<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">compute</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-keyword">int</span> groupNum;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; groupNum;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; output;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; groupNum; i++)<br>    &#123;<br>        <span class="hljs-keyword">float</span> num;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; num;<br>        <span class="hljs-comment">//float exception;</span><br>        <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">1</span>)<br>        &#123;<br>            output.push_back(<span class="hljs-string">"No"</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * num * <span class="hljs-number">0.5</span> + num / <span class="hljs-number">2</span> * <span class="hljs-number">0.5</span> &gt; num)<br>            &#123;<br>                output.push_back(<span class="hljs-string">"Yes"</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                output.push_back(<span class="hljs-string">"No"</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; res = compute();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; res.size(); i++)<br>    &#123;<br>        <span class="hljs-comment">//cout &lt;&lt; res[i];</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>, res[i].c_str());<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Problem Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alice&lt;/em&gt; 和 &lt;em&gt;Bob&lt;/em&gt; 在玩游戏。&lt;/p&gt;
&lt;p&gt;桌面上有两堆金币，少的那堆有 x 个金币，多的那堆有 2x 个金币。&lt;/p&gt;
&lt;p&gt;假设金币可以被无
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/Algorithm/"/>
    
      <category term="C++" scheme="https://chasencenge.github.io/categories/Algorithm/C/"/>
    
    
      <category term="C++" scheme="https://chasencenge.github.io/tags/C/"/>
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>百度之星2020---1001.Discount</title>
    <link href="https://chasencenge.github.io/2020/07/26/%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F2020-1001-Discount/"/>
    <id>https://chasencenge.github.io/2020/07/26/百度之星2020-1001-Discount/</id>
    <published>2020-07-26T10:03:53.000Z</published>
    <updated>2020-07-26T10:21:02.628Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Problem Description</strong></p><p>学皇来到了一个餐馆吃饭。他觉得这家餐馆很好吃，于是就想办个会员。</p><p>一共有 n种会员充值卡套餐，假设学皇这餐饭的消费为 a元，选择第 i种套餐，需要充值 b[i] * a 的钱，这次吃饭可以打 c[i]×10 折，由充值的钱支付（即这次吃饭只需要从充值金额中扣除 a×<em>c</em>[i] 元）。以后用剩余的充值的钱吃饭不再打折。</p><p>请问学皇应该选择哪个套餐（必须选择恰好一个套餐），使得优惠的比例最大？</p><p>优惠比例的定义是把充的钱用完以后，(本来应该付的钱 - 实际付的钱) / 本来应该付的钱。在这个题目里，实际付的钱就是这次充值的花费。</p><p><strong>Input</strong></p><p>第一行一个整数 test(1≤test≤100) 表示数据组数。</p><p>对于每组数据，第一行一个正整数 n(1≤n≤100) 表示套餐的数目。</p><p>接下来 n行，每行一个正整数 b[i]和一个小数 c[i]。</p><p><strong>Output</strong></p><p>对于每组数据，输出一个五位小数表示最大的优惠比例。如果小数点后超过五位，四舍五入到五位。</p><p><strong>Sample Input</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">1<br>2<br>2 0.5<br>3 0.1<br></code></pre></td></tr></table></figure><p><strong>Sample Output</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">0.23077<br><br>样例解释<br>对于第一种套餐，优惠比例为 0.5a / (2a + 0.5a） = 0.2；<br>对于第二种套餐，优惠比例为 0.9a / (3a + 0.9a） = 9 / 39；<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">float</span>&gt; <span class="hljs-title">compute</span><span class="hljs-params">()</span> <br></span>&#123;<br>    <span class="hljs-keyword">int</span> groupNum;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; groupNum;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">float</span>&gt; output;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; groupNum; i++)<br>    &#123;<br>        <span class="hljs-keyword">float</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> choiseNum;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; choiseNum;<br>        <span class="hljs-comment">//cout &lt;&lt; "choiseNum:" &lt;&lt; choiseNum &lt;&lt; endl;</span><br>        <span class="hljs-keyword">int</span> b;<br>        <span class="hljs-keyword">float</span> c;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; choiseNum; j++)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; b;<br>            <span class="hljs-comment">//cout &lt;&lt; "b:" &lt;&lt; b &lt;&lt; endl;</span><br>            <span class="hljs-built_in">cin</span> &gt;&gt; c;<br>            <span class="hljs-comment">//cout &lt;&lt; "c:" &lt;&lt; c &lt;&lt; endl;</span><br>            <span class="hljs-keyword">float</span> temp = (<span class="hljs-number">1</span> - c) / (b + <span class="hljs-number">1</span> - c);<br>            res = max(res, temp);<br>        &#125;<br>        output.push_back(res);<br>    &#125;<br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">float</span>&gt; res = compute();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; res.size(); i++)<br>    &#123;<br>        <span class="hljs-comment">//cout &lt;&lt; res[i];</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.5f\n"</span>, res[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Problem Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;学皇来到了一个餐馆吃饭。他觉得这家餐馆很好吃，于是就想办个会员。&lt;/p&gt;
&lt;p&gt;一共有 n种会员充值卡套餐，假设学皇这餐饭的消费为 a元，选择第 i种套餐，需要充值 b[i] * a 的
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/Algorithm/"/>
    
      <category term="C++" scheme="https://chasencenge.github.io/categories/Algorithm/C/"/>
    
    
      <category term="C++" scheme="https://chasencenge.github.io/tags/C/"/>
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
</feed>
