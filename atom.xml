<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>解字</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chasencenge.github.io/"/>
  <updated>2020-12-28T08:55:21.493Z</updated>
  <id>https://chasencenge.github.io/</id>
  
  <author>
    <name>CHAsencenge</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>手撸算法终版</title>
    <link href="https://chasencenge.github.io/2020/11/30/%E6%89%8B%E6%92%B8%E7%AE%97%E6%B3%95%E7%BB%88%E7%89%88/"/>
    <id>https://chasencenge.github.io/2020/11/30/手撸算法终版/</id>
    <published>2020-11-30T12:43:44.000Z</published>
    <updated>2020-12-28T08:55:21.493Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-两数之和（为目标值）-3min"><a href="#1-两数之和（为目标值）-3min" class="headerlink" title="1. 两数之和（为目标值）   3min"></a>1. 两数之和（为目标值）   3min</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span><br></span>&#123;<br>    umordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; hashtable;<br>    <span class="hljs-comment">/* xiaoguo */</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++)<br>    &#123;<br>        <span class="hljs-keyword">auto</span> it = hashtable.find(target - nums[i]);<br>        <span class="hljs-keyword">if</span>(it != hashtable.end())<br>            <span class="hljs-keyword">return</span> &#123;it-&gt;second, i&#125;;<br>        hashtable[nums[i]] = i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><a id="more"></a><h3 id="2-两数相加（链表形式给出，返回同样格式的链表）-4min"><a href="#2-两数相加（链表形式给出，返回同样格式的链表）-4min" class="headerlink" title="2. 两数相加（链表形式给出，返回同样格式的链表）  4min"></a>2. 两数相加（链表形式给出，返回同样格式的链表）  4min</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span><br></span>&#123;<br>ListNode* head = <span class="hljs-literal">nullptr</span>;<br>    ListNode* tail = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(l1 || l2)<br>    &#123;<br>        <span class="hljs-keyword">int</span> n1 = l1 ? l1-&gt;val : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> n2 = l2 ? l2-&gt;val : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> sum = n1 + n2 + carry;<br>        <span class="hljs-keyword">if</span>(!head)<br>        &#123;<br>            head = tail = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            tail-&gt;next = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>);<br>            tail = tail-&gt;next;<br>        &#125;<br>        carry = sum / <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">if</span>(l1)<br>            l1 = l1-&gt;next;<br>        <span class="hljs-keyword">if</span>(l2)<br>            l2 = l2-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(carry)<br>    &#123;<br>        tail-&gt;next = <span class="hljs-keyword">new</span> ListNode(carry);<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-无重复字符的最长字串-2min"><a href="#3-无重复字符的最长字串-2min" class="headerlink" title="3. 无重复字符的最长字串     2min"></a>3. 无重复字符的最长字串     2min</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span><br></span>&#123;<br><span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt; st;<br>    <span class="hljs-keyword">int</span> n = s.size();<br>    <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>, ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>; left &lt; n; left++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(left != <span class="hljs-number">0</span>)<br>        &#123;<br>            st.erase(s[left - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(right &lt; n &amp;&amp; !st.count(s[right]))<br>        &#123;<br>            st.insert(s[right]);<br>            right++;<br>        &#125;<br>        ret = max(ret, right - left);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="15-三数之和（等于0）-9min"><a href="#15-三数之和（等于0）-9min" class="headerlink" title="15. 三数之和（等于0）  9min"></a>15. 三数之和（等于0）  9min</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">threeSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span><br></span>&#123;<br>    sort(nums.begin(), nums.end());<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; ret;<br>    <span class="hljs-keyword">int</span> n = nums.size();<br>    <span class="hljs-keyword">if</span>(n &gt;= <span class="hljs-number">3</span> &amp;&amp; nums[n - <span class="hljs-number">1</span>] + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">3</span>] &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> ret;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> first = <span class="hljs-number">0</span>; first &lt; n - <span class="hljs-number">2</span>; first++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(nums[first] + nums[first + <span class="hljs-number">1</span>] + nums[first + <span class="hljs-number">2</span>] &gt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span>(first &gt; <span class="hljs-number">0</span> &amp;&amp; nums[first] == nums[first - <span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">int</span> target = -nums[first];<br>        <span class="hljs-keyword">int</span> third = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> second = first + <span class="hljs-number">1</span>; second &lt; n - <span class="hljs-number">1</span>; second++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(second &gt; first + <span class="hljs-number">1</span> &amp;&amp; nums[second] == nums[second - <span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">while</span>(second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target)<br>                --third;<br>            <span class="hljs-keyword">if</span>(second == third)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span>(nums[second] + nums[third] == target)<br>                ret.push_back(&#123;nums[first], nums[second], nums[third]&#125;);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="84-柱状图中的最大矩形-8min"><a href="#84-柱状图中的最大矩形-8min" class="headerlink" title="84. 柱状图中的最大矩形    8min"></a>84. 柱状图中的最大矩形    8min</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++">int largestRectangleArea(vector&lt;int&gt;&amp; heights)<br>&#123;<br>    int ret = 0;<br>    int n = heights.size();<br>    vector&lt;int&gt; left(n), right(n, n);<br>    stack&lt;int&gt; monoStack;<br>    for(int i = 0; i &lt; n; i++)<br>    &#123;<br>        while(!monoStack.empty() &amp;&amp; heights[monoStack.top()] &gt;= heights[i])<br>        &#123;<br>            right[monoStack.top()] = i;<br>            monoStack.pop();<br>        &#125;<br>        left[i] = monoStack.empty() ? -1 : monoStack.top();<br>        monoStack.push(i);<br>    &#125;<br>    for(int i = 0; i &lt; n; i++)<br>    &#123;<br>        ret = max(ret, (right[i] - left[i] - 1) * heights[i]);<br>    &#125;<br>    return ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="85-最大矩形-15min"><a href="#85-最大矩形-15min" class="headerlink" title="85. 最大矩形     15min"></a>85. 最大矩形     15min</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++">int lagestRectangleArea(vector&lt;int&gt;&amp; heights)<br>&#123;<br>    int ret = 0;<br>    int n = heights.size();<br>    vector&lt;int&gt; left(n), right(n, n);<br>    stack&lt;int&gt; monoStack;<br>    for(int i = 0; i &lt; n; i++)<br>    &#123;<br>        while(!monoStack.empty() &amp;&amp; heights[monoStack.top()] &gt;= heights[i])<br>        &#123;<br>            right[monoStack.top()] = i;<br>            monoStack.pop();<br>        &#125;<br>        left[i] = monoStack.empty() ? -1 : monoStack.top();<br>        monoStack.push(i);<br>    &#125;<br>    for(int i = 0; i &lt; n; i++)<br>    &#123;<br>        ret = max(ret, (right[i] - left[i] - ) * heights[i]);<br>    &#125;<br>    return ret;<br>&#125;<br>int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix)<br>&#123;<br> int ret = 0;<br>    int m = matrix.size();<br>    if(m == 0)<br>        return 0;<br>    int n = matrix[0].size();<br>    vector&lt;int&gt; dp (n, 0);<br>    for(int i = 0; i &lt; m; i++)<br>    &#123;<br>        for(int j = 0; j &lt; n; j++)<br>        &#123;<br>            dp[j] = matrix[i][j] == '0' ? 0 : dp[j] + 1;<br>        &#125;<br>        ret = max(ret, largestRectangleArea(dp));<br>    &#125;<br>    return ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a>94. 二叉树的中序遍历</h3><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; ret)</span><br></span>&#123;<br>    <span class="hljs-keyword">if</span>(!root)<br>        <span class="hljs-keyword">return</span>;<br>    inorder(root-&gt;left, ret);<br>    ret.push_back(root-&gt;val);<br>    inorder(root-&gt;right, ret);<br>&#125;<br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span><br></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ret;<br>    inorder(root, ret);<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="非递归-栈"><a href="#非递归-栈" class="headerlink" title="非递归(栈)"></a>非递归(栈)</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span><br></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ret;<br>    <span class="hljs-built_in">stack</span>&lt;TreeNode*&gt; stk;<br>    <span class="hljs-keyword">while</span>(root || !stk.empty())<br>    &#123;<br>        <span class="hljs-keyword">while</span>(root)<br>        &#123;<br>            stk.push(root);<br>            root = root-&gt;left;<br>        &#125;<br>        root = stk.top();<br>        stk.pop();<br>        ret.push_back(root-&gt;val);<br>        root = root-&gt;right;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Morris"><a href="#Morris" class="headerlink" title="Morris"></a>Morris</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span><br></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ret;<br>    TreeNode* predecessor = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span>(root)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(root-&gt;left != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            predecessor = root-&gt;left;<br>            <span class="hljs-keyword">while</span>(predecessor-&gt;right != <span class="hljs-literal">nullptr</span> &amp;&amp; predecessor-&gt;right != root)<br>            &#123;<br>                predecessor = predecessor-&gt;right;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(predecessor-&gt;right == <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                predecessor-&gt;right = root;<br>                root = root-&gt;left;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                ret.push_back(root-&gt;val);<br>                predecessor-&gt;right = <span class="hljs-literal">nullptr</span>;<br>                root = root-&gt;right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            ret.push_back(root-&gt;val);<br>            root = root-&gt;right;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="96-（n个点能组成的）不同的二叉搜索树-1min"><a href="#96-（n个点能组成的）不同的二叉搜索树-1min" class="headerlink" title="96. （n个点能组成的）不同的二叉搜索树     1min"></a>96. （n个点能组成的）不同的二叉搜索树     1min</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span><br></span>&#123;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> m = <span class="hljs-number">2</span>; m &lt;= n; m++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>        &#123;<br>            dp[m] += dp[i - <span class="hljs-number">1</span>] * dp[m - i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="98-验证（一棵树是否为）二叉搜索树-3min"><a href="#98-验证（一棵树是否为）二叉搜索树-3min" class="headerlink" title="98. 验证（一棵树是否为）二叉搜索树     3min"></a>98. 验证（一棵树是否为）二叉搜索树     3min</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span><br></span>&#123;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> inorder = (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)INT_MIN - <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">stack</span>&lt;TreeNode*&gt; stk;<br>    <span class="hljs-keyword">while</span>(root || !stk.empty())<br>    &#123;<br>        <span class="hljs-keyword">while</span>(root)<br>        &#123;<br>            stk.push(root);<br>            root = root-&gt;left;<br>        &#125;<br>        root = stk.top();<br>        stk.pop();<br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt;= inorder)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        inorder = root-&gt;val;<br>        root = root-&gt;right;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="102-二叉树的层序遍历-按层次打印到二维数组中）-6min"><a href="#102-二叉树的层序遍历-按层次打印到二维数组中）-6min" class="headerlink" title="102. 二叉树的层序遍历(按层次打印到二维数组中） 6min"></a>102. 二叉树的层序遍历(按层次打印到二维数组中） 6min</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode* root)</span><br></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; ret;<br>    <span class="hljs-keyword">if</span>(!root)<br>    &#123;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; que;<br>    que.push(root);<br>    <span class="hljs-keyword">while</span>(!que.empty())<br>    &#123;<br>        <span class="hljs-keyword">int</span> n = que.size();<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; temp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> node = que.front();<br>            que.pop();<br>            temp.push_back(node-&gt;val);<br>            <span class="hljs-keyword">if</span>(node-&gt;left)<br>                que.push(node-&gt;left);<br>            <span class="hljs-keyword">if</span>(node-&gt;right)<br>                que.push(node-&gt;right);<br>        &#125;<br>        ret.push_back(temp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="114-二叉树（原地）展开为链表（顺着右子节点连）-3min"><a href="#114-二叉树（原地）展开为链表（顺着右子节点连）-3min" class="headerlink" title="114. 二叉树（原地）展开为链表（顺着右子节点连）  3min"></a>114. 二叉树（原地）展开为链表（顺着右子节点连）  3min</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode* root)</span><br></span>&#123;<br>    TreeNode* cur = root;<br>    <span class="hljs-keyword">while</span>(cur)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(cur-&gt;left)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> next = cur-&gt;left;<br>            <span class="hljs-keyword">auto</span> predecessor = next;<br>            <span class="hljs-keyword">while</span>(predecessor-&gt;right)<br>                predecessor = predecessor-&gt;right;<br>            predecessor-&gt;right = cur-&gt;right;<br>            cur-&gt;left = <span class="hljs-literal">nullptr</span>;<br>            cur-&gt;right = next;<br>&#125;<br>        cur = cur-&gt;right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="121-买卖股票的最佳时机-1min"><a href="#121-买卖股票的最佳时机-1min" class="headerlink" title="121. 买卖股票的最佳时机     1min"></a>121. 买卖股票的最佳时机     1min</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span><br></span>&#123;<br>    <span class="hljs-keyword">int</span> minprice = <span class="hljs-number">1e9</span>, maxprofit = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> price : prices)<br>    &#123;<br>        minprice = min(price, minprice);<br>        maxprofit = max(maxprofit, price - minprice);<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxprofit;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="124-（从任意点起的）二叉树中的最大路径和"><a href="#124-（从任意点起的）二叉树中的最大路径和" class="headerlink" title="124. （从任意点起的）二叉树中的最大路径和"></a>124. （从任意点起的）二叉树中的最大路径和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxGain</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span>&amp; maxSum)</span><br></span>&#123;<br>    <span class="hljs-keyword">if</span>(root)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> left = max(maxGain(root-&gt;left), <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">int</span> right = max(maxGain(root-&gt;right), <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">int</span> curMaxSum = root-&gt;val + left + right;<br>    maxSum = max(maxSum, curMaxSum);<br>    <span class="hljs-keyword">return</span> root-&gt;val + max(left, right);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span><br></span>&#123;<br>    <span class="hljs-keyword">int</span> maxSum = INT_MIN;<br>    maxGain(root, maxSum);<br>    <span class="hljs-keyword">return</span> maxSum;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="128-（无序数组中能找出的）最长连续序列（需要O-n-时间复杂度）"><a href="#128-（无序数组中能找出的）最长连续序列（需要O-n-时间复杂度）" class="headerlink" title="128. （无序数组中能找出的）最长连续序列（需要O(n)时间复杂度）"></a>128. （无序数组中能找出的）最长连续序列（需要O(n)时间复杂度）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span><br></span>&#123;<br>    <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">int</span>&gt; st;<br>    <span class="hljs-keyword">int</span> longestSeq = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)<br>        st.insert(num);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> s : st)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!st.count(s - <span class="hljs-number">1</span>))<br>        &#123;<br>            <span class="hljs-keyword">int</span> curSeq = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">int</span> curNum = s;<br>            <span class="hljs-keyword">while</span>(st.count(curNum + <span class="hljs-number">1</span>))<br>            &#123;<br>                curSeq++;<br>                curNum++;<br>            &#125;<br>            longestSeq = max(longestSeq, curSeq);<br>        &#125;<br>&#125;<br>    <span class="hljs-keyword">return</span> longestSeq;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="136-（在其余数字都出现两次的数组中找）只出现一次的数字（要求线性时间，不使用额外空间）"><a href="#136-（在其余数字都出现两次的数组中找）只出现一次的数字（要求线性时间，不使用额外空间）" class="headerlink" title="136. （在其余数字都出现两次的数组中找）只出现一次的数字（要求线性时间，不使用额外空间）"></a>136. （在其余数字都出现两次的数组中找）只出现一次的数字（要求线性时间，不使用额外空间）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span><br></span>&#123;<br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)<br>        ret ^= num;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="139-单词（是否可以）拆分（成字符串数组中的元素）-4min"><a href="#139-单词（是否可以）拆分（成字符串数组中的元素）-4min" class="headerlink" title="139. 单词（是否可以）拆分（成字符串数组中的元素）  4min"></a>139. 单词（是否可以）拆分（成字符串数组中的元素）  4min</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; wordDict)</span><br></span>&#123;<br>    <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt; st;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">string</span> word : wordDict)<br>        st.insert(word);<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(s.size() + <span class="hljs-number">1</span>)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= s.size();i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)<br>            <span class="hljs-keyword">if</span>(dp[j] &amp;&amp; st.find(s.substr(j, i - j)) != st.end())<br>            &#123;<br>                dp[i] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[s.size()];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="146-LRU缓存机制"><a href="#146-LRU缓存机制" class="headerlink" title="146. LRU缓存机制"></a>146. LRU缓存机制</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DLinkedNode</span><br>&#123;</span><br>    <span class="hljs-keyword">int</span> key, value;<br>    DLinkedNode* prev;<br>    DLinkedNode* next;<br>    DLinkedNode() : key(<span class="hljs-number">0</span>), value(<span class="hljs-number">0</span>), prev(<span class="hljs-literal">nullptr</span>), next(<span class="hljs-literal">nullptr</span>)&#123;&#125;;<br>    DLinkedNode(<span class="hljs-keyword">int</span> _key, <span class="hljs-keyword">int</span> _value) : key(_key), value(_value), prev(<span class="hljs-literal">nullptr</span>), next(<span class="hljs-literal">nullptr</span>)&#123;&#125;;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span><br>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, DLinkedNode*&gt; cache;<br>    <span class="hljs-keyword">int</span> size, capacity;<br>    DLinkedNode* head;<br>    DLinkedNode* tail;<br><span class="hljs-keyword">public</span>:<br>    LRUCache(<span class="hljs-keyword">int</span> _capacity) : size(<span class="hljs-number">0</span>), capacity(_capacity)<br>    &#123;<br>        head = <span class="hljs-keyword">new</span> DLinkedNode();<br>        tail = <span class="hljs-keyword">new</span> DLinkedNode();<br>        head-&gt;next = tail;<br>        tail-&gt;prev = head;<br> &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span><br>    </span>&#123;<br>        <span class="hljs-keyword">if</span>(!cache.count(key))<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        DLinkedNode* node = cache[key];<br>        moveToHead(node);<br>        <span class="hljs-keyword">return</span> node-&gt;value;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span><br>    </span>&#123;<br>        <span class="hljs-keyword">if</span>(!cache.count(key))<br>        &#123;<br>            DLinkedNode* node = <span class="hljs-keyword">new</span> DLinkedNode(key, value);<br>            cache[key] = node;<br>            addToHead(node);<br>            size++;<br>            <span class="hljs-keyword">if</span>(size &gt; capacity)<br>            &#123;<br>                DLinkedNode* remove = tail-&gt;prev;<br>                cache.erase(remove-&gt;key);<br>                removeTail();<br>                size--;<br>                <span class="hljs-keyword">delete</span> remove;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            DLinkedNode* node = cache[key];<br>            node-&gt;value = value;<br>            moveToHead(node);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addToHead</span><span class="hljs-params">(DLinkedNode* node)</span><br>    </span>&#123;<br>        node-&gt;prev = head;<br>        node-&gt;next = head-&gt;next;<br>        head-&gt;next-&gt;prev = node;<br>        head-&gt;next = node;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeNode</span><span class="hljs-params">(DLinkedNode* node)</span><br>    </span>&#123;<br>        node-&gt;next-&gt;prev = node-&gt;prev;<br>        node-&gt;prev-&gt;next = node-&gt;next;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">moveToHead</span><span class="hljs-params">(DLinkedNode* node)</span><br>    </span>&#123;<br>        removeNode(node);<br>        addToHead(node);<br>    &#125;<br>    <span class="hljs-function">DLinkedNode* <span class="hljs-title">removeTail</span><span class="hljs-params">()</span><br>    </span>&#123;<br>        DLinkedNode* node = tail-&gt;prev;<br>        removeNode(node);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="148-排序链表（要求时间复杂度O-nlogn-，空间复杂度O-1-）"><a href="#148-排序链表（要求时间复杂度O-nlogn-，空间复杂度O-1-）" class="headerlink" title="148. 排序链表（要求时间复杂度O(nlogn)，空间复杂度O(1)）"></a>148. 排序链表（要求时间复杂度O(nlogn)，空间复杂度O(1)）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span><br></span>&#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    ListNode* node = head;<br>    <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(node != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        length++;<br>        node = node-&gt;next;<br>    &#125;<br>    ListNode* dummyHead = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>, head);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> subLength = <span class="hljs-number">1</span>; subLength &lt; length; subLength &lt;&lt;= <span class="hljs-number">1</span>)<br>    &#123;<br>        ListNode* prev = dummyHead;<br>        ListNode* curr = dummyHead-&gt;next;<br>        <span class="hljs-keyword">while</span>(curr != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            ListNode* head1 = curr;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; subLength &amp;&amp; curr-&gt;next != <span class="hljs-literal">nullptr</span>; i++)<br>            &#123;<br>                curr = curr-&gt;next;<br>            &#125;<br>            ListNode* head2 = curr-&gt;next;<br>            curr-&gt;next = <span class="hljs-literal">nullptr</span>;<br>            curr = head2;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; subLength &amp;&amp; curr != <span class="hljs-literal">nullptr</span> &amp;&amp; curr-&gt;next != <span class="hljs-literal">nullptr</span>; i++)<br>            &#123;<br>                curr = curr-&gt;next;<br>            &#125;<br>            ListNode* next = <span class="hljs-literal">nullptr</span>;<br>            <span class="hljs-keyword">if</span>(curr != <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                next = curr-&gt;next;<br>                curr-&gt;next = <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>            <span class="hljs-comment">//curr = next;</span><br>            ListNode* merged = merge(head1, head2);<br>            prev-&gt;next = merged;<br>            <span class="hljs-keyword">while</span>(prev-&gt;next != <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                prev = prev-&gt;next;<br>            &#125;<br>            curr = next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br>&#125;<br><span class="hljs-function">ListNode* <span class="hljs-title">merge</span><span class="hljs-params">(ListNode* head1, ListNode* head2)</span><br></span>&#123;<br>    ListNode* dummyHead = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>    ListNode* temp = dummyHead;<br>    ListNode* temp1 = head1;<br>    ListNode* temp2 = head2;<br>    <span class="hljs-keyword">while</span>(temp1 != <span class="hljs-literal">nullptr</span> &amp;&amp; temp2 != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(temp1-&gt;val &lt;= temp2-&gt;val)<br>        &#123;<br>            temp-&gt;next = temp1;<br>            temp1 = temp1-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            temp-&gt;next = temp2;<br>            temp2 = temp2-&gt;next;<br>        &#125;<br>        temp = temp-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(temp1 != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        temp-&gt;next = temp1;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(temp2 != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        temp-&gt;next = temp2;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a>152. 乘积最大子数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span><br></span>&#123;<br>    <span class="hljs-keyword">int</span> maxF = nums[<span class="hljs-number">0</span>], minF = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> ans = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.size(); i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> mx = maxF, mn = minF;<br>        maxF = max(mx * nums[i], max(mn * nums[i], nums[i]));<br>        minF = min(mx * nums[i], min(mn * nums[i], nums[i]));<br>        ans = max(maxF, ans);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="155-最小栈（保证能常数时间内返回最小值）"><a href="#155-最小栈（保证能常数时间内返回最小值）" class="headerlink" title="155. 最小栈（保证能常数时间内返回最小值）"></a>155. 最小栈（保证能常数时间内返回最小值）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span><br>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; xStack;<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; mStack;<br>    MinStack()<br>    &#123;<br>        mStack.push(INT_MIN);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span><br>    </span>&#123;<br>        xStack.push(x);<br>        mStack.push(min(x, mStack.pop()));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span><br>    </span>&#123;<br>        xStack.pop();<br>        mStack.pop();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span><br>    </span>&#123;<br>        <span class="hljs-keyword">return</span> xStack.top();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span><br>    </span>&#123;<br>        <span class="hljs-keyword">return</span> mStack.top();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a>198. 打家劫舍</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span><br></span>&#123;<br>    <span class="hljs-keyword">if</span>(nums.empty())<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> n = nums.size();<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>    dp[<span class="hljs-number">1</span>] = max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++)<br>    &#123;<br>        dp[i] = max(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + nums[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a>200. 岛屿数量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span><br>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; parent;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; rank;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br>    UnionFind(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; grid)<br>    &#123;<br><span class="hljs-keyword">int</span> m = grid.size();<br>        <span class="hljs-keyword">int</span> n = grid[<span class="hljs-number">0</span>].size();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; m; r++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; n; c++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(grid[r][c] == <span class="hljs-string">'1'</span>)<br>                &#123;<br>                    parent.push_back(r * n + c);<br>                    count++;<br>&#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    parent.push_back(<span class="hljs-number">-1</span>);<br>                &#125;<br>                rank.push_back(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span><br>    </span>&#123;<br>        <span class="hljs-keyword">if</span>(parent[i] != i)<br>            parent[i] = find(parent[i]);<br>        <span class="hljs-keyword">return</span> parent[i];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span><br>    </span>&#123;<br>        <span class="hljs-keyword">int</span> rootx = find(x);<br>        <span class="hljs-keyword">int</span> rooty = find(y);<br>        <span class="hljs-keyword">if</span>(rootx != rooty)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(rank[rootx] &lt; rank[rooty])<br>            &#123;<br>                swap(rootx, rooty);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(rank[rootx] == rank[rooty])<br>            &#123;<br>                rank[rootx] += <span class="hljs-number">1</span>;<br>            &#125;<br>parent[rooty] = rootx;<br>            count--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span><br>    </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><br>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; grid)</span><br>    </span>&#123;<br>        <span class="hljs-keyword">int</span> nr = grid.size();<br>        <span class="hljs-keyword">int</span> nc = grid[<span class="hljs-number">0</span>].size();<br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(grid)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; nr; r++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; nc; c++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(grid[r][c] == <span class="hljs-string">'1'</span>)<br>                &#123;<br>                    grid[r][c] = <span class="hljs-string">'0'</span>;<br>                    <span class="hljs-keyword">if</span>(r - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[r - <span class="hljs-number">1</span>][c] == <span class="hljs-string">'1'</span>) uf.unite(r * nc + c, (r - <span class="hljs-number">1</span>) * nc + c);<br>                    <span class="hljs-keyword">if</span>(r + <span class="hljs-number">1</span> &lt; nr &amp;&amp; grid[r + <span class="hljs-number">1</span>][c] == <span class="hljs-string">'1'</span>) uf.unite(r * nc + c, (r + <span class="hljs-number">1</span>) * nc + c);<br>                    <span class="hljs-keyword">if</span>(c - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[r][c - <span class="hljs-number">1</span>] == <span class="hljs-string">'1'</span>) uf.unite(r * nc + c, r * nc + c - <span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">if</span>(c + <span class="hljs-number">1</span> &lt; nc &amp;&amp; grid[r][c + <span class="hljs-number">1</span>] == <span class="hljs-string">'1'</span>) uf.unite(r * nc + c, r * nc + c + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uf.getCount();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="206-翻转链表"><a href="#206-翻转链表" class="headerlink" title="206. 翻转链表"></a>206. 翻转链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 递归</span><br><span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span><br></span>&#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    ListNode* ret = reverseList(head-&gt;next);<br>    head-&gt;next-&gt;next = head;<br>    head-&gt;next = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><span class="hljs-comment">// 双指针迭代</span><br><span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span><br></span>&#123;<br>    ListNode* pre = head;<br>    ListNode* cur = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span>(pre != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        ListNode* p = pre-&gt;next;<br>        pre-&gt;next = cur;<br>        cur = pre;<br>        pre = p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cur;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="208-实现Trie-前缀树"><a href="#208-实现Trie-前缀树" class="headerlink" title="208. 实现Trie(前缀树)"></a>208. 实现Trie(前缀树)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span><br>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">bool</span> isEnd;<br>    Trie* next[<span class="hljs-number">26</span>];<br><span class="hljs-keyword">public</span>:<br>    Trie()<br>    &#123;<br>        isEnd = <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">memset</span>(next, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(next));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-built_in">string</span> word)</span><br>    </span>&#123;<br>        Trie* node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : word)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(node-&gt;next[c - <span class="hljs-string">'a'</span>] == <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                node-&gt;next[c - <span class="hljs-string">'a'</span>] = <span class="hljs-keyword">new</span> Trie();<br>            &#125;<br>            node = node-&gt;next[c - <span class="hljs-string">'a'</span>];<br>        &#125;<br>        node-&gt;isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-built_in">string</span> word)</span><br>    </span>&#123;<br>        Trie* node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : word)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(node-&gt;next[c - <span class="hljs-string">'a'</span>] == <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            node = node-&gt;next[c - <span class="hljs-string">'a'</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> node-&gt;isEnd;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(<span class="hljs-built_in">string</span> prefix)</span><br>    </span>&#123;<br>        Trie* node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : prefix)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(node-&gt;next[c - <span class="hljs-string">'a'</span>] == <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            node = node-&gt;next[c - <span class="hljs-string">'a'</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="739-每日温度（每天找下一个比今天更高的温度）"><a href="#739-每日温度（每天找下一个比今天更高的温度）" class="headerlink" title="739. 每日温度（每天找下一个比今天更高的温度）"></a>739. 每日温度（每天找下一个比今天更高的温度）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dailyTemperature</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; T)</span><br></span>&#123;<br>    <span class="hljs-keyword">int</span> n = T.size();<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ret</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; stk;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(!stk.empty() &amp;&amp; T[i] &gt; T[stk.top()])<br>        &#123;<br>            <span class="hljs-keyword">int</span> prevIndex = stk.top();<br>            ret[prevIndex] = i - prevIndex;<br>            stk.pop();<br>        &#125;<br>        stk.push(i);<br>    &#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-两数之和（为目标值）-3min&quot;&gt;&lt;a href=&quot;#1-两数之和（为目标值）-3min&quot; class=&quot;headerlink&quot; title=&quot;1. 两数之和（为目标值）   3min&quot;&gt;&lt;/a&gt;1. 两数之和（为目标值）   3min&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs c++&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;twoSum&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; nums, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; target)&lt;/span&gt;&lt;br&gt;&lt;/span&gt;&amp;#123;&lt;br&gt;    umordered_map&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt; hashtable;&lt;br&gt;    &lt;span class=&quot;hljs-comment&quot;&gt;/* xiaoguo */&lt;/span&gt;&lt;br&gt;    &lt;br&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; nums.size(); i++)&lt;br&gt;    &amp;#123;&lt;br&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; it = hashtable.find(target - nums[i]);&lt;br&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(it != hashtable.end())&lt;br&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &amp;#123;it-&amp;gt;second, i&amp;#125;;&lt;br&gt;        hashtable[nums[i]] = i;&lt;br&gt;    &amp;#125;&lt;br&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&amp;#125;;&lt;br&gt;&amp;#125;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>哈希专题</title>
    <link href="https://chasencenge.github.io/2020/10/29/%E5%93%88%E5%B8%8C%E4%B8%93%E9%A2%98/"/>
    <id>https://chasencenge.github.io/2020/10/29/哈希专题/</id>
    <published>2020-10-29T06:07:49.000Z</published>
    <updated>2020-12-28T08:56:55.493Z</updated>
    
    <content type="html"><![CDATA[<h4 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a>49. 字母异位词分组</h4><p>如何将异位词分到一组？</p><p>对于每个字符串，对其进行字典排序，利用排序后的string作为map的key，将排序前的string推到value中</p><p>用到的数据结构为：unordered_map&lt;string, vector<string>&gt; mp</string></p><p>最后将mp中的每个元素的second push_back到结果集ret中</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;49-字母异位词分组&quot;&gt;&lt;a href=&quot;#49-字母异位词分组&quot; class=&quot;headerlink&quot; title=&quot;49. 字母异位词分组&quot;&gt;&lt;/a&gt;49. 字母异位词分组&lt;/h4&gt;&lt;p&gt;如何将异位词分到一组？&lt;/p&gt;
&lt;p&gt;对于每个字符串，对其进行字典排序，利用排序后的string作为map的key，将排序前的string推到value中&lt;/p&gt;
&lt;p&gt;用到的数据结构为：unordered_map&amp;lt;string, vector&lt;string&gt;&amp;gt; mp&lt;/string&gt;&lt;/p&gt;
&lt;p&gt;最后将mp中的每个元素的second push_back到结果集ret中&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>特殊技巧专题</title>
    <link href="https://chasencenge.github.io/2020/10/29/%E7%89%B9%E6%AE%8A%E6%8A%80%E5%B7%A7%E4%B8%93%E9%A2%98/"/>
    <id>https://chasencenge.github.io/2020/10/29/特殊技巧专题/</id>
    <published>2020-10-29T05:15:00.000Z</published>
    <updated>2020-12-28T08:54:56.168Z</updated>
    
    <content type="html"><![CDATA[<h4 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a>48. 旋转图像</h4><p>对矩阵的<strong>原地</strong>旋转操作可通过转置并翻转来实现</p><p>本题要求完成90°旋转，可先求转置，再对每一行进行翻转</p><p>如果要旋转180°，可以先对列翻转，再对行翻转</p><p>如果要逆时针旋转90°，则先求转置，再对列进行翻转</p><a id="more"></a><h4 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29. 顺时针打印矩阵"></a>29. 顺时针打印矩阵</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">处理移动四个移动方向用：<br>vector&lt;vector&lt;int&gt;&gt; move&#123; &#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125; &#125;;<br>或者：<br>static constexpr int directions[4][2] = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;<br>标记矩阵的已访问元素和未访问元素用一个相同大小的bool矩阵visit<br>输入一个空matrix时，如果对其求matrix[0].size()会报错，因为没有matrix[0]<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; order;<br><br>    <span class="hljs-keyword">if</span> (matrix.size() == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].size() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> rowRange = matrix.size();<br>    <span class="hljs-keyword">int</span> colRange = matrix[<span class="hljs-number">0</span>].size();<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-title">visit</span><span class="hljs-params">(rowRange, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(colRange))</span></span>;<br>    <span class="hljs-keyword">int</span> total = rowRange * colRange;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; move&#123; &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125; &#125;;<br>    <span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> moveIndex = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> nextRow, nextCol;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; total; i++)<br>    &#123;<br>        order.push_back(matrix[row][col]);<br>        visit[row][col] = <span class="hljs-literal">true</span>;<br>        nextRow = row + move[moveIndex][<span class="hljs-number">0</span>];<br>        nextCol = col + move[moveIndex][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (nextRow &gt;= rowRange || nextRow &lt; <span class="hljs-number">0</span> || nextCol &gt;= colRange || nextCol &lt; <span class="hljs-number">0</span> || visit[nextRow][nextCol])<br>        &#123;<br>            moveIndex = (moveIndex + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;<br>        &#125;<br>        row += move[moveIndex][<span class="hljs-number">0</span>];<br>        col += move[moveIndex][<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> order;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a>56. 合并区间</h4><p>先按区间左边界进行升序排序</p><p>每次检查是否能合并时，比较：当前区间的左边界和结果集合中最后一个区间的右边界</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(intervals[i][<span class="hljs-number">0</span>] &lt;= ret.back()[<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p>如果当前区间左边界小于结果集合中最后一个区间的右边界，说明区间重叠，修改当前区间的右边界，选择当前比较的两个区间的右边界中的较大值作为新的右边界</p><p>如果不能合并，在结果集合ret中push_back当前检查的区间</p><h4 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a>62. 不同路径</h4><p>求只能往右或者往下走的全路径：排列组合中的组合</p><p>尽可能的防止溢出，每次循环中更新完分子和分母后，都用分子和分母分别除以公约数</p><p>公约数计算方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span>   <br>    </span>&#123;<br>        <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : gcd(b, a % b);<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;48-旋转图像&quot;&gt;&lt;a href=&quot;#48-旋转图像&quot; class=&quot;headerlink&quot; title=&quot;48. 旋转图像&quot;&gt;&lt;/a&gt;48. 旋转图像&lt;/h4&gt;&lt;p&gt;对矩阵的&lt;strong&gt;原地&lt;/strong&gt;旋转操作可通过转置并翻转来实现&lt;/p&gt;
&lt;p&gt;本题要求完成90°旋转，可先求转置，再对每一行进行翻转&lt;/p&gt;
&lt;p&gt;如果要旋转180°，可以先对列翻转，再对行翻转&lt;/p&gt;
&lt;p&gt;如果要逆时针旋转90°，则先求转置，再对列进行翻转&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>栈和队列专题</title>
    <link href="https://chasencenge.github.io/2020/10/29/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E4%B8%93%E9%A2%98/"/>
    <id>https://chasencenge.github.io/2020/10/29/栈和队列专题/</id>
    <published>2020-10-29T05:14:13.000Z</published>
    <updated>2020-12-28T08:57:06.498Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>树专题</title>
    <link href="https://chasencenge.github.io/2020/10/28/%E6%A0%91%E5%9B%BE%E4%B8%93%E9%A2%98/"/>
    <id>https://chasencenge.github.io/2020/10/28/树图专题/</id>
    <published>2020-10-28T11:50:18.000Z</published>
    <updated>2020-12-28T07:01:51.738Z</updated>
    
    <content type="html"><![CDATA[<h4 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a>207. 课程表</h4><p>我们可以将本题建模成一个求拓扑排序的问题：将每一门课看成一个节点，如果想要学习课程 A之前必须完成课程 B，那么我们从B到A连接一条有向边。这样以来，在拓扑排序中，B一定出现在 A的前面</p><a id="more"></a><p><strong>思路：</strong></p><p>考虑拓扑排序中最前面的节点，该节点一定不会有任何入边，也就是它没有任何的先修课程要求。当我们将一个节点加入答案中后，我们就可以移除它的所有出边，代表着它的相邻节点少了一门先修课程的要求。如果某个相邻节点变成了「没有任何入边的节点」，那么就代表着这门课可以开始学习了。按照这样的流程，我们不断地将没有入边的节点加入答案，直到答案中包含所有的节点（得到了一种拓扑排序）或者不存在没有入边的节点（图中包含环）</p><p><strong>算法：</strong></p><p>使用一个队列来进行广度优先搜索。初始时，所有入度为 00 的节点都被放入队列中，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。</p><p>在广度优先搜索的每一步中，我们取出队首的节点u：</p><p>我们将u放入答案中</p><p>我们移除 u的所有出边，也就是将u的所有相邻节点的入度减少1。如果某个相邻节点v的入度变为0，那么我们就将v放入队列中</p><p>在广度优先搜索的过程结束后。如果答案中包含了这n个节点，那么我们就找到了一种拓扑排序，否则说明图中存在环，也就不存在拓扑排序了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numCourses, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br>    <span class="hljs-comment">//入度 in degree</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; indeg;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; edges;<br>    <span class="hljs-comment">//resize内的默认初始化值为0</span><br>    indeg.resize(numCourses);<br>    edges.resize(numCourses);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; info : prerequisites)<br>    &#123;<br>        <span class="hljs-comment">//以info[1]为起始的边，指向info[0]</span><br>        edges[info[<span class="hljs-number">1</span>]].push_back(info[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">//info[0]的入度加一，指向它的是info[1]</span><br>        ++indeg[info[<span class="hljs-number">0</span>]];<br>    &#125;<br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++)<br>    &#123;<br>        <span class="hljs-comment">//把最开始入度为0的点push进去</span><br>        <span class="hljs-keyword">if</span> (indeg[i] == <span class="hljs-number">0</span>)<br>        &#123;<br>            q.push(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> visited = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!q.empty())<br>    &#123;<br>        visited++;<br>        <span class="hljs-keyword">int</span> u = q.front();<br>        q.pop();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v : edges[u])<br>        &#123;<br>            --indeg[v];<br>            <span class="hljs-comment">//如果去掉指向它的u之后，v点的入度变为0，那么push进队列</span><br>            <span class="hljs-keyword">if</span> (indeg[v] == <span class="hljs-number">0</span>)<br>            &#123;<br>                q.push(v);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> visited == numCourses;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-字符串转换整数"><a href="#8-字符串转换整数" class="headerlink" title="8. 字符串转换整数"></a>8. 字符串转换整数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 有限自动机，写一个有限自动机类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Automation</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; table = &#123;<br>        &#123;<span class="hljs-string">"start"</span>, &#123;<span class="hljs-string">"start"</span>, <span class="hljs-string">"signed"</span>, <span class="hljs-string">"in_number"</span>, <span class="hljs-string">"end"</span>&#125;&#125;,<br>        &#123;<span class="hljs-string">"signed"</span>, &#123;<span class="hljs-string">"end"</span>, <span class="hljs-string">"end"</span>, <span class="hljs-string">"in_number"</span>, <span class="hljs-string">"end"</span>&#125;&#125;,<br>        &#123;<span class="hljs-string">"in_number"</span>, &#123;<span class="hljs-string">"end"</span>, <span class="hljs-string">"end"</span>, <span class="hljs-string">"in_number"</span>, <span class="hljs-string">"end"</span>&#125;&#125;,<br>        &#123;<span class="hljs-string">"end"</span>, &#123;<span class="hljs-string">"end"</span>, <span class="hljs-string">"end"</span>, <span class="hljs-string">"end"</span>, <span class="hljs-string">"end"</span>&#125;&#125;<br>    &#125;;<br>    <span class="hljs-built_in">string</span> status = <span class="hljs-string">"start"</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_col</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span><br>    </span>&#123;<br>        <span class="hljs-keyword">if</span>(c == <span class="hljs-string">' '</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(c == <span class="hljs-string">'+'</span> || c == <span class="hljs-string">'-'</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isdigit</span>(c))<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> sign = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span><br>    </span>&#123;<br>        status = table[status][get_col(c)];<br>        <span class="hljs-keyword">if</span>(status == <span class="hljs-string">"in_number"</span>)<br>        &#123;<br>            res =  res * <span class="hljs-number">10</span> + (c - <span class="hljs-string">'0'</span>);<br>            res = sign == <span class="hljs-number">1</span> ? min(res, (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)INT_MAX) : min(res, -(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)INT_MIN);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(status == <span class="hljs-string">"signed"</span>)<br>        &#123;<br>            sign = c == <span class="hljs-string">'+'</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str)</span> </span>&#123;<br>        Automation atmn;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : str)<br>        &#123;<br>            atmn.get(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> atmn.sign * atmn.res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id><a href="#" class="headerlink" title></a></h4>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;207-课程表&quot;&gt;&lt;a href=&quot;#207-课程表&quot; class=&quot;headerlink&quot; title=&quot;207. 课程表&quot;&gt;&lt;/a&gt;207. 课程表&lt;/h4&gt;&lt;p&gt;我们可以将本题建模成一个求拓扑排序的问题：将每一门课看成一个节点，如果想要学习课程 A之前必须完成课程 B，那么我们从B到A连接一条有向边。这样以来，在拓扑排序中，B一定出现在 A的前面&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>空间换时间专题</title>
    <link href="https://chasencenge.github.io/2020/10/28/%E7%A9%BA%E9%97%B4%E6%8D%A2%E6%97%B6%E9%97%B4%E4%B8%93%E9%A2%98/"/>
    <id>https://chasencenge.github.io/2020/10/28/空间换时间专题/</id>
    <published>2020-10-28T11:49:39.000Z</published>
    <updated>2020-10-28T11:57:26.346Z</updated>
    
    <content type="html"><![CDATA[<h4 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h4><p>此题首先需知如何计算总雨水量：</p><p>总雨水量的计算需知数组中的每个数左侧和右侧的最高值，取二者较小值减去当前高度，即为当前点处能蓄水的量</p><p>如果不用空间换时间，计算每个点左右两侧的最大值都需要遍历一次所有数据</p><p>所以用两个数组leftMax和rightMax分别存储每个点左侧的最大值和右侧的最大值</p><p>最后再一次遍历计算总蓄水量</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;42-接雨水&quot;&gt;&lt;a href=&quot;#42-接雨水&quot; class=&quot;headerlink&quot; title=&quot;42. 接雨水&quot;&gt;&lt;/a&gt;42. 接雨水&lt;/h4&gt;&lt;p&gt;此题首先需知如何计算总雨水量：&lt;/p&gt;
&lt;p&gt;总雨水量的计算需知数组中的每个数左侧和右侧的最高值，取二者
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lambda表达式</title>
    <link href="https://chasencenge.github.io/2020/10/25/C-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://chasencenge.github.io/2020/10/25/C-Lambda表达式/</id>
    <published>2020-10-25T09:01:24.000Z</published>
    <updated>2020-10-26T09:32:03.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lambda申明方式"><a href="#Lambda申明方式" class="headerlink" title="Lambda申明方式"></a>Lambda申明方式</h1><p>Lambda表达式允许在函数内部创建一个匿名函数</p><h3 id="声明方式：-captrues-params-gt-ret-Statements"><a href="#声明方式：-captrues-params-gt-ret-Statements" class="headerlink" title="声明方式：[captrues(params) -&gt;ret {Statements};"></a>声明方式：[captrues(params) -&gt;ret {Statements};</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> fadd = [](<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)<br>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;; <span class="hljs-comment">// 注意最后有分号</span><br></code></pre></td></tr></table></figure><p>[]表示开始定定义Lambda表达式，()里面是函数的参数 ，{}里面是函数体</p><h3 id="显示指明返回值："><a href="#显示指明返回值：" class="headerlink" title="显示指明返回值："></a>显示指明返回值：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> fadd = [](<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) -&gt; ret<br>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="Lambda表达式的变量截取"><a href="#Lambda表达式的变量截取" class="headerlink" title="Lambda表达式的变量截取"></a>Lambda表达式的变量截取</h1><p>[] 不截取任何变量</p><p>[&amp;] 截取外部作用域的所有变量，并作为引用在函数体中使用</p><p>[=] 截取外部作用域中的所有变量，并拷贝一份在函数体中使用</p><p>[=, &amp;foo] 截取外部作用域中所有变量并拷贝一份在函数体中使用，但对foo变量使用引用</p><p>[bar] 截取bar变量并拷贝一份在函数体使用，不截取其他变量</p><p>[this] 截取当前类中的指针</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Lambda申明方式&quot;&gt;&lt;a href=&quot;#Lambda申明方式&quot; class=&quot;headerlink&quot; title=&quot;Lambda申明方式&quot;&gt;&lt;/a&gt;Lambda申明方式&lt;/h1&gt;&lt;p&gt;Lambda表达式允许在函数内部创建一个匿名函数&lt;/p&gt;
&lt;h3 id=&quot;声
      
    
    </summary>
    
    
      <category term="cpp" scheme="https://chasencenge.github.io/categories/cpp/"/>
    
    
      <category term="cpp" scheme="https://chasencenge.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>双指针专题</title>
    <link href="https://chasencenge.github.io/2020/10/16/%E5%8F%8C%E6%8C%87%E9%92%88%E4%B8%93%E9%A2%98/"/>
    <id>https://chasencenge.github.io/2020/10/16/双指针专题/</id>
    <published>2020-10-15T16:08:03.000Z</published>
    <updated>2020-12-28T08:55:35.052Z</updated>
    
    <content type="html"><![CDATA[<h4 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a>16. 最接近的三数之和</h4><p>相对于暴力解法，双指针能够通过首尾指针和合理移动，减少不合理情况的遍历，即a+b+c &lt; target，则c向左移动，a+b+c &gt; target，b向右移动</p><p>进一步可以总结出：<strong>若想要使两数之和逼近某一个目标值</strong>，可使用双指针对已排序数组进行查找</p><a id="more"></a><p><strong>对已排序数组的遍历时跳过重复值</strong>的通用优化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> p0 = p + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(nums[p0] == nums[p] &amp;&amp; p0 &lt; q)<br>    p0++;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">threeSumClosest</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1e7</span>;<br>    <span class="hljs-keyword">int</span> n = nums.size();<br>    sort(nums.begin(), nums.end());<br>    <span class="hljs-keyword">int</span> sum;<br>    <span class="hljs-keyword">auto</span> update = [&amp;](<span class="hljs-keyword">int</span> cur)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(cur - target) &lt; <span class="hljs-built_in">abs</span>(ans - target))<br>        &#123;<br>            ans = cur;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">2</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>])<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">int</span> p = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> q = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(p &lt; q)<br>        &#123;<br>            sum = nums[i] + nums[p] + nums[q];<br>            <span class="hljs-keyword">if</span>(sum == target)<br>            &#123;<br>                <span class="hljs-keyword">return</span> target;<br>            &#125;<br>            update(sum);<br>            <span class="hljs-keyword">if</span>(sum &lt; target)<br>            &#123;<br>                <span class="hljs-keyword">int</span> p0 = p + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span>(nums[p0] == nums[p] &amp;&amp; p0 &lt; q)<br>                    p0++;<br>                p = p0;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(sum &gt; target)<br>            &#123;<br>                <span class="hljs-keyword">int</span> q0 = q - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span>(q0 &gt; p &amp;&amp; nums[q0] == nums[q])<br>                &#123;<br>                    q0--;<br>                &#125;<br>                q = q0;<br>            &#125;<br><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a>19. 删除链表的倒数第N个节点</h4><h5 id="怎样一次遍历找到倒数第N个节点？"><a href="#怎样一次遍历找到倒数第N个节点？" class="headerlink" title="怎样一次遍历找到倒数第N个节点？"></a>怎样一次遍历找到倒数第N个节点？</h5><p>双指针，前面的指针在后面的指针前N+1的位置，同步前进，然后当前面的指针指到nullptr时，后面的指针处于倒数N+1位置，这时令：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">p-&gt;next = p-&gt;next-&gt;next;<br></code></pre></td></tr></table></figure><h5 id="怎样保证最后返回正确的头节点？（原链表的头节点可能被删除）"><a href="#怎样保证最后返回正确的头节点？（原链表的头节点可能被删除）" class="headerlink" title="怎样保证最后返回正确的头节点？（原链表的头节点可能被删除）"></a>怎样保证最后返回正确的头节点？（原链表的头节点可能被删除）</h5><p>开始时在head前new一个节点hair：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">ListNode* hair = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>, head); <span class="hljs-comment">// (val, next)</span><br></code></pre></td></tr></table></figure><p>最后返回hair-&gt;next</p><h4 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a>18. 四数之和</h4><p>先将数组用sort()进行排序</p><p>双重循环遍历前两个数，后两个数分配双指针一前一后</p><p>外面双重循环：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n<span class="hljs-number">-3</span>; i++)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>; j &lt; n<span class="hljs-number">-2</span>; j++)<br>&#123;<br>......<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>双指针起始位置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> p = j + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> q = n - <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>剪枝操作：</p><p>在外层的两重循环中分别做如下几种情况的剪枝：</p><p>当前值nums[i]与上一个值nums[i-1]相同时，continue</p><p>当前值nums[i]加上后面连续三个数nums[i+1], nums[i+2], nums[i+3]的和大于target，则之后不论如何取值都一定大于target，直接跳出循环break</p><p>当前值nums[i]加上倒数三个最大的值nums[n-1], nums[n-2], nums[n-3]的和小于target，说明以nums[i]起始的任意四个数的和均小于target，跳出本次循环continue</p><p>对于第二层循环做类似的三种情况的剪枝处理</p><h4 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a>415. 字符串相加</h4><p>实现两个字符串的数值相加，不能用类型转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">addStrings</span><span class="hljs-params">(<span class="hljs-built_in">string</span> num1, <span class="hljs-built_in">string</span> num2)</span> </span>&#123;<br>    <span class="hljs-comment">//双指针，双指针的“指针”不一定非得是指针类型，能做flag标记就行</span><br><span class="hljs-keyword">int</span> i = num1.length() - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> j = num2.length() - <span class="hljs-number">1</span>;<br><span class="hljs-built_in">string</span> res;<br><span class="hljs-keyword">int</span> multi = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//进位</span><br><span class="hljs-keyword">int</span> add = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span> || add &gt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>)<br>&#123;<br>            <span class="hljs-comment">//两者相减得到的是int型</span><br>x = num1[i] - <span class="hljs-string">'0'</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (j &gt;= <span class="hljs-number">0</span>)<br>&#123;<br>y = num2[j] - <span class="hljs-string">'0'</span>;<br>&#125;<br><span class="hljs-keyword">int</span> result = x + y + add;<br>res.push_back(<span class="hljs-string">'0'</span> + result % <span class="hljs-number">10</span>);<br>add = result / <span class="hljs-number">10</span>;<br>i--;<br>j--;<br>&#125;<br>    <span class="hljs-comment">//因为每次push_back是从低位到高位的，所以结果要翻转</span><br>reverse(res.begin(), res.end());<br><span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a>75. 颜色分类</h4><p>数组中只有0，1，2三种值，对其排序的方式：</p><p>双指针p0和p2，p0用于交换0，p2用于交换2</p><p>p0 = 0，p2 = n - 1</p><p>一次遍历，当前值如果为0，交换当前位置和p0位置的值，当前值如果为2，和p2交换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 这里while的使用要注意，对照输入[2,1,2]</span><br><span class="hljs-keyword">while</span>(i &lt;= p2 &amp;&amp; nums[i] == <span class="hljs-number">2</span>)<br>&#123;<br>    swap(nums[i], nums[p2]);<br>    --p2;<br>&#125;<br><span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>)<br>&#123;<br>    swap(nums[i], nums[p0]);<br>    ++p0;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;16-最接近的三数之和&quot;&gt;&lt;a href=&quot;#16-最接近的三数之和&quot; class=&quot;headerlink&quot; title=&quot;16. 最接近的三数之和&quot;&gt;&lt;/a&gt;16. 最接近的三数之和&lt;/h4&gt;&lt;p&gt;相对于暴力解法，双指针能够通过首尾指针和合理移动，减少不合理情况的遍历，即a+b+c &amp;lt; target，则c向左移动，a+b+c &amp;gt; target，b向右移动&lt;/p&gt;
&lt;p&gt;进一步可以总结出：&lt;strong&gt;若想要使两数之和逼近某一个目标值&lt;/strong&gt;，可使用双指针对已排序数组进行查找&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>UE学习文档</title>
    <link href="https://chasencenge.github.io/2020/10/12/UE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://chasencenge.github.io/2020/10/12/UE学习笔记/</id>
    <published>2020-10-12T08:43:46.000Z</published>
    <updated>2020-12-22T09:21:21.306Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UE4源码编译"><a href="#UE4源码编译" class="headerlink" title="UE4源码编译"></a>UE4源码编译</h1><p>git clone源码</p><p>运行Setup.bat下载依赖文件</p><p>运行GenerateProjectFiles.bat生成工程文件</p><p>运行UE.sln</p><p>在vs打开的工程中，最上方的解决方案配置设置为Development Editor，启动项目设置为UE4，平台WIN64，右键UE4 – Build进行编译</p><p>编译完成后按F5在vs中启动</p><p><strong>注意</strong></p><p>生成工程文件前可能会报错，根据报错信息可判断是否缺少相应的.NET Framework，如果缺少在vs installer中选中相应版本的vs – 修改 – 添加相应的.NET工具</p><p>Epic Game Launcher中不能识别非公版的引擎，向编译版的引擎创建的工程中添加保管库中的素材时，点击添加到工程–显示所有工程–为相应工程手动选择对应的版本号即可添加素材（因为又编译版引擎创建的工程在Launcher中显示的版本标识为“其他”，不选择相应的版本号则素材或插件都会显示不兼容）</p><h1 id="项目打包"><a href="#项目打包" class="headerlink" title="项目打包"></a>项目打包</h1><h2 id="项目打包注意事项"><a href="#项目打包注意事项" class="headerlink" title="项目打包注意事项"></a>项目打包注意事项</h2><h3 id="启动地图"><a href="#启动地图" class="headerlink" title="启动地图"></a>启动地图</h3><p>构建项目时会从游戏默认地图开始，需要点击Project Settings — Maps &amp; Modes 设置game default map</p><p><img src="/2020/10/12/UE学习笔记/map.png" alt="设置启动地图"></p><h3 id="选择目标平台"><a href="#选择目标平台" class="headerlink" title="选择目标平台"></a>选择目标平台</h3><p><img src="/2020/10/12/UE学习笔记/platform.png" alt="设置平台"></p><p>还要记得选择目标硬件(Target Hardware)</p><h3 id="编辑器查看方式"><a href="#编辑器查看方式" class="headerlink" title="编辑器查看方式"></a>编辑器查看方式</h3><p><img src="/2020/10/12/UE学习笔记/editorview.png" alt="选择编辑器视口"></p><h3 id="细化平台性能控制"><a href="#细化平台性能控制" class="headerlink" title="细化平台性能控制"></a>细化平台性能控制</h3><p><img src="/2020/10/12/UE学习笔记/deviceprofile.png" alt="查看和修改设备描述"></p><p>打开Device Profiles以后点击想要修改的设备型号后面的扳手即可对其值进行修改</p><p><img src="/2020/10/12/UE学习笔记/everydevice.png" alt="对其修改"></p><h2 id="Android设置和打包方式"><a href="#Android设置和打包方式" class="headerlink" title="Android设置和打包方式"></a>Android设置和打包方式</h2><h3 id="设置方式"><a href="#设置方式" class="headerlink" title="设置方式"></a>设置方式</h3><p>寻找UE4 Android Works文件夹，一般默认为C:/Program Files/Epic Games/UE_4_版本/Engine/Extras/Android Works/Win64</p><p>安装后可看到CodeWorks Manager窗口</p><p>在手机端，有时需找到usb driver才能使用，一般连数据线即可</p><p><a href="http://developer.android.com/tools/extras/oem-usb.html" target="_blank" rel="noopener">http://developer.android.com/tools/extras/oem-usb.html</a></p><p>解锁设备时要开启开发者模式，开启usb调试</p><p>在设置主页找到“已连接设备”选择启用文件传输</p><p>在电脑上cmd输入adb devices，如果列出了自己的手机设备名，则准备就绪</p><p><strong>注意：</strong></p><p>手机开发者选项中不但需开启USB调试，还打开USB安装，允许通过USB安装应用</p><h3 id="打包方式"><a href="#打包方式" class="headerlink" title="打包方式"></a>打包方式</h3><p>为了更准确的测试，使用Play – Mobile Preview</p><p><img src="/2020/10/12/UE学习笔记/MobilePreview.png" alt="模拟移动端测试"></p><p><strong>退出游戏方式：</strong> “~”打开控制台，输入quit game</p><p><strong>确保项目做好准备：</strong></p><p>Settings – Project Settings – Platforms – Android </p><p>页面顶部会有警告称项目尚未对Android完成配置，点击configure now</p><p>设置文件包名称，格式为：com.MyGameCompany.MyCoolGame</p><p>并完成项目命名</p><p>如果要计划使用Google Play服务，向下滚动到Google Play Services并点击Configure Now，以将平台构建到游戏中</p><p><img src="/2020/10/12/UE学习笔记/GooglePlayServices.png" alt="计划使用Google Play服务"></p><p><strong>构建到设备：</strong></p><p><img src="/2020/10/12/UE学习笔记/toDivice.png" alt="构建到设备"></p><p>测试并部署到自己的设备很方便，如果需要部署到其他设备，需打包</p><p><img src="/2020/10/12/UE学习笔记/package.png" alt="打包"></p><p>双击生成的.bat项目可以将其安装到自己的Android设备上</p><p><strong>注意</strong></p><p>记得在项目设置 – Android勾选将游戏数据打包至.apk中</p><h1 id="UE4游戏框架"><a href="#UE4游戏框架" class="headerlink" title="UE4游戏框架"></a>UE4游戏框架</h1><p> 游戏架构的基类是GameMode，设置游戏规则，也分则处理生成玩家</p><h3 id="Pawn"><a href="#Pawn" class="headerlink" title="Pawn"></a>Pawn</h3><p>作为世界中的一个“代理”Actor，可由控制器处理 ，可接收输入并且可执行各种各样类似于玩家的动作（但不假定Pawn就是类人的）</p><h3 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h3><p>类人的Pawn，本身默认具有用于碰撞的CapsuleComponent（胶囊体组件）和CharacterMovementComponent（角色运动组件）；可进行基本的拟人运动、平滑地在网格上复制运动，并具有一些动画相关的功能</p><h3 id="控制Pawn"><a href="#控制Pawn" class="headerlink" title="控制Pawn"></a>控制Pawn</h3><p>Controller负责管理Pawn的Actor，一般分为PlayerController和AIController，控制器可以“具有”一个Pawn并控制它</p><h3 id="HUD"><a href="#HUD" class="headerlink" title="HUD"></a>HUD</h3><p>平视显示信息</p><h3 id="GameMode"><a href="#GameMode" class="headerlink" title="GameMode"></a>GameMode</h3><p>游戏的定义，包括像游戏规则和获胜条件这样的内容；仅存在于服务器上，一般在游戏过程中不会有太多数据改变，并且一定不会具有客户端需要的临时数据</p><h3 id="GameState"><a href="#GameState" class="headerlink" title="GameState"></a>GameState</h3><p>包含游戏状态，包括像关联玩家的列表、分数、象棋游戏中的棋子位置或在开放世界中已经完成的任务列表</p><p>存在于服务器和所有客户端上，可以自由地进行复制来保持同步</p><h3 id="PlayerState"><a href="#PlayerState" class="headerlink" title="PlayerState"></a>PlayerState</h3><p>表示游戏中一个参与者的状态（AI没有PlayerState），适合包含的实例数据有：玩家姓名，分数，多人在线竞技场比赛中的级别，夺旗模式游戏中玩家当前是否占领旗帜</p><p>所有玩家的PlayerStates在所有的机器上都存在，并且可以自由复制包持同步</p><h1 id="UE-C"><a href="#UE-C" class="headerlink" title="UE C++"></a>UE C++</h1><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><p>派生自<code>Actor</code>的类前缀为A</p><p>派生自<code>Object</code>的类前缀为U</p><p>派生自<code>Swidget</code>（Slate UI）的类前缀为S</p><p><code>Enums</code>的类前缀为E</p><p><code>Interface</code>类的前缀通常为I</p><p><code>Template</code>类的前缀为T</p><p>其余类的前缀均为F</p><p>布尔值用b前缀</p><p>全局元素用G前缀</p><p>输入参数用In前缀</p><p>输出参数用Out前缀</p><h2 id="在API文档寻找类或函数"><a href="#在API文档寻找类或函数" class="headerlink" title="在API文档寻找类或函数"></a>在API文档寻找类或函数</h2><p>进入UE4文档 –&gt; Unreal Engine API Reference –&gt; Contents</p><p>Contents下面点击All classes或者All Functions查看所有的类和函数</p><h2 id="防止头文件被编译多次的两种方法"><a href="#防止头文件被编译多次的两种方法" class="headerlink" title="防止头文件被编译多次的两种方法"></a>防止头文件被编译多次的两种方法</h2><p>（1）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta"># <span class="hljs-meta-keyword">ifndef</span> _SOMEFILE_H_</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> _SOMEFILE_H_</span><br>......<br><span class="hljs-meta"># <span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>（2）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta"># <span class="hljs-meta-keyword">pragma</span> once</span><br></code></pre></td></tr></table></figure><h2 id="UCLASS"><a href="#UCLASS" class="headerlink" title="UCLASS()"></a>UCLASS()</h2><p>UCLASS 宏（在头文件）可用于标记从 <code>UObject</code> 派生的类，使 UObject 处理系统识别到它们</p><p>GENERATED_BODY 宏不获取参数，但会对类进行设置，以支持引擎要求的基础结构。所有 UCLASS 均有此要求</p><h2 id="UPROPERTY"><a href="#UPROPERTY" class="headerlink" title="UPROPERTY()"></a>UPROPERTY()</h2><p>为将变量公开到虚幻引擎，需使其成为 <strong>UPROPERTY</strong>。利用此操作，可在启动游戏或加载保存的关卡时保留变量的值。带有空括号的 <code>UPROPERTY</code> 标记，将被添加到受其它影响的变量正上方</p><p><code>UPROPERTY</code> 支持改变虚幻引擎使用变量方式的参数。将变量设为可编辑，可添加 <code>EditAnywhere</code> 参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">UPROPERTY(EditAnywhere)<br>int32 CountdownTime;<br></code></pre></td></tr></table></figure><p>然后该变量的修改便可在Details（细节面板）中进行</p><h2 id="UFUNCTION"><a href="#UFUNCTION" class="headerlink" title="UFUNCTION()"></a>UFUNCTION()</h2><p>UFUNCTION()宏把C++函数对反射系统公开，BlueprintCallable选项将对其蓝图虚拟机公开</p><p><strong>BlueprintCallable</strong>：该函数可以在蓝图或关卡蓝图图表中执行</p><p><strong>BlueprintImplementableEvent</strong>：此函数可以在蓝图或关卡蓝图图表内进行重载</p><p><strong>BlueprintNativeEvent</strong>：此函数将由蓝图进行重载，但同时也包含native类的执行。提供一个名称为[FunctionName]_Implementation的函数本体而非[FunctionName];自动生成的代码将包含转换程序,此程序在需要时会调用实施方式</p><h2 id="游戏客户端公开课学习文档"><a href="#游戏客户端公开课学习文档" class="headerlink" title="游戏客户端公开课学习文档"></a>游戏客户端公开课学习文档</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;UE4源码编译&quot;&gt;&lt;a href=&quot;#UE4源码编译&quot; class=&quot;headerlink&quot; title=&quot;UE4源码编译&quot;&gt;&lt;/a&gt;UE4源码编译&lt;/h1&gt;&lt;p&gt;git clone源码&lt;/p&gt;
&lt;p&gt;运行Setup.bat下载依赖文件&lt;/p&gt;
&lt;p&gt;运行Gene
      
    
    </summary>
    
    
      <category term="GameDev" scheme="https://chasencenge.github.io/categories/GameDev/"/>
    
    
      <category term="GameDev" scheme="https://chasencenge.github.io/tags/GameDev/"/>
    
  </entry>
  
  <entry>
    <title>实时计算机图形学笔记</title>
    <link href="https://chasencenge.github.io/2020/10/02/%E5%AE%9E%E6%97%B6%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://chasencenge.github.io/2020/10/02/实时计算机图形学笔记/</id>
    <published>2020-10-02T12:04:03.000Z</published>
    <updated>2020-10-26T09:31:51.557Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="GameDev" scheme="https://chasencenge.github.io/categories/GameDev/"/>
    
    
      <category term="GameDev" scheme="https://chasencenge.github.io/tags/GameDev/"/>
    
  </entry>
  
  <entry>
    <title>腾讯游戏开发精粹笔记</title>
    <link href="https://chasencenge.github.io/2020/09/25/%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E7%B2%BE%E7%B2%B9%E7%AC%94%E8%AE%B0/"/>
    <id>https://chasencenge.github.io/2020/09/25/腾讯游戏开发精粹笔记/</id>
    <published>2020-09-25T06:07:13.000Z</published>
    <updated>2020-10-02T12:02:17.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、游戏数学"><a href="#一、游戏数学" class="headerlink" title="一、游戏数学"></a>一、游戏数学</h1><h2 id="1-基于SDF的摇杆移动"><a href="#1-基于SDF的摇杆移动" class="headerlink" title="1.基于SDF的摇杆移动"></a>1.基于SDF的摇杆移动</h2><h3 id="SDF："><a href="#SDF：" class="headerlink" title="SDF："></a>SDF：</h3><p>SDF全称Signed Distance Field（有号距离场），定义为空间中的点到形状表面的最小距离，并用正值表示点在形状外部，负值表示点在形状内部。</p><h3 id="为什么要使用SDF？"><a href="#为什么要使用SDF？" class="headerlink" title="为什么要使用SDF？"></a>为什么要使用SDF？</h3><p>空间换时间，在O(1)时间复杂度计算出是否碰撞。</p><h3 id="如何判断碰撞？"><a href="#如何判断碰撞？" class="headerlink" title="如何判断碰撞？"></a>如何判断碰撞？</h3><p>基于已有SDF信息的栅格，使用其邻近四个角的SD信息进行插值，得到当前点的SD，若SD&lt;=0, 则判定该点和碰撞物发生了碰撞。</p><h3 id="插值获得任意点的SD值："><a href="#插值获得任意点的SD值：" class="headerlink" title="插值获得任意点的SD值："></a>插值获得任意点的SD值：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//计算位置pos的SD值</span><br><span class="hljs-comment">//每个栅格的实际尺寸为grid，横向栅格数量为width</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">Sample</span><span class="hljs-params">(Vector2 pos)</span><br></span>&#123;<br>    pos = pos / grid;<br>    <span class="hljs-keyword">int</span> fx = Mathf.FloorToInt(pos.x);<br>    <span class="hljs-keyword">int</span> fy = Mathf.FloorToInt(pos.y);<br>    <span class="hljs-keyword">float</span> rx = pos.x - fx;<br>    <span class="hljs-keyword">float</span> ry = pos.y - fy;<br>    <span class="hljs-keyword">int</span> i = fy * width + fx;<br>    <span class="hljs-keyword">return</span> (sdf[i]*(<span class="hljs-number">1</span>-rx) + sdf[i+<span class="hljs-number">1</span>]*rx)*(<span class="hljs-number">1</span>-ry) + (sdf[i+width]*(<span class="hljs-number">1</span>-rx) + sdf[i+width+<span class="hljs-number">1</span>]*rx)*ry;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何实现发生碰撞后绕障碍物滑行？"><a href="#如何实现发生碰撞后绕障碍物滑行？" class="headerlink" title="如何实现发生碰撞后绕障碍物滑行？"></a>如何实现发生碰撞后绕障碍物滑行？</h3><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/1.6%E6%BB%91%E8%A1%8C.png" alt="1.6滑行"></p><p>v表示摇杆方向，与障碍物发生碰撞后需要沿着v’方向滑行，n为碰撞法线，v’和v有以上关系。</p><h4 id="如何获取碰撞法线n？"><a href="#如何获取碰撞法线n？" class="headerlink" title="如何获取碰撞法线n？"></a>如何获取碰撞法线n？</h4><p>利用SDF的梯度作为碰撞法线。</p><h4 id="求梯度方向："><a href="#求梯度方向：" class="headerlink" title="求梯度方向："></a>求梯度方向：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">public</span> Vector2 <span class="hljs-title">Gradient</span><span class="hljs-params">(Vector2 pos)</span><br></span>&#123;<br>    <span class="hljs-keyword">float</span> delta = <span class="hljs-number">1f</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0.5f</span> * <span class="hljs-keyword">new</span> Vector2(<br>    Sample(<span class="hljs-keyword">new</span> Vector2(pos.x+delta, pos.y)) - Sample(<span class="hljs-keyword">new</span> Vector2(pos.x-delta, pos.y)), <br>    Sample(<span class="hljs-keyword">new</span> Vector2(pos.x, pos.y+delta)) - Sample(<span class="hljs-keyword">new</span> Vector2(pos.x, pos.y-delta))<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="发生碰撞后实际移动方向代码："><a href="#发生碰撞后实际移动方向代码：" class="headerlink" title="发生碰撞后实际移动方向代码："></a>发生碰撞后实际移动方向代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//获取在移动过程使用SDF得到的最佳位置</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Vector2 <span class="hljs-title">GetValidPositionBySDF</span><span class="hljs-params">(Vector2 pos, Vector2 dir, <span class="hljs-keyword">float</span> speed)</span><br></span>&#123;<br>    Vector2 newPos = pos + dir * speed;<br>    <span class="hljs-keyword">float</span> SD = Sample(newPos);<br>    <br>    <span class="hljs-comment">//不可行走</span><br>    <span class="hljs-keyword">if</span>(SD &lt; playerRadius)<br>    &#123;<br>        Vector2 gradient = Gradient(newPos);<br>        Vector2 adjustDir = dir - gradient * Vector2.Dot(gradient, dir);<br>        newPos = pos + adjustDir.normalized * speed;<br>    &#125;<br>    <br>    <span class="hljs-comment">//多次迭代</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>    &#123;<br>        SD = Sample(newPos);<br>        <span class="hljs-keyword">if</span>(SD &gt;= playerRadius)<br>            <span class="hljs-keyword">break</span>;<br>        newPos += Gradient(newPos) * (playerRadius - SD);<br>    &#125;<br>    <br>    <span class="hljs-comment">//避免往返</span><br>    <span class="hljs-keyword">if</span>(Vector2.Dot(newPos - pos, dir) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        newPos = pos;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newPos;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="角色不能越过障碍物的远距离移动"><a href="#角色不能越过障碍物的远距离移动" class="headerlink" title="角色不能越过障碍物的远距离移动"></a>角色不能越过障碍物的远距离移动</h3><p>用于当校色进行瞬时远距离移动但不能越过障碍物的情况。</p><p>使用连续碰撞检测规避穿越障碍物的情况，具体方法是<strong>圆盘投射（Disk Casting）</strong>。</p><h4 id="使用圆盘投射计算位置："><a href="#使用圆盘投射计算位置：" class="headerlink" title="使用圆盘投射计算位置："></a>使用圆盘投射计算位置：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//oriPos:原始位置，dir:冲刺方向，radius:角色半径，maxDist:最大冲刺距离</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Vector2 <span class="hljs-title">DiskCast</span><span class="hljs-params">(Vector2 origin, Vector2 dir, <span class="hljs-keyword">float</span> radius, <span class="hljs-keyword">float</span> maxDist)</span><br></span>&#123;<br>    <span class="hljs-keyword">float</span> t = <span class="hljs-number">0f</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>    &#123;<br>        Vector2 p = origin + dir * t;<br>        <span class="hljs-keyword">float</span> sd = Sample(p);<br>        <span class="hljs-keyword">if</span>(sd &lt;= radius)<br>            <span class="hljs-keyword">return</span> p;<br>        t += sd - radius;<br>        <span class="hljs-keyword">if</span>(t &gt;= maxDist)<br>            <span class="hljs-keyword">return</span> origin + dir * maxDist;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态地图"><a href="#动态地图" class="headerlink" title="动态地图"></a>动态地图</h3><p>在均匀网格地图上，当角色在一帧内的行走距离不会超过单个网格大小时，可以通过检测每一帧与玩家所在网格相邻的8个网格的碰撞来实现规避障碍物的功能。</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/1.16%E8%A7%92%E8%89%B2%E5%9C%A8%E5%9D%87%E5%8C%80%E7%BD%91%E6%A0%BC%E5%9C%B0%E5%9B%BE%E7%A7%BB%E5%8A%A8.png" alt="1.16角色在均匀网格地图移动"></p><p>红色为障碍物区域，虚线圆圈为角色。</p><h4 id="实现规避障碍物："><a href="#实现规避障碍物：" class="headerlink" title="实现规避障碍物："></a>实现规避障碍物：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">EvalSDF</span><span class="hljs-params">(Vector2 p)</span><br></span>&#123;<br>    <span class="hljs-comment">//坐标离散成网格</span><br>    <span class="hljs-keyword">int</span> x = posToGridX(p);<br>    <span class="hljs-keyword">int</span> y = posToGridY(p);<br>    <span class="hljs-keyword">float</span> dist = cellSize;<br>    <span class="hljs-keyword">int</span> center = grid[y * width + x];<br>    <span class="hljs-comment">//WALL格子不可行走</span><br>    <span class="hljs-comment">//检测与玩家最近的距离</span><br>    <span class="hljs-keyword">if</span>(center == WALL)<br>    &#123;<br>        dist = min(dist, sdBox(centerPos - vecTopLeft, cellExtents));<br>    &#125;<br>    <span class="hljs-keyword">int</span> topleft = grid[(y - <span class="hljs-number">1</span>) * width + (x - <span class="hljs-number">1</span>)];<br>    <span class="hljs-keyword">if</span>(topleft == WALL)<br>    &#123;<br>        dist = min(dist, sdBox(centerPos - vecTop, cellExtents));<br>    &#125;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">return</span> dist;<br>&#125;<br><br><span class="hljs-function">Vector2 <span class="hljs-title">EvalGradient</span><span class="hljs-params">(Vector2 p)</span><br></span>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-comment">//新目标位置</span><br>    Vector2 nextPlayerPos = playerPos + moveDir * moveSpeed;<br>    <span class="hljs-comment">//目标位置的最近距离</span><br>    <span class="hljs-keyword">float</span> d = EvalSDF(nextPlayerPos);<br>    <span class="hljs-comment">//距离小于玩家半径，有穿插</span><br>    <span class="hljs-keyword">if</span>(d &lt; playerRadius)<br>    &#123;<br>        <span class="hljs-comment">//计算最近表面的法线</span><br>        Vector2 n = EvalGradient(nextPlayerPos);<br>        <span class="hljs-comment">//将玩家推出障碍区域</span><br>        nextPlayerPos = nextPlayerPos + n * (playerRadius - d);<br>    &#125;<br>    playerPos = nextPlayerPos;<br>&#125;<br></code></pre></td></tr></table></figure><p>场景中的其他障碍物，如较大的汽车、其他玩家等，可通过<strong>矩形、圆形的SDF函数</strong>来表示，并将结果与网格地图取出的SDF做<strong>交集</strong>操作。</p><h4 id="圆盘SDF"><a href="#圆盘SDF" class="headerlink" title="圆盘SDF:"></a>圆盘SDF:</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//x为任意点坐标，c为圆盘中心，r为圆盘半径</span><br><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">sdCircle</span><span class="hljs-params">(Vector2 x, Vector2 c, <span class="hljs-keyword">float</span> r)</span><br></span>&#123;<br>    <span class="hljs-keyword">return</span> (x - c).length() - r;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="矩形SDF"><a href="#矩形SDF" class="headerlink" title="矩形SDF:"></a>矩形SDF:</h4><p>d = (x - c)R(-θ) - b</p><p>Φ<del>x</del> = min(max(d<del>x</del>, d<del>y</del>), 0) + ||max(d, 0)||</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/1.14%E7%9F%A9%E5%BD%A2SDF.png" alt="1.14矩形SDF"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//x为任意点坐标，c为矩形中心，rot为矩形旋转角度，b为矩形边长</span><br><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">sdBox</span><span class="hljs-params">(Vector2 x, Vector c, Vector2 rot, Vector2 b)</span><br></span>&#123;<br>    Vector2 p = Vector2.Dot(x - c, -rot);<br>    Vector2 d = Vector2.Abs(p) - b;<br>    <span class="hljs-keyword">return</span> Mathf.Min(Mathf.Max(d.x, d.y), <span class="hljs-number">0f</span>) + Vector2.Max(d, Vector2.zero).Length(); <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-高性能的定点数实现方案"><a href="#2-高性能的定点数实现方案" class="headerlink" title="2. 高性能的定点数实现方案"></a>2. 高性能的定点数实现方案</h2><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>解决不同平台上的浮点数运算结果不同而导致的对帧同步的严重影响。</p><h3 id="32位浮点数结构"><a href="#32位浮点数结构" class="headerlink" title="32位浮点数结构"></a>32位浮点数结构</h3><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/32%E4%BD%8D%E6%B5%AE%E7%82%B9%E6%95%B0%E7%BB%93%E6%9E%84.png" alt="32位浮点数结构"></p><p>S=0时为正数，S=1时为负数</p><h3 id="基于整数的二进制表示的定点数原理"><a href="#基于整数的二进制表示的定点数原理" class="headerlink" title="基于整数的二进制表示的定点数原理"></a>基于整数的二进制表示的定点数原理</h3><p>设a为定点数，f(a)为这个定点数对应的整数值</p><p>a = 2^-n^f(a)</p><h3 id="32和64位定点数表示原理"><a href="#32和64位定点数表示原理" class="headerlink" title="32和64位定点数表示原理"></a>32和64位定点数表示原理</h3><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/%E5%AE%9A%E7%82%B9%E6%95%B0%E7%BB%93%E6%9E%84.png" alt="定点数结构"></p><p>32位定点数表示的范围：[-2^21^, 2^21^ - 2^-10^]</p><p>64位定点数表示的范围：[-2^31^, 2^31^ - 2^-32^]</p><h3 id="定点数四则运算"><a href="#定点数四则运算" class="headerlink" title="定点数四则运算"></a>定点数四则运算</h3><p>a + b = 2^-n^ (f(a) + f(b))</p><p>a - b = 2^-n^ (f(a) - f(b))</p><p>ab = (2^-n^)^2^ f(a) f(b) = 2^-n^ (2^-n^ f(a) f(b))</p><p>a / b = 2^-n^ (2^n^ f(a) / f(b))</p><h1 id="二、游戏物理"><a href="#二、游戏物理" class="headerlink" title="二、游戏物理"></a>二、游戏物理</h1><h2 id="1-一种高效的弧长参数化路径系统"><a href="#1-一种高效的弧长参数化路径系统" class="headerlink" title="1. 一种高效的弧长参数化路径系统"></a>1. 一种高效的弧长参数化路径系统</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>在跑酷游戏中，人物的移动靠路径引导；想要实现“弧长参数化”的特性—即令曲线参数t与曲线长度为L为线性关系，从而将参数t的线性变化映射到长度的线性变化上，实现曲线上的匀线速度运动。</p><h4 id="曲线路径系统需求："><a href="#曲线路径系统需求：" class="headerlink" title="曲线路径系统需求："></a>曲线路径系统需求：</h4><p>路径布置简单，最直观的就是布置路点。</p><p>修改具有局部性，修改一个路点只会影响上下游。</p><p>曲线至少具有C1连续性，满足基本的光滑需求。</p><p>两个路点之间的曲线可以是异面曲线，等同于可以自由控制邻接路点曲线的方向。</p><p>与曲线相关的计算尽量简单，尽量少地进行迭代计算。</p><h3 id="端点间二次样条的构建"><a href="#端点间二次样条的构建" class="headerlink" title="端点间二次样条的构建"></a>端点间二次样条的构建</h3><h4 id="为什么要拼接两条二次曲线？"><a href="#为什么要拼接两条二次曲线？" class="headerlink" title="为什么要拼接两条二次曲线？"></a>为什么要拼接两条二次曲线？</h4><p>要求两个路点可以自由控制位置和朝向（切线方向），单一的一段二次曲线自由度不够。</p><h4 id="二次样条曲线："><a href="#二次样条曲线：" class="headerlink" title="二次样条曲线："></a>二次样条曲线：</h4><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/3.1%E4%BA%8C%E6%AC%A1%E6%A0%B7%E6%9D%A1%E6%9B%B2%E7%BA%BF%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="3.1二次样条曲线示意图"></p><p>起点P<del>0</del>、起点切线T<del>0</del>、终点P<del>1</del>、终点切线T<del>1</del>。</p><p>f<del>1</del>(t) = a<del>1</del>t^2^ + b<del>1</del>t + c<del>1</del></p><p>f<del>2</del>(t) = a<del>2</del>t^2^ + b<del>2</del>t + c<del>2</del></p><p>为了将分段曲线当作一段曲线使用，需将两段曲线的参数t归一化到统一的[0, 1]范围内，f<del>s</del>(0) = P<del>0</del>，f<del>s</del>(1) = P<del>1</del>。</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/%E5%8F%82%E6%95%B0t%E5%BD%92%E4%B8%80%E5%8C%96%E5%90%8E%E7%9A%84%E5%88%86%E6%AE%B5%E4%BA%8C%E6%AC%A1%E6%9B%B2%E7%BA%BF.png" alt="参数t归一化后的分段二次曲线"></p><p>例如当L<del>1</del>长度为4，L<del>2</del>长度为6，归一化t = 0.3时，f<del>s</del>(t) = f<del>s</del>(0.3) = f<del>1</del>(0.3 x 10 / 4) = f<del>1</del>(3/4)，恰好对应L<del>1</del>的四分之三位置。</p><h3 id="路径的构建"><a href="#路径的构建" class="headerlink" title="路径的构建"></a>路径的构建</h3><p>路径为路点间曲线的拼接，切线的设置模仿Catmull-Rom这类Cardinal曲线的做法：路点i处的切线由路点i-1和路点i+1的位置决定：</p><p>T<del>i</del> = τ(P<del>i+1</del> - P<del>i-1</del>), τ为切线的缩放因子（张弛因子）</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/3.2Cardinal%E6%9B%B2%E7%BA%BF%E5%88%87%E7%BA%BF%E8%AE%BE%E7%BD%AE.png" alt="3.2Cardinal曲线切线设置"></p><p>使用邻接路点的信息构建曲线时，将邻接路点转换到自己的<strong>局部坐标系</strong>下，在上图的构建中，P<del>i</del>处于坐标原点且旋转为(0, 0, 0)，最后在使用路径时，每段曲线的计算结果要做一次<strong>从局部到世界坐标系的转换</strong>，<strong>好处</strong>是路径作为一个整体不受刚体变换的影响，适合游戏中场景动态拼接的需求。</p><h3 id="弧长的重参数化（arc-length-parametrization）"><a href="#弧长的重参数化（arc-length-parametrization）" class="headerlink" title="弧长的重参数化（arc-length parametrization）"></a>弧长的重参数化（arc-length parametrization）</h3><h4 id="为什么要做弧长的重参数化？"><a href="#为什么要做弧长的重参数化？" class="headerlink" title="为什么要做弧长的重参数化？"></a>为什么要做弧长的重参数化？</h4><p>可近似理解为在曲线上，每一点处的<strong>速度</strong>不同，相同的Δt内对应“走过”的弧长也不相同。</p><p>例如，对于曲线：</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/%E6%9B%B2%E7%BA%BF.png" alt="曲线"></p><p>直接用t取点，具有明显不均匀现象：</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/%E7%9B%B4%E6%8E%A5t%E5%8F%96%E7%82%B9.png" alt="直接t取点"></p><h4 id="arc-length"><a href="#arc-length" class="headerlink" title="arc-length:"></a>arc-length:</h4><p>定义一个映射Δ: [a, b] -&gt; [0, L], 获取原弧线参数t的定义域到弧长区间上的一个满射：</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/%E6%BB%A1%E5%B0%84.png" alt="满射"></p><p>其反函数设为Φ(s)，那么在给定s位置下，对应曲线参数为Φ(s)，对于上述曲线，先求Δ(t)，再求其反函数：</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/%E9%87%8D%E5%8F%82%E6%95%B01.png" alt="重参数1"></p><p>其反函数：</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/%E9%87%8D%E5%8F%82%E6%95%B02.png" alt="重参数2"></p><p>重参数化形式：</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/%E9%87%8D%E5%8F%82%E6%95%B03.png" alt="重参数3"></p><p>arc-length参数化后结果：</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/%E9%87%8D%E5%8F%82%E6%95%B04.png" alt="重参数4"></p><h3 id="曲线上的简单运动"><a href="#曲线上的简单运动" class="headerlink" title="曲线上的简单运动"></a>曲线上的简单运动</h3><p>法平面定义：过空间曲线的切点并且与切线垂直的平面。</p><h3 id="相邻路径的切换"><a href="#相邻路径的切换" class="headerlink" title="相邻路径的切换"></a>相邻路径的切换</h3><p>路径切换的过程中，使用当前路径上的基准点的法平面与另一路径的交点（等位点），由于路径的切换不能瞬时完成，将当前基准点变换到相邻路径基准点的局部坐标系下，将变换后的值和(O, X, Y, Z)插值的结果转换到世界坐标系，作为当前基准点及其关联的局部坐标系输入给物理模块。</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/3.4%E8%B7%AF%E5%BE%84%E5%88%87%E6%8D%A2%E6%8F%92%E5%80%BC%E8%BD%A8%E8%BF%B9.png" alt="3.4路径切换插值轨迹"></p><h3 id="曲线上的旋转插值"><a href="#曲线上的旋转插值" class="headerlink" title="曲线上的旋转插值"></a>曲线上的旋转插值</h3><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/3.5%E6%97%8B%E8%BD%AC%E6%8F%92%E5%80%BC%E5%AF%B9%E6%AF%94.png" alt="3.5旋转插值对比"></p><h2 id="2-船的物理模拟及同步设计"><a href="#2-船的物理模拟及同步设计" class="headerlink" title="2. 船的物理模拟及同步设计"></a>2. 船的物理模拟及同步设计</h2><h3 id="船的两种刚体"><a href="#船的两种刚体" class="headerlink" title="船的两种刚体"></a>船的两种刚体</h3><p>移动碰撞体：用于计算浮力的动态刚体</p><p>射击碰撞体：用来做射击检测的动力学动态刚体</p><h3 id="浮力计算中计算多面体入水体积"><a href="#浮力计算中计算多面体入水体积" class="headerlink" title="浮力计算中计算多面体入水体积"></a>浮力计算中计算多面体入水体积</h3><p>分成三角面判断，一个三角面只有三种状态：完全入水、完全出水、部分出水。</p><p>三角面完全入水，则三角面可以和P形成四面体为入水体积（点P必须在水面上）。</p><p>三角面完全出水，丢弃。</p><p>三角面部分入水，分两种情况，两点入水和一点入水。两点入水，分成的三个三角形，将水面上部的丢弃；一点入水，分成的三个三角形将水面上的两个三角形丢弃。</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/%E4%B8%89%E8%A7%92%E9%9D%A2%E9%83%A8%E5%88%86%E5%85%A5%E6%B0%B4.png" alt="三角面部分入水"></p><p><strong>于是，入水体积的求解收敛为两个问题：</strong></p><p>求一个四面体的体积。</p><p>已知三角形的顶点A, B, C, 求与水面的交点问题。</p><h3 id="浮力系统物理更新机制"><a href="#浮力系统物理更新机制" class="headerlink" title="浮力系统物理更新机制"></a>浮力系统物理更新机制</h3><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/%E7%AC%AC%E4%B8%80%E6%96%B9%E5%92%8C%E7%AC%AC%E4%B8%89%E6%96%B9Component.png" alt="第一方和第三方Component"></p><p>三种第三方位置同步方法：</p><p>设置位置：会造成物体瞬移。</p><p>设置速度：通过计算位移差求出速度，在物理引擎进行物理模拟前应用到动态刚体上。</p><p>设置力：增加了一层间接性。</p><h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><p>第三方同步组件会每帧更新刚体的速度，浮力组件会每帧更新刚体受到的力，会造成位置的不一致（例如第三方刚体本来以速度v移动到位置X，但是浮力组件在速度方向上施加了阻力、浮力和升力，从而使物理系统算出的速度和v有偏差，导致最终物理模拟结束时物体的位置不是X）。</p><h4 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h4><p>浮力系统根据是否是第一方选择最终计算结果是力还是速度。</p><h4 id="Component物理更新的过程："><a href="#Component物理更新的过程：" class="headerlink" title="Component物理更新的过程："></a>Component物理更新的过程：</h4><p>第一方通过引擎组件(EngineComponent)计算出驱动力，通过浮力组件(BuoyancyComponent)计算出浮力，将这些力在物理引擎进行物理模拟之前统一施加在刚体组件(PhyComponent)上；</p><p>第三方通过同步组件(SyncComponent)计算出下一帧的同步速度，通过浮力组件计算出的浮力推算出下一帧的浮力速度，将这两个速度糅合后，在物理引擎进行物理模拟之前设置在刚体组件上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、游戏数学&quot;&gt;&lt;a href=&quot;#一、游戏数学&quot; class=&quot;headerlink&quot; title=&quot;一、游戏数学&quot;&gt;&lt;/a&gt;一、游戏数学&lt;/h1&gt;&lt;h2 id=&quot;1-基于SDF的摇杆移动&quot;&gt;&lt;a href=&quot;#1-基于SDF的摇杆移动&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="GameDev" scheme="https://chasencenge.github.io/categories/GameDev/"/>
    
    
      <category term="GameDev" scheme="https://chasencenge.github.io/tags/GameDev/"/>
    
  </entry>
  
  <entry>
    <title>容器</title>
    <link href="https://chasencenge.github.io/2020/09/15/%E5%AE%B9%E5%99%A8/"/>
    <id>https://chasencenge.github.io/2020/09/15/容器/</id>
    <published>2020-09-15T13:50:54.000Z</published>
    <updated>2020-09-15T14:18:33.577Z</updated>
    
    <content type="html"><![CDATA[<h3 id="容器与镜像"><a href="#容器与镜像" class="headerlink" title="容器与镜像"></a>容器与镜像</h3><p>进程可见、可相互通信、共享一份文件系统</p><p>高级权限的进程可能破环低权限的进程</p><p>资源抢占</p><p>Linux通过 <code>chroot</code> 可将一个子目录变成根目录</p><p><code>namespace</code>在资源视图上进行隔离</p><p><code>cgroup</code>限制资源使用率</p><h4 id="容器："><a href="#容器：" class="headerlink" title="容器："></a>容器：</h4><p>容器是一个视图隔离、资源可限制、独立文件系统的进程集合</p><h4 id="镜像："><a href="#镜像：" class="headerlink" title="镜像："></a>镜像：</h4><p>运行容器需要的所有文件集合</p><p>构建步骤所带来的文件系统的变化叫做changeset</p><p>镜像可进行分层复用</p><h4 id="如何构建镜像？"><a href="#如何构建镜像？" class="headerlink" title="如何构建镜像？"></a>如何构建镜像？</h4><p>编写Dockerfile</p><p>// 表示以下的步骤是基于golang构建的</p><p><code>FROM golang:1.12-alpine</code> </p><p>// 类似于cd</p><p><code>WORKDIR /go/src/app</code></p><p>// 把数据拷入到容器内</p><p><code>COPY</code></p><p>//下载依赖</p><p><code>RUN go get -d -v ./...</code></p><p>//创建应用并安装</p><p><code>RUN go install -v ./...</code></p><p>//使用镜像默认程序的名字是什么</p><p><code>CMD [&quot;app&quot;]</code></p><p>有了这样一个Dockerfile<code>之后就可以通过docker build</code>构建镜像（存储到本地的）</p><p>docker registry进行镜像数据的存储和转发，通过 <code>docker push</code>可以将本地的镜像推送到镜像仓库中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;容器与镜像&quot;&gt;&lt;a href=&quot;#容器与镜像&quot; class=&quot;headerlink&quot; title=&quot;容器与镜像&quot;&gt;&lt;/a&gt;容器与镜像&lt;/h3&gt;&lt;p&gt;进程可见、可相互通信、共享一份文件系统&lt;/p&gt;
&lt;p&gt;高级权限的进程可能破环低权限的进程&lt;/p&gt;
&lt;p&gt;资源抢占&lt;/
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://chasencenge.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://chasencenge.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>贪心专题</title>
    <link href="https://chasencenge.github.io/2020/09/15/%E8%B4%AA%E5%BF%83%E4%B8%93%E9%A2%98/"/>
    <id>https://chasencenge.github.io/2020/09/15/贪心专题/</id>
    <published>2020-09-15T11:24:25.000Z</published>
    <updated>2020-12-28T08:56:46.769Z</updated>
    
    <content type="html"><![CDATA[<h4 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12. 整数转罗马数字"></a>12. 整数转罗马数字</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 处理上有优先级，对于当前的数，优先处理大于1000的部分，然后处理900，500，400.....（每一部分的处理方式也有固定的对应） --&gt; 贪心算法</span><br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">intToRoman</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>    <span class="hljs-built_in">string</span> res;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; store&#123; <span class="hljs-number">1000</span>, <span class="hljs-number">900</span>, <span class="hljs-number">500</span>, <span class="hljs-number">400</span>, <span class="hljs-number">100</span>, <span class="hljs-number">90</span>, <span class="hljs-number">50</span>, <span class="hljs-number">40</span>, <span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span> &#125;;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; strs&#123; <span class="hljs-string">"M"</span>, <span class="hljs-string">"CM"</span>, <span class="hljs-string">"D"</span>, <span class="hljs-string">"CD"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"XC"</span>, <span class="hljs-string">"L"</span>, <span class="hljs-string">"XL"</span>, <span class="hljs-string">"X"</span>, <span class="hljs-string">"IX"</span>, <span class="hljs-string">"V"</span>, <span class="hljs-string">"IV"</span>, <span class="hljs-string">"I"</span> &#125;;<br>    <span class="hljs-keyword">int</span> n = store.size();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (num &gt;= store[i])<br>        &#123;<br>            res.append(strs[i]);<br>            num -= store[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><a id="more"></a><h4 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a>13. 罗马数字转整数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">romanToInt</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; hash&#123; &#123;<span class="hljs-string">'M'</span>, <span class="hljs-number">1000</span>&#125;, &#123;<span class="hljs-string">'D'</span>, <span class="hljs-number">500</span>&#125;, &#123;<span class="hljs-string">'C'</span>, <span class="hljs-number">100</span>&#125;, &#123;<span class="hljs-string">'L'</span>, <span class="hljs-number">50</span>&#125;, &#123;<span class="hljs-string">'X'</span>, <span class="hljs-number">10</span>&#125;, &#123;<span class="hljs-string">'V'</span>, <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-string">'I'</span>, <span class="hljs-number">1</span>&#125; &#125;;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.size(); i++)<br>    &#123;<br>        <span class="hljs-comment">// s.size()为'\0',将'\0'赋给int型变量时，变量值为0；</span><br>        <span class="hljs-keyword">if</span> (hash[s[i]] &lt; hash[s[i + <span class="hljs-number">1</span>]])<br>            res -= hash[s[i]];<br>        <span class="hljs-keyword">else</span><br>            res += hash[s[i]];<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; s[s.size()];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a>55. 跳跃游戏</h4><p>在每个能到达的点检查从该点出发能到达的最远距离，最远距离超过nums.size() - 1则能到达终点</p><p>如何判断中间的某一点是否能到达？</p><p>因为是顺序遍历所有位置，每次遍历当前位置时都用maxPos检查是否能达到下一点，如果无法达到说明已经中断，此时使用break跳出循环</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;12-整数转罗马数字&quot;&gt;&lt;a href=&quot;#12-整数转罗马数字&quot; class=&quot;headerlink&quot; title=&quot;12. 整数转罗马数字&quot;&gt;&lt;/a&gt;12. 整数转罗马数字&lt;/h4&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs c++&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 处理上有优先级，对于当前的数，优先处理大于1000的部分，然后处理900，500，400.....（每一部分的处理方式也有固定的对应） --&amp;gt; 贪心算法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;intToRoman&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; num)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;br&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; res;&lt;br&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt; store&amp;#123; &lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;900&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;500&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;400&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;90&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;40&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &amp;#125;;&lt;br&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;&amp;gt; strs&amp;#123; &lt;span class=&quot;hljs-string&quot;&gt;&quot;M&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;CM&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;D&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;CD&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;C&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;XC&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;L&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;XL&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;X&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;IX&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;V&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;IV&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;I&quot;&lt;/span&gt; &amp;#125;;&lt;br&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; n = store.size();&lt;br&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; n; i++)&lt;br&gt;    &amp;#123;&lt;br&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (num &amp;gt;= store[i])&lt;br&gt;        &amp;#123;&lt;br&gt;            res.append(strs[i]);&lt;br&gt;            num -= store[i];&lt;br&gt;        &amp;#125;&lt;br&gt;    &amp;#125;&lt;br&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; res;&lt;br&gt;&amp;#125;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>递归专题</title>
    <link href="https://chasencenge.github.io/2020/09/08/%E5%9B%9E%E6%BA%AF%E4%B8%93%E9%A2%98/"/>
    <id>https://chasencenge.github.io/2020/09/08/回溯专题/</id>
    <published>2020-09-08T06:17:54.000Z</published>
    <updated>2020-11-04T14:37:37.236Z</updated>
    
    <content type="html"><![CDATA[<h3 id="回溯算法的写法："><a href="#回溯算法的写法：" class="headerlink" title="回溯算法的写法："></a>回溯算法的写法：</h3><h5 id="画出递归树，找到状态变量（回溯函数的参数）"><a href="#画出递归树，找到状态变量（回溯函数的参数）" class="headerlink" title="画出递归树，找到状态变量（回溯函数的参数）"></a>画出递归树，找到状态变量（回溯函数的参数）</h5><h5 id="根据题意确立结束条件"><a href="#根据题意确立结束条件" class="headerlink" title="根据题意确立结束条件"></a>根据题意确立结束条件</h5><h5 id="找准选择列表"><a href="#找准选择列表" class="headerlink" title="找准选择列表"></a>找准选择列表</h5><h5 id="判断是否需要剪枝（去掉重复的集合，即去掉递归树上的某些分支）"><a href="#判断是否需要剪枝（去掉重复的集合，即去掉递归树上的某些分支）" class="headerlink" title="判断是否需要剪枝（去掉重复的集合，即去掉递归树上的某些分支）"></a>判断是否需要剪枝（去掉重复的集合，即去掉递归树上的某些分支）</h5><h5 id="做出选择，递归调用，进入下一层"><a href="#做出选择，递归调用，进入下一层" class="headerlink" title="做出选择，递归调用，进入下一层"></a>做出选择，递归调用，进入下一层</h5><h5 id="撤销选择"><a href="#撤销选择" class="headerlink" title="撤销选择"></a>撤销选择</h5><h4 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a>77. 组合</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//给出n，k返回可能的组合</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; temp;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span><br></span>&#123;<br>    <span class="hljs-comment">// 如果[cur, n]中元素的个数加上temo中元素的个数少于k，无法构成需要的组合</span><br>    <span class="hljs-keyword">if</span> (temp.size() + (n - cur + <span class="hljs-number">1</span>) &lt; k)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果temp的size == k，说明找到了组合，插入res</span><br>    <span class="hljs-keyword">if</span> (temp.size() == k)<br>    &#123;<br>        res.push_back(temp);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 小于k的话继续往里添加元素</span><br>    <span class="hljs-keyword">if</span> (temp.size() &lt; k)<br>    &#123;<br>        <span class="hljs-comment">// 考虑选择当前位置</span><br>        temp.push_back(cur);<br>        dfs(cur + <span class="hljs-number">1</span>, n, k);<br>        temp.pop_back();<br>        <span class="hljs-comment">// 考虑不选择当前位置</span><br>        dfs(cur + <span class="hljs-number">1</span>, n, k);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">combine</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    dfs(<span class="hljs-number">1</span>, n, k);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 因为是数据可重复选择的情况，所以在回溯中，可选择跳过和不跳过当前数值，这样就会包括某一个值重复选择的情况，在不跳过当前值的选择中，需要确定当前数值没有超过所需值</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; temp;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; candidates, <span class="hljs-keyword">int</span> remain)</span><br></span>&#123;        <br>    <span class="hljs-keyword">if</span>(cur == n)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(remain == <span class="hljs-number">0</span>)<br>    &#123;<br>        res.push_back(temp);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 不选择当前位置，直接跳过</span><br>    dfs(cur + <span class="hljs-number">1</span>, n, candidates, remain);<br>    <span class="hljs-comment">// 选择当前数，不跳过，不跳过的话需要判断当前数是否还能选择</span><br>    <span class="hljs-keyword">if</span>(candidates[cur] &lt;= remain)<br>    &#123;<br>        temp.push_back(candidates[cur]);<br>        remain -= candidates[cur]; <br>        dfs(cur, n, candidates, remain);<br>        temp.pop_back();<br>    &#125;<br>       <br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">combinationSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; candidates, <span class="hljs-keyword">int</span> target)</span> <br></span>&#123;<br>    <span class="hljs-keyword">int</span> n = candidates.size();<br>    dfs(<span class="hljs-number">0</span>, n,candidates, target);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="401-二进制手表"><a href="#401-二进制手表" class="headerlink" title="401. 二进制手表"></a>401. 二进制手表</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;string&gt; res;<br>unordered_map&lt;int, int&gt; hashdata = &#123;&#123;0,1&#125;,&#123;1,2&#125;,&#123;2,4&#125;,&#123;3,8&#125;,&#123;4,1&#125;,&#123;5,2&#125;,&#123;6,4&#125;,&#123;7,8&#125;,&#123;8,16&#125;,&#123;9,32&#125;&#125;;<br>void backtrack(int num,int start,pair&lt;int,int&gt;&amp; time)&#123;<br>    // 结束条件<br>    if(num == 0)<br>    &#123;<br>        if(time.first &gt; 11 || time.second &gt; 59)<br>        &#123;<br>            return;<br>        &#125;<br>        string temp_hour = to_string(time.first);<br>        string temp_minute = to_string(time.second);<br>        if(temp_minute.size() == 1)<br>        &#123;<br>            temp_minute.insert(0, "0");<br>        &#125;<br>        res.push_back(temp_hour + ":" + temp_minute);<br>        return;<br>    &#125;<br>    for(int i = start; i &lt; 10; i++)<br>    &#123;<br>        if(time.first &gt; 11 || time.second &gt; 59)<br>        &#123;<br>            continue;<br>        &#125;<br>        // 在本层中创建一个变量store用来存储当前的time值，回退时使用<br>        pair&lt;int, int&gt; store = time;<br>        if(i &lt; 4)<br>        &#123;<br>            time.first += hashdata[i];<br>        &#125;<br>        else<br>        &#123;<br>            time.second += hashdata[i];<br>        <br>        &#125;<br>        backtrack(num - 1, i + 1, time);<br>        // 在同层回退时把前面存好的store再赋给time，时time恢复到原状态<br>        time = store;<br>        <br>    &#125;<br>&#125;<br><br>vector&lt;string&gt; readBinaryWatch(int num) &#123;<br>    pair&lt;int, int&gt; time(0, 0);<br>    backtrack(num, 0, time);<br>    return res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="40-组合总数2"><a href="#40-组合总数2" class="headerlink" title="40. 组合总数2"></a>40. 组合总数2</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 去重复结果组合使用pair计数，将给的数组里的相同数值的数放在一起去递归处理</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; temp;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br><span class="hljs-built_in">vector</span>&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; freq;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos, <span class="hljs-keyword">int</span> rest)</span><br></span>&#123;<br>    <span class="hljs-keyword">if</span>(rest == <span class="hljs-number">0</span>)<br>    &#123;<br>        res.push_back(temp);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pos == freq.size() || rest &lt; freq[pos].first)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br><br>    dfs(pos+<span class="hljs-number">1</span>, rest);<br><span class="hljs-comment">// most用来判断处理相同数值的数时，进行几次递归，例如有五个2，但是target是7，那么只进行对2这个数值只进行三次递归</span><br>    <span class="hljs-keyword">int</span> most = min(rest / freq[pos].first, freq[pos].second);    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>; a &lt;= most; a++)<br>    &#123;<br>        temp.push_back(freq[pos].first);<br>        dfs(pos+<span class="hljs-number">1</span>, rest - a * freq[pos].first);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> b = <span class="hljs-number">1</span>; b &lt;= most; b++)<br>    &#123;<br>        temp.pop_back();<br>    &#125;<br>  <br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">combinationSum2</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; candidates, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-comment">// vector&lt;pair&lt;int, int&gt;&gt; freq;</span><br>    sort(candidates.begin(), candidates.end());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : candidates)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(freq.empty() || num != freq.back().first)<br>        &#123;<br>            <span class="hljs-comment">// 用push_back的话需要make_pair，用emplace_back则不需要</span><br>            <span class="hljs-comment">// freq.push_back(make_pair(num, 1));</span><br>            freq.emplace_back(num, <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            ++freq.back().second;<br>        &#125;<br>    &#125;<br>    dfs(<span class="hljs-number">0</span>, target);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="216-组合总数3"><a href="#216-组合总数3" class="headerlink" title="216. 组合总数3"></a>216. 组合总数3</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; temp;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> remain, <span class="hljs-keyword">int</span> k)</span><br></span>&#123;<br>    <span class="hljs-keyword">if</span>(remain == <span class="hljs-number">0</span> &amp;&amp; temp.size() == k)<br>    &#123;<br>        res.push_back(temp);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(cur &gt; remain || temp.size() == k || cur &gt; <span class="hljs-number">9</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    temp.push_back(cur);<br>    dfs(cur+<span class="hljs-number">1</span>, remain-cur, k);<br>    temp.pop_back();<br>    dfs(cur+<span class="hljs-number">1</span>, remain, k);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">combinationSum3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    dfs(<span class="hljs-number">1</span>, n, k);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h4><p>回溯函数参数：要生成的括号对数n，存结果的vector<string> rets，单个结果的string ret，当前左括号数open，当前右括号数close</string></p><p>用<code>ret.size() == 2 * n</code>判断是否将ret添加到结果rets</p><p>用<code>open &lt; n</code>判断是否继续添加左括号</p><p>用<code>close &lt; open</code>判断当前是否能添加右括号</p><h4 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h4><p>什么情况适合使用回溯法：</p><p>通过探索所有可能的候选解来找出所有解</p><p>终止条件为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cur == len<br></code></pre></td></tr></table></figure><p>回溯体结构为：</p><p>从已构造长度开始往后，逐个与当前位置进行数据交换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = cur; i &lt; len; i++)<br>&#123;<br>swap(output[cur], output[i]);<br>    backtrack(ret, output, cur+<span class="hljs-number">1</span>, len);<br>    swap(output[cur], output[i]); <span class="hljs-comment">//回溯里一定要记得的撤销操作</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a>78. 子集</h4><p>没啥说的，最基础的回溯….</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;回溯算法的写法：&quot;&gt;&lt;a href=&quot;#回溯算法的写法：&quot; class=&quot;headerlink&quot; title=&quot;回溯算法的写法：&quot;&gt;&lt;/a&gt;回溯算法的写法：&lt;/h3&gt;&lt;h5 id=&quot;画出递归树，找到状态变量（回溯函数的参数）&quot;&gt;&lt;a href=&quot;#画出递归树，找到
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>查找专题</title>
    <link href="https://chasencenge.github.io/2020/09/03/%E6%9F%A5%E6%89%BE%E4%B8%93%E9%A2%98/"/>
    <id>https://chasencenge.github.io/2020/09/03/查找专题/</id>
    <published>2020-09-03T12:56:48.000Z</published>
    <updated>2020-10-29T05:11:30.462Z</updated>
    
    <content type="html"><![CDATA[<h4 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a>4. 寻找两个正序数组的中位数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//二分查找</span><br><span class="hljs-comment">//写一个查找第k大的函数，k值在运行过程中会慢慢减小</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthElement</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2, <span class="hljs-keyword">int</span> k)</span><br></span>&#123;<br>    <span class="hljs-keyword">int</span> m = nums1.size();<br>    <span class="hljs-keyword">int</span> n = nums2.size();<br>    <span class="hljs-keyword">int</span> index1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> index2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-comment">//nums1中的指针位置已经到了末尾，直接在num2中找剩下的第k大</span><br>        <span class="hljs-keyword">if</span> (index1 == m)<br>        &#123;<br>            <span class="hljs-keyword">return</span> nums2[index2 + k - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (index2 == n)<br>        &#123;<br>            <span class="hljs-keyword">return</span> nums1[index1 + k - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> min(nums1[index1], nums2[index2]);<br>        &#125;<br><span class="hljs-comment">//边界检测，index如果加了k / 2 - 1越界了，就直接将新的index设置为数组的最后一位</span><br>        <span class="hljs-keyword">int</span> newIndex1 = min(index1 + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>, m - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">int</span> newIndex2 = min(index2 + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">int</span> pivot1 = nums1[newIndex1];<br>        <span class="hljs-keyword">int</span> pivot2 = nums2[newIndex2];<br>        <span class="hljs-keyword">if</span> (pivot1 &lt;= pivot2)<br>        &#123;<br>            <span class="hljs-comment">//更新k和index</span><br>            k -= newIndex1 - index1 + <span class="hljs-number">1</span>;<br>            index1 = newIndex1 + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            k -= newIndex2 - index2 + <span class="hljs-number">1</span>;<br>            index2 = newIndex2 + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> totalLength = nums1.size() + nums2.size();<br>    <span class="hljs-keyword">if</span> (totalLength % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>    &#123;<span class="hljs-comment">//奇数总数和偶数总数分开讨论</span><br>        <span class="hljs-keyword">return</span> findKthElement(nums1, nums2, (totalLength + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> (findKthElement(nums1, nums2, totalLength / <span class="hljs-number">2</span>) + findKthElement(nums1, nums2, totalLength / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>)) / <span class="hljs-number">2.0</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h4><p>排序数组直接联想二分查找</p><p>对二分查找做适合题目要求的改动，有多个连续的target值，寻找左边界时要找到最左面的target下标，则需要在findLeft函数中添加判断：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(nums[mid] == target)<br>right = mid;<br></code></pre></td></tr></table></figure><p>使有边界逐渐向左逼近，以保证最后走出 <code>while(left &lt; right)</code> 循环时，left在多个相同的target中的最左面</p><p>在findRight函数中不仅需要添加判断：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(nums[mid] == target)<br>left = mid;<br></code></pre></td></tr></table></figure><p>特别注意，还需要修改mid的计算：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">mid = (left + right + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>这里如果不加1的话，当left == right-1时，计算mid永远等于left，无法退出循环</p><h4 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a>347. 前 K 个高频元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 这里的static的添加是因为sory()第三个参数是个函数指针，然而cmp函数是一个非静态成员函数，非静态成员函数指针和普通函数指针是有区别的，为防止报错在类内的成员函数定义前添加static，或者把cmp函数定义写在类外</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; a, pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; b)</span><br>    </span>&#123;<br>        <span class="hljs-keyword">return</span> a.second &gt; b.second;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; countMap;<br>        <span class="hljs-keyword">int</span> n = nums.size();<br>        <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;::iterator it;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-comment">// 判断map中某个key是否存在，使用find()，（find()返回的是迭代器）</span><br>            it = countMap.find(nums[i]);<br>            <span class="hljs-keyword">if</span>(it != countMap.end())<br>            &#123;<br>                countMap[nums[i]]++;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">// map中插入新的&lt;key, value&gt;对</span><br>                countMap.insert(pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;(nums[i], <span class="hljs-number">1</span>));<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// map没有sort()函数，因为map不是线性结构，所以为了排序，将map中的pair形式的成员放到vector中再进行排序</span><br>        <span class="hljs-built_in">vector</span>&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; vec;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;::iterator it = countMap.begin(); it != countMap.end(); it++)<br>        &#123;<br>            vec.push_back(pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;(it-&gt;first, it-&gt;second));<br>        &#125;<br>        sort(vec.begin(), vec.end(), cmp);<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-built_in">vector</span>&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt;::iterator iter = vec.begin();<br>        <span class="hljs-keyword">while</span>(k)<br>        &#123;<br>            res.push_back(iter-&gt;first);<br>            iter++;<br>            k--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id><a href="#" class="headerlink" title></a></h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;4-寻找两个正序数组的中位数&quot;&gt;&lt;a href=&quot;#4-寻找两个正序数组的中位数&quot; class=&quot;headerlink&quot; title=&quot;4. 寻找两个正序数组的中位数&quot;&gt;&lt;/a&gt;4. 寻找两个正序数组的中位数&lt;/h4&gt;&lt;figure class=&quot;highligh
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口专题</title>
    <link href="https://chasencenge.github.io/2020/09/03/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%93%E9%A2%98/"/>
    <id>https://chasencenge.github.io/2020/09/03/滑动窗口专题/</id>
    <published>2020-09-03T11:18:54.000Z</published>
    <updated>2020-10-30T08:46:17.299Z</updated>
    
    <content type="html"><![CDATA[<h4 id="3-无重复的最长字串"><a href="#3-无重复的最长字串" class="headerlink" title="3.  无重复的最长字串"></a>3.  无重复的最长字串</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//右指针</span><br>    <span class="hljs-keyword">int</span> rp = <span class="hljs-number">-1</span>;<br>    <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt; seri;<br>    <span class="hljs-comment">//i是左指针</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.size(); i++)<br>    &#123;<br>        <span class="hljs-comment">//每次循环开始的时候把上一次左指针指向的值删掉</span><br>        <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>)<br>        &#123;<br>            seri.erase(s[i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-comment">//例如abcdcefgh，到了第二个c会产生重复，rp会停在d这里，然后删掉a继续循环，发现仍不满足!seri.count(s[rp + 1])，因为c并没被删掉，所以跳过while继续循环，删掉b，知道删掉第一个c，while中才满足!seri.count(s[rp + 1])，这时才能进入while，rp继续向后走</span><br>        <span class="hljs-keyword">while</span> (rp + <span class="hljs-number">1</span> &lt; s.size() &amp;&amp; !seri.count(s[rp + <span class="hljs-number">1</span>]))<br>        &#123;<br>            seri.insert(s[rp + <span class="hljs-number">1</span>]);<br>            rp++;<br>        &#125;<br>        res = max(res, rp - i + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="76-最小覆盖字串"><a href="#76-最小覆盖字串" class="headerlink" title="76. 最小覆盖字串"></a>76. 最小覆盖字串</h4><p>用两个map分别记录所需包含的字母及其个数(ori)，以及当前窗口内所含所需字母及其个数(cnt)</p><p>每次检查时，检查ori中的每个key对应的value和cnt中对应的value，cnt中的值不能小于ori，不然意味着当前窗口未完全包含所需的所有字符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;&amp; ori, <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;&amp; cnt)</span><br></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; p : ori)<br>    &#123;<br>    <span class="hljs-keyword">if</span>(cnt[p.first] &lt; p.second)<br>        &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当check满足条件，检查是否需要更新最小窗口长度len和结果起始点ansL，并且由于check满足条件需要将窗口左侧边界右移一位，所以此时如果最左侧的字母为ori中的一员，cnt对应的key的value减一</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(check(ori, cnt) &amp;&amp; l &lt;= r)<br>&#123;<br><span class="hljs-keyword">if</span>(r - l &lt; minLength)<br>&#123;<br>minLength = r - l;<br>ansL = l;<br>&#125;<br>    <span class="hljs-keyword">if</span>(ori.find(s[l]) != ori.end())<br>    &#123;<br>    --cnt[s[l]];<br>    &#125;<br>l++;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;3-无重复的最长字串&quot;&gt;&lt;a href=&quot;#3-无重复的最长字串&quot; class=&quot;headerlink&quot; title=&quot;3.  无重复的最长字串&quot;&gt;&lt;/a&gt;3.  无重复的最长字串&lt;/h4&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://chasencenge.github.io/2020/08/24/%E5%89%91%E6%8C%87offer/"/>
    <id>https://chasencenge.github.io/2020/08/24/剑指offer/</id>
    <published>2020-08-24T06:51:21.000Z</published>
    <updated>2020-12-28T08:57:02.935Z</updated>
    
    <content type="html"><![CDATA[<h4 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29. 顺时针打印矩阵"></a>29. 顺时针打印矩阵</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">处理移动四个移动方向用：<br>vector&lt;vector&lt;int&gt;&gt; move&#123; &#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125; &#125;;<br>或者：<br>static constexpr int directions[4][2] = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;<br>标记矩阵的已访问元素和未访问元素用一个相同大小的bool矩阵visit<br>输入一个空matrix时，如果对其求matrix[0].size()会报错，因为没有matrix[0]<br></code></pre></td></tr></table></figure><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; order;<br><br>    <span class="hljs-keyword">if</span> (matrix.size() == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].size() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> rowRange = matrix.size();<br>    <span class="hljs-keyword">int</span> colRange = matrix[<span class="hljs-number">0</span>].size();<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-title">visit</span><span class="hljs-params">(rowRange, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(colRange))</span></span>;<br>    <span class="hljs-keyword">int</span> total = rowRange * colRange;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; move&#123; &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125; &#125;;<br>    <span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> moveIndex = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> nextRow, nextCol;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; total; i++)<br>    &#123;<br>        order.push_back(matrix[row][col]);<br>        visit[row][col] = <span class="hljs-literal">true</span>;<br>        nextRow = row + move[moveIndex][<span class="hljs-number">0</span>];<br>        nextCol = col + move[moveIndex][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (nextRow &gt;= rowRange || nextRow &lt; <span class="hljs-number">0</span> || nextCol &gt;= colRange || nextCol &lt; <span class="hljs-number">0</span> || visit[nextRow][nextCol])<br>        &#123;<br>            moveIndex = (moveIndex + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;<br>        &#125;<br>        row += move[moveIndex][<span class="hljs-number">0</span>];<br>        col += move[moveIndex][<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> order;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;29-顺时针打印矩阵&quot;&gt;&lt;a href=&quot;#29-顺时针打印矩阵&quot; class=&quot;headerlink&quot; title=&quot;29. 顺时针打印矩阵&quot;&gt;&lt;/a&gt;29. 顺时针打印矩阵&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs undefined&quot;&gt;处理移动四个移动方向用：&lt;br&gt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; move&amp;#123; &amp;#123;0, 1&amp;#125;, &amp;#123;1, 0&amp;#125;, &amp;#123;0, -1&amp;#125;, &amp;#123;-1, 0&amp;#125; &amp;#125;;&lt;br&gt;或者：&lt;br&gt;static constexpr int directions[4][2] = &amp;#123;&amp;#123;0, 1&amp;#125;, &amp;#123;1, 0&amp;#125;, &amp;#123;0, -1&amp;#125;, &amp;#123;-1, 0&amp;#125;&amp;#125;;&lt;br&gt;标记矩阵的已访问元素和未访问元素用一个相同大小的bool矩阵visit&lt;br&gt;输入一个空matrix时，如果对其求matrix[0].size()会报错，因为没有matrix[0]&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>dp专题</title>
    <link href="https://chasencenge.github.io/2020/08/18/dp%E4%B8%93%E9%A2%98/"/>
    <id>https://chasencenge.github.io/2020/08/18/dp专题/</id>
    <published>2020-08-18T07:54:15.000Z</published>
    <updated>2020-12-28T08:56:50.806Z</updated>
    
    <content type="html"><![CDATA[<h4 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5.最长回文子串"></a>5.最长回文子串</h4><p>单独处理长度为1和2的字符串</p><p>状态转移：字串加上相同的首尾</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">dp[i][j] = (s[i] == s[j] &amp;&amp; dp[i+1][j-1]);<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>    <span class="hljs-built_in">string</span> ans;<br>    <span class="hljs-keyword">int</span> n = s.size();<br>    <span class="hljs-comment">//初始化二维vector，初始值为0</span><br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n))</span></span>;<br>    <span class="hljs-comment">//外层循环用的是字串的长度，dp矩阵对角线（i==j）代表字串长度为1，对角线两侧的斜线代表字串长度为2，依次往外扩展更新</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>; len &lt; n; len++)<br>    &#123;c<br>        <span class="hljs-comment">//对于dbabcad，首轮更新d, b, a, b, c, a, d对应的dp; 第二轮更新db, ba, ab, bc, ca, ad对应的dp; 然后是dba, bab, abc......（它根据首轮的更新的dp做s[i] == s[j] &amp;&amp; dp[i + 1][j - 1]判断）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - len; i++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> j = i + len;<br>            <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>)<br>            &#123;<br>                dp[i][j] = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>)<br>            &#123;<br>                dp[i][j] = s[i] == s[j];<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                dp[i][j] = (s[i] == s[j] &amp;&amp; dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);<br>            &#125;<br>            <span class="hljs-comment">//如果找到了更长的字串，更新新的字串</span><br>            <span class="hljs-keyword">if</span> (dp[i][j] &amp;&amp; len + <span class="hljs-number">1</span> &gt; ans.size())<br>            &#123;<br>                <span class="hljs-comment">//substr(i, j): 从下标i开始截取j位</span><br>                ans = s.substr(i, len + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a>53. 最大子序和</h4><p>状态转移：nums[i]为当前遍历到的数，比较在已有数组上加上当前数值（数组里加当前数值）和当前数值的大小（开一个新数组）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">max(f[i-1]+nums[i], nums[i])<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; f;<br>        <span class="hljs-keyword">if</span>(nums.empty())<br>        &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>        f.push_back(nums[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.size(); i++)<br>        &#123;<br>            f.push_back(max(f[i<span class="hljs-number">-1</span>]+nums[i], nums[i]));<br>        &#125;<br>        <span class="hljs-keyword">int</span> compare = f[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:f)<br>        &#123;<br>            compare = max(x, compare);<br>        &#125;<br>        <span class="hljs-keyword">return</span> compare;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="超级码力复赛-3-秋叶收藏集"><a href="#超级码力复赛-3-秋叶收藏集" class="headerlink" title="超级码力复赛 3.秋叶收藏集"></a>超级码力复赛 3.秋叶收藏集</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">要将叶子调整为“红黄红”排列，r为红，y为黄，每次可将r调整为y，也可将y调整为r，求调整所需最小次数<br><br>示例：<br>输入：leaves = &quot;rrryyyrryyyrr&quot;<br>输出：2<br>解释：调整两次，将中间的两片红叶替换成黄叶，得到 &quot;rrryyyyyyyyrr&quot;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minimumOperations</span><span class="hljs-params">(<span class="hljs-built_in">string</span> leaves)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = leaves.size();<br>    <span class="hljs-comment">//cout &lt;&lt; "n" &lt;&lt;n &lt;&lt; endl;</span><br>    <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> end = leaves.size() - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n - <span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n - <span class="hljs-number">2</span>, <span class="hljs-number">100000</span>))</span></span>;<br>    <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (leaves[<span class="hljs-number">0</span>] == <span class="hljs-string">'y'</span>)<br>    &#123;<br>        temp++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (leaves[<span class="hljs-number">1</span>] == <span class="hljs-string">'r'</span>)<br>    &#123;<br>        temp++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (leaves[i] == <span class="hljs-string">'y'</span>)<br>        &#123;<br>            temp++;<br>        &#125;<br>    &#125;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = temp;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> y = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span> (x != n - <span class="hljs-number">3</span>)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (y != n - <span class="hljs-number">2</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (leaves[y] == <span class="hljs-string">'y'</span>)<br>                dp[x][y] = dp[x][y - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                dp[x][y] = dp[x][y - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            y++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (x + <span class="hljs-number">2</span> == n - <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//cout &lt;&lt; "test" &lt;&lt; endl;</span><br>        <span class="hljs-keyword">if</span> (leaves[x+<span class="hljs-number">1</span>] == <span class="hljs-string">'y'</span>)<br>            dp[x + <span class="hljs-number">1</span>][x + <span class="hljs-number">2</span>] = dp[x][x + <span class="hljs-number">2</span>] + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            dp[x + <span class="hljs-number">1</span>][x + <span class="hljs-number">2</span>] = dp[x][x + <span class="hljs-number">2</span>] - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//cout &lt;&lt; "test2" &lt;&lt; endl;</span><br>        x++;<br>        y = x + <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//cout &lt;&lt; "x y " &lt;&lt; x &lt;&lt; y &lt;&lt; endl;</span><br>        <span class="hljs-comment">/*for (int a = 0; a &lt; dp.size(); a++)<br>        &#123;<br>            for (int b = 0; b &lt; dp[0].size(); b++)<br>            &#123;<br>                cout &lt;&lt; dp[a][b] &lt;&lt; " ";<br>            &#125;<br>            cout &lt;&lt; endl;<br>        &#125;*/</span><br>    &#125;<br>    <span class="hljs-keyword">int</span> res = dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>; a &lt; dp.size(); a++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>; b &lt; dp[<span class="hljs-number">0</span>].size(); b++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (dp[a][b] &lt; res)<br>            &#123;<br>                res = dp[a][b];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// cout &lt;&lt; res;</span><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a>32. 最长有效括号</h4><p>寻找转移方程：</p><p>每个dp元素代表以该位置为结尾的最长有效括号数，也就是说当以’)’为结尾才可能不为0</p><p>当发现s[i]位置以’)’结尾，检查s[i-1]</p><p>如果<code>s[i-1] == &#39;(&#39;</code>，<code>dp[i] = dp[i-2] + 2</code></p><p>如果<code>s[i-1] == &#39;)&#39;</code>并且 <code>s[i - dp[i-1] - 1] == &#39;(&#39;</code> ，<code>dp[i] = dp[i-1] + dp[i - dp[i-1] - 2] + 2</code> </p><p>对第二种情况举例：( <strong>)</strong> ( ( ) ( <strong>)</strong> )，检测到最后一位为’)’并且倒数第二位也为’)’，这时dp[6] = 4, dp[7] = dp[6]（dp[i-1]） + dp[1]（dp[7 - dp[6] -2]） + 2 = 4 + 2 + 2，分别代表第四个到第七个括号组成的dp[i-1]、第一个和第二个括号组成的dp[i - dp[i-1] - 1]，（加上这个是因为除去dp[i-1]和第三个和第八个配对的括号以外，第一个和第二个括号也因为原本没有配对的第三个括号成功配对而连接起来）、第三个和第八个括号组成的新配对的括号组</p><h4 id="47-礼物的最大价值"><a href="#47-礼物的最大价值" class="headerlink" title="47. 礼物的最大价值"></a>47. 礼物的最大价值</h4><p>构造“矩阵最优路径的寻径问题”的dp矩阵，dp矩阵每个元素的含义是到当前点的最大收益</p><p>转移方程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j];<br></code></pre></td></tr></table></figure><p>这样的话就需要填充边界：使dp矩阵的维度加一，填充0</p><p>本题的优化：可将dp矩阵维度降为一维，在每一个外层循环中覆盖更新dp</p><h4 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a>62. 不同路径</h4><p>转移方程:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">dp[i][j] = dp[i<span class="hljs-number">-1</span>][j]+dp[i][j<span class="hljs-number">-1</span>];<br></code></pre></td></tr></table></figure><p><strong>动态规划中要下意识地思考是否能够降低空间复杂度</strong></p><p>本题中每一行的计算都只需要当前行和上一行的信息，所以将空间复杂度O(n^2^)降至O(2n):</p><p>只构造两个一维数组pre和cur，分别保存上一行和当前行的值</p><p>每次修改完当前行的值以后，将当前行cur复制给pre</p><p>进一步优化空间复杂度至O(n):</p><p>只构造一个一维数组cur，对应上面的转移方程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cur[j] += cur[j<span class="hljs-number">-1</span>];<br></code></pre></td></tr></table></figure><p>因为在更新cur[j]时，更新前的cur[j]即为上一行的j列值，只需在此之上加上cur[j-1]即可</p><h4 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a>64. 最小路径和</h4><p>转移方程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span> || j == <span class="hljs-number">1</span>)<br>&#123;<br>dp[i][j] = i == <span class="hljs-number">1</span> ? dp[i][j<span class="hljs-number">-1</span>] + grid[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] : dp[i<span class="hljs-number">-1</span>][j] + grid[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>dp[i][j] = min(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]) + grid[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>为了防止下标左溢出，dp矩阵是(m+1) * (n+1)的，第一行和第一列填充0</p><p>第一行和第一列做单独处理，因为当前点的值应为左侧和上侧的较小值加上当前点的值，而第一行的点的值只能为左侧的值加上当前点的值，第一列的点的值只能为上侧的点的值加上当前点的值</p><h5 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h5><p>转移方程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++)<br>&#123;<br>dp[i] = dp[i<span class="hljs-number">-2</span>] + dp[i<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>防止左溢出，提前设定dp[1]和dp[2]，并设置n=1和n=2时的返回值</p><h4 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a>72. 编辑距离</h4><p>问题本质等同于有三种操作：</p><p>在单词 <code>A</code> 中插入一个字符，如果horse到ro的编辑距离为a，那么到ros的编辑距离不会超过a+1</p><p>在单词 <code>B</code> 中插入一个字符，如果hors到ros的编辑距离为b，那么horse到ros的编辑距离不会超过b+1</p><p>修改单词 <code>A</code> 的一个字符，如果hors到ro的编辑距离为c，那么horse到ros的编辑距离不会超过c+1</p><p>因此产生状态转移方程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> label = word1[i<span class="hljs-number">-1</span>] == word2[j<span class="hljs-number">-1</span>] ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>; <span class="hljs-comment">//先判断A和B最后一个字母是否相同</span><br>dp[i][j] = min(min(dp[i<span class="hljs-number">-1</span>][j] + <span class="hljs-number">1</span>, dp[i][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>), dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + label);<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;5-最长回文子串&quot;&gt;&lt;a href=&quot;#5-最长回文子串&quot; class=&quot;headerlink&quot; title=&quot;5.最长回文子串&quot;&gt;&lt;/a&gt;5.最长回文子串&lt;/h4&gt;&lt;p&gt;单独处理长度为1和2的字符串&lt;/p&gt;
&lt;p&gt;状态转移：字串加上相同的首尾&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode top100刷题</title>
    <link href="https://chasencenge.github.io/2020/08/03/LeetCode-top&amp;hot%E5%88%B7%E9%A2%98/"/>
    <id>https://chasencenge.github.io/2020/08/03/LeetCode-top&amp;hot刷题/</id>
    <published>2020-08-03T15:15:27.000Z</published>
    <updated>2020-12-28T08:54:52.036Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span><br></span>&#123;<br>    <span class="hljs-comment">/*map*/</span> <br>    umordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; hashtable;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++)<br>    &#123;<br>        <span class="hljs-keyword">auto</span> it = hashtable.find(target - nums[i]);<br>        <span class="hljs-keyword">if</span>(it != hashtable.end())<br>            <span class="hljs-keyword">return</span> &#123;it-&gt;second, i&#125;;<br>        hashtable[nums[i]] = i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*先排序，再利用双指针遍历，初始i放首部，j放尾部，两数之和大于target的话j--，小于target的话i++，找到对应的i和j*/</span><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; resV&#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; copyV = nums;<br>    <span class="hljs-keyword">int</span> find;<br>    <span class="hljs-keyword">int</span> hasFound = <span class="hljs-number">0</span>;<br>    sort(nums.begin(), nums.end());<br>    <span class="hljs-comment">/* for(int k = 0; k &lt; nums.size(); k++)*/</span><br>    <span class="hljs-comment">/* &#123;cout &lt;&lt; nums[k] &lt;&lt; " ";&#125;*/</span><br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> j = nums.size() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i != j &amp;&amp; hasFound == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (target &gt; nums[i] + nums[j])<br>        &#123;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &lt; nums[i] + nums[j])<br>        &#123;<br>            j--;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">/*找到i和j还没结束，要根据nums[i], nums[j]找到排序前的数组中对应的原始下标<br>            found1防止数组中有相同的值k使得k + k = target导致只能（进入下面的if）更新resV[0]的值<br>            这样，如果在原数组中找到第一个k值时进入if，之后继续找到第二个k值的时候便不会再进入if重复更新resV[0]而导致resV[j]不被更新*/</span><br>            <span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>, found1 = <span class="hljs-number">0</span>, label = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (label != <span class="hljs-number">2</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (copyV[flag] == nums[i] &amp;&amp; found1 == <span class="hljs-number">0</span>)<br>                &#123;<br>                    label++;<br>                    resV[<span class="hljs-number">0</span>] = flag;<br>                    found1 = <span class="hljs-number">1</span>;<br>                    flag++;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (copyV[flag] == nums[j])<br>                &#123;<br>                    label++;<br>                    resV[<span class="hljs-number">1</span>] = flag;<br>                    flag++;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    flag++;<br>                &#125;<br>            &#125;<br>            hasFound = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> resV;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> <br></span>&#123;<br>    ListNode *head = <span class="hljs-literal">nullptr</span>, *tail = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (l1 || l2) &#123;<br>        <span class="hljs-keyword">int</span> n1 = l1 ? l1-&gt;val: <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> n2 = l2 ? l2-&gt;val: <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> sum = n1 + n2 + carry;<br>        <span class="hljs-keyword">if</span> (!head) &#123;<br>            head = tail = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tail-&gt;next = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>);<br>            tail = tail-&gt;next;<br>        &#125;<br>        carry = sum / <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">if</span> (l1) &#123;<br>            l1 = l1-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l2) &#123;<br>            l2 = l2-&gt;next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (carry &gt; <span class="hljs-number">0</span>) &#123;<br>        tail-&gt;next = <span class="hljs-keyword">new</span> ListNode(carry);<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-无重复字符的最长字串"><a href="#3-无重复字符的最长字串" class="headerlink" title="3. 无重复字符的最长字串"></a>3. 无重复字符的最长字串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span><br></span>&#123;<br>    <span class="hljs-comment">/* 滑动窗口 + set */</span><br><span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt; st;<br>    <span class="hljs-keyword">int</span> n = s.size();<br>    <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>, ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>; left &lt; n; left++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(left != <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">/* 每一轮循环首先舍弃窗口左端 */</span><br>            st.erase(s[left - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(right &lt; n &amp;&amp; !st.count(s[right]))<br>        &#123;<br>            st.insert(s[right]);<br>            right++;<br>        &#125;<br>        <span class="hljs-comment">/* 这里right - left 不用再加一，因为right从0而不是从-1开始，理解right的意义 */</span><br>        ret = max(ret, right - left);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 排序然后双指针 */</span><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">threeSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span><br></span>&#123;<br>    sort(nums.begin(), nums.end());<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; ret;<br>    <span class="hljs-keyword">int</span> n = nums.size();<br>    <span class="hljs-keyword">if</span>(n &gt;= <span class="hljs-number">3</span> &amp;&amp; nums[n - <span class="hljs-number">1</span>] + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">3</span>] &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">/* 剪枝 */</span><br>        <span class="hljs-keyword">return</span> ret;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> first = <span class="hljs-number">0</span>; first &lt; n - <span class="hljs-number">2</span>; first++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(nums[first] + nums[first + <span class="hljs-number">1</span>] + nums[first + <span class="hljs-number">2</span>] &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">/* 剪枝 */</span><br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span>(first &gt; <span class="hljs-number">0</span> &amp;&amp; nums[first] == nums[first - <span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">int</span> target = -nums[first];<br>        <span class="hljs-keyword">int</span> third = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> second = first + <span class="hljs-number">1</span>; second &lt; n - <span class="hljs-number">1</span>; second++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(second &gt; first + <span class="hljs-number">1</span> &amp;&amp; nums[second] == nums[second - <span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">while</span>(second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target)<br>                --third;<br>            <span class="hljs-keyword">if</span>(second == third)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span>(nums[second] + nums[third] == target)<br>                ret.push_back(&#123;nums[first], nums[second], nums[third]&#125;);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="84-柱状图中的最大矩形"><a href="#84-柱状图中的最大矩形" class="headerlink" title="84. 柱状图中的最大矩形"></a>84. 柱状图中的最大矩形</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++">int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;<br>    int ret = 0;<br>    int n = heights.size();<br>    vector&lt;int&gt; left(n), right(n, n);<br>    stack&lt;int&gt; monoStack;<br><br>    for(int i = 0; i &lt; n; i++)<br>    &#123;<br>        while(!monoStack.empty() &amp;&amp; heights[monoStack.top()] &gt;= heights[i])<br>        &#123;<br>            right[monoStack.top()] = i; /* 终于遇到比stack中的top对应的柱低的柱了（之前可能是连续的比它高，所以无法确定矩形的宽，遇到比它低的时，就可以确定以它为高的矩形的右边界了）*/<br>            monoStack.pop();<br>        &#125;<br>        left[i] = monoStack.empty() ? -1 : monoStack.top(); /* 检索到某下标时就可以确定以它为高的矩形的左边界 */<br>        monoStack.push(i);<br>    &#125;<br>    for(int i = 0; i &lt; n; i++)<br>    &#123;<br>        ret = max(ret, (right[i] - left[i] -1) * heights[i]);<br>    &#125;<br>    return ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="85-最大矩形"><a href="#85-最大矩形" class="headerlink" title="85. 最大矩形"></a>85. 最大矩形</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++">int largestRectangleArea(vector&lt;int&gt;&amp; heights)<br>&#123;<br>    int ret = 0;<br>    int n = heights.size();<br>    vector&lt;int&gt; left(n), right(n, n);<br>    stack&lt;int&gt; monoStack;<br>    for(int i = 0; i &lt; n; i++)<br>    &#123;<br>        while(!monoStack.empty() &amp;&amp; heights[monoStack.top()] &gt;= heights[i])<br>        &#123;<br>            right[monoStack.top()] = i;<br>            monoStack.pop();<br>        &#125;<br>        left[i] = monoStack.empty() ? -1 : monoStack.top();<br>        monoStack.push(i);<br>    &#125;<br>    for(int i = 0; i &lt; n; i++)<br>    &#123;<br>        ret = max(ret, (right[i] - left[i] - 1) * heights[i]);<br>    &#125;<br>    return ret;<br>&#125;<br><br>int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;<br>    int ret = 0;<br>    int m = matrix.size();<br>    if(m == 0) /*要写在n的定义之前，因为matrix[0]不一定存在*/<br>        return 0;<br>    int n = matrix[0].size();<br>    vector&lt;int&gt; dp (n, 0);<br>    for(int i = 0; i &lt; m; i++)<br>    &#123;<br>        for(int j = 0; j &lt; n; j++)<br>        &#123;<br>            dp[j] = matrix[i][j] == '0' ? 0 : dp[j] + 1; /* 这个叠加是根据上一行的dp进行的，比如上方是2，下一行如果为‘1’，相应的柱状图加1的长度变为3（即在原dp数组基础上进行修改）*/<br>        &#125;<br>        ret = max(ret, largestRectangleArea(dp));<br>    &#125;<br>    return ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="114-二叉树（原地）展开为链表（顺着右子节点连）"><a href="#114-二叉树（原地）展开为链表（顺着右子节点连）" class="headerlink" title="114. 二叉树（原地）展开为链表（顺着右子节点连）"></a>114. 二叉树（原地）展开为链表（顺着右子节点连）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 还可以用前序遍历存到数组，再改节点结构；或者（只能用迭代法）同时存到数组并改节点结构，以上两种方法空间复杂度O(n)，下面是第三种方法不用前序遍历，直接改结构，空间复杂度为O(1) */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode* root)</span><br></span>&#123;<br>    TreeNode* cur = root;<br>    <span class="hljs-keyword">while</span>(cur)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(cur-&gt;left)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> next = cur-&gt;left;<br>            <span class="hljs-keyword">auto</span> predecessor = next;<br>            <span class="hljs-keyword">while</span>(predecessor-&gt;right)<br>                predecessor = predecessor-&gt;right;<br>            <span class="hljs-comment">/* predecessor为当前节点的左子树的最右节点，连到当前节点cur的右子节点 */</span><br>            predecessor-&gt;right = cur-&gt;right;<br>            <span class="hljs-comment">/* 更新当前节点的左右子节点 */</span><br>            cur-&gt;left = <span class="hljs-literal">nullptr</span>;<br>            cur-&gt;right = next;<br>&#125;<br>        cur = cur-&gt;right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a>124. 二叉树中的最大路径和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxGain</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span>&amp; maxSum)</span><br></span>&#123;<br>    <span class="hljs-keyword">if</span>(root)<br>        <span class="hljs-comment">/* 空节点的最大贡献值等于0 */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> left = max(maxGain(root-&gt;left), <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">int</span> right = max(maxGain(root-&gt;right), <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">/* 当前子树中的最大路径和为当前节点值加上两个子节点的最大贡献值 */</span><br>    <span class="hljs-keyword">int</span> curMaxSum = root-&gt;val + left + right;<br>    maxSum = max(maxSum, curMaxSum);<br>    <span class="hljs-comment">/* 非空节点的最大贡献值等于节点值与其子节点中的最大贡献值之和 */</span><br>    <span class="hljs-keyword">return</span> root-&gt;val + max(left, right);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span><br></span>&#123;<br>    <span class="hljs-keyword">int</span> maxSum = INT_MIN;<br>    maxGain(root, maxSum);<br>    <span class="hljs-keyword">return</span> maxSum;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="128-（无序数组中能找出的）最长连续序列（需要O-n-时间复杂度）"><a href="#128-（无序数组中能找出的）最长连续序列（需要O-n-时间复杂度）" class="headerlink" title="128. （无序数组中能找出的）最长连续序列（需要O(n)时间复杂度）"></a>128. （无序数组中能找出的）最长连续序列（需要O(n)时间复杂度）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span><br></span>&#123;<br>    <span class="hljs-comment">/* 怎么也该想到用哈希表存来减少时间复杂度 */</span><br>    <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">int</span>&gt; st;<br>    <span class="hljs-keyword">int</span> longestSeq = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)<br>        st.insert(num);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> s : st)<br>    &#123;<br>        <span class="hljs-comment">/* 灵魂的一步剪枝，怎么确定是否检查从某一个数字开始的序列？看set中是否存在num-1，如果存在，则跳过，以此避免查询序列中间的数字 */</span><br>        <span class="hljs-keyword">if</span>(!st.count(s - <span class="hljs-number">1</span>))<br>        &#123;<br>            <span class="hljs-keyword">int</span> curSeq = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">int</span> curNum = s;<br>            <span class="hljs-keyword">while</span>(st.count(curNum + <span class="hljs-number">1</span>))<br>            &#123;<br>                curSeq++;<br>                curNum++;<br>            &#125;<br>            longestSeq = max(longestSeq, curSeq);<br>        &#125;<br>&#125;<br>    <span class="hljs-keyword">return</span> longestSeq;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="139-单词（是否可以）拆分（成字符串数组中的元素）-4min"><a href="#139-单词（是否可以）拆分（成字符串数组中的元素）-4min" class="headerlink" title="139. 单词（是否可以）拆分（成字符串数组中的元素）  4min"></a>139. 单词（是否可以）拆分（成字符串数组中的元素）  4min</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; wordDict)</span><br></span>&#123;<br>    <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt; st;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">string</span> word : wordDict)<br>        st.insert(word);<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(s.size() + <span class="hljs-number">1</span>)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">/* 这里的i可以理解为字符串s的前i个字符 */</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= s.size();i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)<br>            <span class="hljs-comment">/* 字符串的匹配使用的是s的子串和集合中存的string元素比较 */</span><br>            <span class="hljs-keyword">if</span>(dp[j] &amp;&amp; st.find(s.substr(j, i - j)) != st.end())<br>            &#123;<br>                dp[i] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[s.size()];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a>160. 相交链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 你走过我走的路，我走过你走的路，我们殊途同归 */</span><br><span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!headA || !headB) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    ListNode *p, *q, *pp, *qq;<br>    p = headA; q = headB;<br>    <span class="hljs-keyword">while</span>(p != q)<br>    &#123;<br>        pp = p; qq = q;<br>        p = (!p -&gt; next &amp;&amp; qq -&gt; next) ? headB : p -&gt; next;<br>        <span class="hljs-comment">/* 用pp的作用体现出来了，经过上面的步骤，p可能已经变为p-&gt;next*/</span><br>        q = (!q -&gt; next &amp;&amp; pp -&gt; next) ? headA : q -&gt; next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="739-每日温度（每天找下一个比今天更高的温度）"><a href="#739-每日温度（每天找下一个比今天更高的温度）" class="headerlink" title="739. 每日温度（每天找下一个比今天更高的温度）"></a>739. 每日温度（每天找下一个比今天更高的温度）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 又是单调栈，相关题目还有84，85 */</span><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dailyTemperature</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; T)</span><br></span>&#123;<br>    <span class="hljs-keyword">int</span> n = T.size();<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ret</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; stk;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(!stk.empty() &amp;&amp; T[i] &gt; T[stk.top()])<br>        &#123;<br>            <span class="hljs-keyword">int</span> prevIndex = stk.top();<br>            ret[prevIndex] = i - prevIndex;<br>            stk.pop();<br>        &#125;<br>        stk.push(i);<br>    &#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-两数之和&quot;&gt;&lt;a href=&quot;#1-两数之和&quot; class=&quot;headerlink&quot; title=&quot;1. 两数之和&quot;&gt;&lt;/a&gt;1. 两数之和&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode200周赛</title>
    <link href="https://chasencenge.github.io/2020/08/02/LeetCode%E5%91%A8%E8%B5%9B/"/>
    <id>https://chasencenge.github.io/2020/08/02/LeetCode周赛/</id>
    <published>2020-08-02T14:18:15.000Z</published>
    <updated>2020-10-26T09:20:11.864Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个整数数组 arr ，以及 a、b 、c 三个整数。请你统计其中好三元组的数量</p><p>如果三元组 (arr[i], arr[j], arr[k]) 满足下列全部条件，则认为它是一个 好三元组 </p><p>0 &lt;= i &lt; j &lt; k &lt; arr.length</p><p>|arr[i] - arr[j]| &lt;= a</p><p>|arr[j] - arr[k]| &lt;= b</p><p>|arr[i] - arr[k]| &lt;= c</p><p>其中 |x| 表示 x 的绝对值</p><p>返回 好三元组的数量 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">输入：arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3<br>输出：4<br>解释：一共有 4 个好三元组：[(3,0,1), (3,0,1), (3,1,1), (0,1,1)]<br><br>输入：arr = [1,1,2,2,3], a = 0, b = 0, c = 1<br>输出：0<br>解释：不存在满足所有条件的三元组<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countGoodTriplets</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br><span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.size() - <span class="hljs-number">2</span>; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.size() - <span class="hljs-number">1</span>; j++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = j + <span class="hljs-number">1</span>; k &lt; arr.size(); k++)<br>&#123;<br>                <span class="hljs-comment">//使用abs()需引用cmath头文件</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(arr[i] - arr[j]) &lt;= a &amp;&amp; <span class="hljs-built_in">abs</span>(arr[j] - arr[k]) &lt;= b &amp;&amp; <span class="hljs-built_in">abs</span>(arr[i] - arr[k]) &lt;= c)<br>&#123;<br>res++;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>给你一个由 不同 整数组成的整数数组 arr 和一个整数 k </p><p>每回合游戏都在数组的前两个元素（即 arr[0] 和 arr[1] ）之间进行。比较 arr[0] 与 arr[1] 的大小，较大的整数将会取得这一回合的胜利并保留在位置 0 ，较小的整数移至数组的末尾。当一个整数赢得 k 个连续回合时，游戏结束，该整数就是比赛的 赢家 </p><p>返回赢得比赛的整数</p><p>题目数据 保证 游戏存在赢家</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入：arr = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>], k = <span class="hljs-number">10</span><br>输出：<span class="hljs-number">3</span><br>解释：<span class="hljs-number">3</span> 将会在前 <span class="hljs-number">10</span> 个回合中连续获胜<br>    <br>输入：arr = [<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], k = <span class="hljs-number">7</span><br>输出：<span class="hljs-number">9</span><br>    <br>输入：arr = [<span class="hljs-number">1</span>,<span class="hljs-number">11</span>,<span class="hljs-number">22</span>,<span class="hljs-number">33</span>,<span class="hljs-number">44</span>,<span class="hljs-number">55</span>,<span class="hljs-number">66</span>,<span class="hljs-number">77</span>,<span class="hljs-number">88</span>,<span class="hljs-number">99</span>], k = <span class="hljs-number">1000000000</span><br>输出：<span class="hljs-number">99</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//vector操作</span><br>a.erase(a.begin()+<span class="hljs-number">1</span>,a.begin()+<span class="hljs-number">3</span>); <span class="hljs-comment">//包前不包后，删除第1、2个元素</span><br>a.insert(a.begin()+<span class="hljs-number">1</span>,<span class="hljs-number">5</span>); <span class="hljs-comment">//在a的第1个元素（从第0个算起）的位置插入数值5</span><br>a.insert(a.begin()+<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>); <span class="hljs-comment">//在a的第1个元素（从第0个算起）的位置插入3个数，其值都为5</span><br>a.back(); <span class="hljs-comment">//返回a的最后一个元素</span><br>a.front(); <span class="hljs-comment">//返回a的第一个元素</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//按命题逻辑操作vector，遇到超长数组同时超大K值时会超时</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getWinner</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> res = arr[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">if</span> (k &gt; arr.size())<br>&#123;<br>k = arr.size();<br>&#125;<br><br><span class="hljs-keyword">while</span> (num &lt; k)<br>&#123;<br><span class="hljs-keyword">if</span> (arr[<span class="hljs-number">0</span>] &gt; arr[<span class="hljs-number">1</span>])<br>&#123;<br>num++;<br><span class="hljs-keyword">int</span> temp = arr[<span class="hljs-number">1</span>];<br>arr.erase(arr.begin() + <span class="hljs-number">1</span>, arr.begin() + <span class="hljs-number">2</span>);<br>arr.push_back(temp);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>num = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> temp = arr[<span class="hljs-number">0</span>];<br>res = arr[<span class="hljs-number">1</span>];<br>arr.erase(arr.begin(), arr.begin() + <span class="hljs-number">1</span>);<br>arr.push_back(temp);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//trick，不用按题述方式操作vector，从前向后遍历即可</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getWinner</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> res = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">if</span> (k &gt; arr.size())<br>    &#123;<br>    k = arr.size();<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.size(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(arr[i]&gt;arr[i+<span class="hljs-number">1</span>])<br>            &#123;<br>                <span class="hljs-comment">//直接修改arr[i+1]的值为arr[i]，这样继续和后面比较时仍是类似命题中的：上一组的较大者和新数值比较</span><br>                arr[i+<span class="hljs-number">1</span>] = arr[i];<br>                num++;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">//当遇到前者小于后者的情况，看此时的num值是否满足大于等于k的要求，符合即作为结果返回</span><br>                <span class="hljs-keyword">if</span>(num &gt;= k)<br>                &#123;<br>                    <span class="hljs-keyword">return</span> arr[i];<br>                &#125;<br>                <span class="hljs-comment">//不符合则设置num为1，不设置为0的原因是因为已经淘汰掉上一个值，已经赢了一回合</span><br>                res = arr[i+<span class="hljs-number">1</span>];<br>                num = <span class="hljs-number">1</span>; <br>            &#125;<br>        &#125;<br>    <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><p>给你一个 n x n 的二进制网格 grid，每一次操作中，你可以选择网格的 相邻两行 进行交换</p><p>一个符合要求的网格需要满足主对角线以上的格子全部都是 0 </p><p>请你返回使网格满足要求的最少操作次数，如果无法使网格符合要求，请你返回 -1 </p><p>主对角线指的是从 (1, 1) 到 (n, n) 的这些格子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">输入：grid = [[0,0,1],[1,1,0],[1,0,0]]<br>输出：3<br><br>输入：grid = [[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,1,1,0]]<br>输出：-1<br>解释：所有行都是一样的，交换相邻行无法使网格符合要求<br><br>输入：grid = [[1,0,0],[1,1,0],[1,1,1]]<br>输出：0<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//贪心</span><br><span class="hljs-comment">//从第一行开始，如果该行的后缀0满足条件，那么直接跳过进入下一行（因为需要的后缀0个数是从大到小的顺序（理解这一点非常重要），所以不必担心前面的会抢后面的，自己不够用的时候放心的去抢后面的，因为当前行的需求（优先级）比后面都高）</span><br><span class="hljs-comment">//如果该行后缀0个数不满足条件，那么就往下遍历找到最先（贪心，这是最小次数）满足条件的行，一行一行换上来，记录交换的次数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minSwaps</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; resV;<br><span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> n = grid.size();<br>    <span class="hljs-comment">//统计每行后缀0个数，存到resV中</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br><span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; grid[i].size(); j++)<br>&#123;<br><span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">0</span>)<br>&#123;<br>    num++;<br>&#125;<br><span class="hljs-keyword">else</span> <br>&#123;<br>    num = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>resV.push_back(num);<br>&#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)<br>    &#123;<br>        <span class="hljs-comment">//如果当前行的后缀0个数够用，直接往下遍历，不用担心抢了后面的，因为当前行的需求量比后面的都高</span><br>        <span class="hljs-keyword">if</span>(resV[i] &gt;= n - i - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(resV[j] &lt; n - i - <span class="hljs-number">1</span> )<br>            &#123;<br>                j++;<br>                <span class="hljs-comment">//找到最后都没有找到满足个数的后缀0，就直接退出</span><br>                <span class="hljs-keyword">if</span>(j == n)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            &#125;<br>            <span class="hljs-comment">//while之后到这里说明找到了一行满足当前行的后缀0的个数需求，把找到的行一行一行的往上换，换到当前行，每次swap的同时更新交换次数</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> m = j; m &gt; i; m--)<br>            &#123;<br>                swap(resV[m], resV[m - <span class="hljs-number">1</span>]);<br>                res++;<br>            &#125;    <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5484-找出第-N-个二进制字符串中的第-K-位"><a href="#5484-找出第-N-个二进制字符串中的第-K-位" class="headerlink" title="5484. 找出第 N 个二进制字符串中的第 K 位"></a>5484. 找出第 N 个二进制字符串中的第 K 位</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">输入：n = 3, k = 1<br>输出：&quot;0&quot;<br>解释：S3 为 &quot;0111001&quot;，其第 1 位为 &quot;0&quot; <br><br>输入：n = 4, k = 11<br>输出：&quot;1&quot;<br>解释：S4 为 &quot;011100110110001&quot;，其第 11 位为 &quot;1&quot;<br><br>输入：n = 1, k = 1<br>输出：&quot;0&quot;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// invert处理    </span><br><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">ch_not</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">'0'</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">'1'</span>; &#125;<br>        <span class="hljs-keyword">else</span>          &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">'0'</span>; &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">findKthBit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">'0'</span>; &#125;<br>        <span class="hljs-comment">// 1左移n-1位，pow(2, n-1)</span><br>        <span class="hljs-keyword">int</span> mid = (<span class="hljs-number">1</span>&lt;&lt;(n<span class="hljs-number">-1</span>));<br>        <span class="hljs-keyword">if</span>(k == mid) &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">'1'</span>; &#125;<br>        <span class="hljs-keyword">if</span>(k &lt; mid) &#123; <span class="hljs-keyword">return</span> findKthBit(n<span class="hljs-number">-1</span>, k); &#125;<br>        <span class="hljs-comment">// k &gt; mid的情况需要把k挪到对称位置：(1&lt;&lt;n) - k，并进行invert</span><br>        <span class="hljs-keyword">return</span> ch_not(findKthBit(n<span class="hljs-number">-1</span>, (<span class="hljs-number">1</span>&lt;&lt;n) - k)); <br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="5483-整理字符串"><a href="#5483-整理字符串" class="headerlink" title="5483. 整理字符串"></a>5483. 整理字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">输入：s = &quot;leEeetcode&quot;<br>输出：&quot;leetcode&quot;<br>解释：无论你第一次选的是 i = 1 还是 i = 2，都会使 &quot;leEeetcode&quot; 缩减为 &quot;leetcode&quot;<br><br>输入：s = &quot;abBAcC&quot;<br>输出：&quot;&quot;<br>解释：存在多种不同情况，但所有的情况都会导致相同的结果。例如：<br>&quot;abBAcC&quot; --&gt; &quot;aAcC&quot; --&gt; &quot;cC&quot; --&gt; &quot;&quot;<br>&quot;abBAcC&quot; --&gt; &quot;abBA&quot; --&gt; &quot;aA&quot; --&gt; &quot;&quot;<br><br>输入：s = &quot;s&quot;<br>输出：&quot;s&quot;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">makeGood</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i != s.length() - <span class="hljs-number">1</span>)<br>&#123;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; s.length() - <span class="hljs-number">1</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(s[i] - s[i + <span class="hljs-number">1</span>]) == <span class="hljs-number">32</span>)<br>        &#123;<br>            s.erase(i, <span class="hljs-number">2</span>);<br>            i = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(s.empty())<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//William Lin版</span><br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">makeGood</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span><br></span>&#123;<br>    <span class="hljs-keyword">bool</span> ch = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(ch)<br>    &#123;<br>        ch = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">string</span> t = s;<br>        <span class="hljs-comment">//size()返回类型是size_t, (unsigned) 和后面的int相减可能会溢出</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-keyword">int</span>)s.size() - <span class="hljs-number">1</span>; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i] + <span class="hljs-number">32</span> == s[i + <span class="hljs-number">1</span>] || s[i + <span class="hljs-number">1</span>] + <span class="hljs-number">32</span> == s[i])<br>            &#123;<br>                <span class="hljs-comment">//string的substr()使用，带首不带尾，单个参数默认从参数位置取到末尾</span><br>                t = s.substr(<span class="hljs-number">0</span>, i) + s.substr(i + <span class="hljs-number">2</span>);<br>            ch = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        s = t;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5468-第-k-个缺失的正整数"><a href="#5468-第-k-个缺失的正整数" class="headerlink" title="5468. 第 k 个缺失的正整数"></a>5468. 第 k 个缺失的正整数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">输入：arr = [2,3,4,7,11], k = 5<br>输出：9<br>解释：缺失的正整数包括 [1,5,6,8,9,10,12,13,...]<br><br>输入：arr = [1,2,3,4], k = 2<br>输出：6<br>解释：缺失的正整数包括 [5,6,7,...]<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthPositive</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> init = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> resNum = <span class="hljs-number">0</span>;<br>    res = arr[<span class="hljs-number">0</span>] - init <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(res &gt;= k)<br>    &#123;<br>        <span class="hljs-keyword">return</span> k;<br>    &#125;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; arr.size() &amp;&amp; res &lt; k)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(res + arr[i] - arr[i<span class="hljs-number">-1</span>] - <span class="hljs-number">1</span> &lt; k)<br>        &#123;<br>            res += arr[i] - arr[i<span class="hljs-number">-1</span>] - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            resNum = arr[i<span class="hljs-number">-1</span>] + (k - res); <br>            res = k;<br>        &#125;<br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(i == arr.size() &amp;&amp; res &lt; k)<br>    &#123;<br>        resNum = arr.back() + (k - res);<br>    &#125;<br>    <span class="hljs-keyword">return</span> resNum;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5469-K-次操作转变字符串"><a href="#5469-K-次操作转变字符串" class="headerlink" title="5469. K 次操作转变字符串"></a>5469. K 次操作转变字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">输入：s = &quot;input&quot;, t = &quot;ouput&quot;, k = 9<br>输出：true<br>解释：第 6 次操作时，我们将 &apos;i&apos; 切换 6 次得到 &apos;o&apos; 。第 7 次操作时，我们将 &apos;n&apos; 切换 7 次得到 &apos;u&apos;<br><br>输入：s = &quot;abc&quot;, t = &quot;bcd&quot;, k = 10<br>输出：false<br>解释：我们需要将每个字符切换 1 次才能得到 t 。我们可以在第 1 次操作时将 &apos;a&apos; 切换成 &apos;b&apos; ，但另外 2 个字母在剩余操作中无法再转变为 t 中对应字母<br><br>输入：s = &quot;aab&quot;, t = &quot;bbb&quot;, k = 27<br>输出：true<br>解释：第 1 次操作时，我们将第一个 &apos;a&apos; 切换 1 次得到 &apos;b&apos; 。在第 27 次操作时，我们将第二个字母 &apos;a&apos; 切换 27 次得到 &apos;b&apos;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//结果出现的位置有数组首之前，数组中间，数组末尾之后，分别处理</span><br><span class="hljs-comment">//创建一个数组存储每一位需要的操作数，将操作数按大小排好，一次遍历去对应k值看是否满足要求</span><br><span class="hljs-comment">//addNum记录某个操作数出现的次数，比如6在某一位上出现一次，某另一位的操作数也是6，那么操作数只能选择6 + 26，第三次出现时操作数为6 + 26 * 2</span><br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canConvertString</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> t, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s.length() != t.length())<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; resV;<br>        <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (t[i] - s[i] &gt;= <span class="hljs-number">0</span>)<br>            &#123;<br>                temp = t[i] - s[i];<br>                addNum[temp] += <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                temp = t[i] - <span class="hljs-string">'a'</span> + <span class="hljs-string">'z'</span> - s[i] + <span class="hljs-number">1</span>;<br>                addNum[temp] += <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">//操作数为0是可以重复的，不需要加重叠次数*26</span><br>            <span class="hljs-keyword">if</span> (temp != <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">int</span> pushNum = temp + <span class="hljs-number">26</span> * (addNum[temp] - <span class="hljs-number">1</span>);<br>                resV.push_back(pushNum);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                resV.push_back(temp);<br>            &#125;<br>        &#125;<br>        sort(resV.begin(), resV.end());<br>        <span class="hljs-keyword">while</span> (!resV.empty() &amp;&amp; resV.back() != <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (k &gt; resV.back())<br>            &#123;<br>                k = resV.back() - <span class="hljs-number">1</span>;<br>                resV.pop_back();<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == resV.back())<br>            &#123;<br>                resV.pop_back();<br>                k--;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="1546-和为目标值的最大数目不重叠非空子数组数目"><a href="#1546-和为目标值的最大数目不重叠非空子数组数目" class="headerlink" title="1546. 和为目标值的最大数目不重叠非空子数组数目"></a>1546. 和为目标值的最大数目不重叠非空子数组数目</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined">输入：nums = [1,1,1,1,1], target = 2<br>输出：2<br>解释：总共有 2 个不重叠子数组（加粗数字表示） [1,1,1,1,1] ，它们的和为目标值 2 <br><br>输入：nums = [-1,3,5,1,4,2,-9], target = 6<br>输出：2<br>解释：总共有 3 个子数组和为 6 。<br>([5,1], [4,2], [3,5,1,4,2,-9]) 但只有前 2 个是不重叠的<br><br>输入：nums = [-2,6,6,3,5,4,1,2,8], target = 10<br>输出：3<br><br>输入：nums = [0,0,0], target = 0<br>输出：3<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 贪心</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxNonOverlapping</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span><br></span>&#123;<br>    <span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; s;<br>    <span class="hljs-comment">//初始时累计值为0，保证在&#123;-1, 3, 5, 1&#125;中找target=6时能找去掉-1, 3，找到&#123;5, 1&#125;</span><br>    s.insert(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">int</span> ps = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//一个替代遍历vector中每个值的方法（不关注下标时可使用）</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a : nums)<br>    &#123;<br>        <span class="hljs-comment">//记录到每个当前值的累计值，其中的两个值相减就是两者之间的子数组中的各个值和</span><br>        ps += a;<br>        <span class="hljs-comment">//注意理解ps - target的含义，是在当前位置根据target找前面是否有能截断而得到要的子数组的位置</span><br>        <span class="hljs-keyword">if</span>(s.find(ps - target != s.end()))<br>        &#123;<br>            ++ans;<br>            s.clear();<br>        &#125;<br>        s.insert(ps);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给你一个整数数组 arr ，以及 a、b 、c 三个整数。请你统计其中好三元组的数量&lt;/p&gt;
&lt;p&gt;如果三元组 (arr[i], arr[j], arr[k]) 满足下列全部条件，则认为它是一个 好三元组 &lt;/p&gt;
&lt;p&gt;0 &amp;lt;= i &amp;lt; j &amp;lt; k &amp;l
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
</feed>
