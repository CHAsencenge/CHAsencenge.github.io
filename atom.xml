<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>解字</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chasencenge.github.io/"/>
  <updated>2021-01-02T03:04:10.092Z</updated>
  <id>https://chasencenge.github.io/</id>
  
  <author>
    <name>CHAsencenge</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>FPS问题解决记录</title>
    <link href="https://chasencenge.github.io/2021/01/02/FPS%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95/"/>
    <id>https://chasencenge.github.io/2021/01/02/FPS问题解决记录/</id>
    <published>2021-01-02T02:42:38.000Z</published>
    <updated>2021-01-02T03:04:10.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FPS制作中的一些问题解决记录"><a href="#FPS制作中的一些问题解决记录" class="headerlink" title="FPS制作中的一些问题解决记录"></a>FPS制作中的一些问题解决记录</h1><h3 id="怎样实现人物的边走边进行装弹，即上半身和下半身动画的组合"><a href="#怎样实现人物的边走边进行装弹，即上半身和下半身动画的组合" class="headerlink" title="怎样实现人物的边走边进行装弹，即上半身和下半身动画的组合"></a>怎样实现人物的边走边进行装弹，即上半身和下半身动画的组合</h3><p>为实现这一功能，先圈一个大概的定位，在“动画”、“状态机”、“蒙太奇”等关键词上面。</p><p>在“动画”部分看到了两个概念“动画合成”和“动画融合”都有点像完成这一功能的样子，所以先分清动画合成和动画融合两个概念，原来动画合成(composite)只是动画序列的组合，基本是newSequence = sequence1 + sequence2 + … + sequenceN，其中单个的序列可以调整开始、结束时间来控制长度。</p><a id="more"></a><p>动画融合经过了解便是想要的功能，通过Layered blend per bone（每个骨骼的分层混合）可以在Locomotion中将下半身体的移动和上半身体的装弹进行融合，实现移动射击。</p><p>其实在找“Blend”的时候还有相似的概念，Blend和Blend poses by bool，前者是混合Pose，根据权重来计算最后融合的Pose，想要的不是这个，只是想单纯的分离而已，Blend poses by bool它用于连接动画，并在动画切换时进行融合，因此也pass掉。</p><p>那知道了要用ayered blend per bone来进行分层以后，我发现它的输入是Base Pose和Blend Poses 0，也就是要考虑这个“层”具体怎么分开然后输入到这两个地方。</p><p>用插槽(Slot)，插槽中排了装弹的动画。</p><p><img src="/2021/01/02/FPS问题解决记录/slot.png" alt="slot"></p><p>然后就是在角色动画蓝图中使用Layered blend per bone实现分层动画了。</p><p><img src="/2021/01/02/FPS问题解决记录/layered.png" alt="layered"></p><p>角色的事件图表中也要有相应的装弹的逻辑。</p><p><img src="/2021/01/02/FPS问题解决记录/reload.png" alt="reload"></p><p>这样，功能就基本完成了。</p><h3 id="怎样保证长按装弹键时，子弹数的持续增长"><a href="#怎样保证长按装弹键时，子弹数的持续增长" class="headerlink" title="怎样保证长按装弹键时，子弹数的持续增长"></a>怎样保证长按装弹键时，子弹数的持续增长</h3><p>在我一直按下装弹键时，装弹的动画利用Slot中Reloading的循环是可以持续播放的，但是子弹数如何跟着每一次装弹动作来增加呢？</p><p>使用定时器GetTimerManager().SetTimer()，先记录一下动画中每个装弹动作的周期，根据周期设定定时器时间，每完成一次装弹动作，子弹数加5。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">.h<br>FTimerHandle ReloadDownTimerHandler;<br>.<span class="hljs-function">cpp<br><span class="hljs-keyword">void</span> <span class="hljs-title">ATPSShootCharacter::AddBullet</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-keyword">if</span>(ReloadButtonDown)<br>        Bullet += <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">else</span><br>        GetWorldTimerManager().ClearTimer(ReloadDownTimerHandler);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ATPSShootCharacter::AddBulletByReloading</span><span class="hljs-params">()</span><br></span>&#123;<br>    GetWorldTimerManager().SetTimer(ReloadDownTimerHandler, <span class="hljs-keyword">this</span>, &amp;ATPSShootCharacter::AddBullet, <span class="hljs-number">0.9f</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="当角色的旋转度数过大时，进行角色平滑旋转"><a href="#当角色的旋转度数过大时，进行角色平滑旋转" class="headerlink" title="当角色的旋转度数过大时，进行角色平滑旋转"></a>当角色的旋转度数过大时，进行角色平滑旋转</h3><p>当角色视角的旋转角度大于90度时，上半身和下半身的相对旋转就显得有些不自然了，这时下半身应该平滑地旋转至上半身方向，这部分的功能实现主要还是熟悉向量的拆分和旋转体的创建。</p><p><img src="/2021/01/02/FPS问题解决记录/rotation.png" alt="rotation"></p><img src="/2021/01/02/FPS问题解决记录/rotation.png" width="50%" height="50%"><h3 id="怎样实现按下Alt键切换为自由视角"><a href="#怎样实现按下Alt键切换为自由视角" class="headerlink" title="怎样实现按下Alt键切换为自由视角"></a>怎样实现按下Alt键切换为自由视角</h3><p>也就是“自由视角”的功能实现。</p><p>自由视角和一般视角不同之处主要在人物朝向和是否进行平滑旋转两部分，在自由视角中，人物的腿部不需要根据相机的角度改变而进行转动。</p><p>人物的朝向逻辑也有一些不同，自由视角中，当相机在人身后时，人应当朝向相机指向的方向，这部分和一般视角相同，但是由于相机可以转到人的前方而面向人物，这时人物应该始终看向（朝向）相机。</p><p>我的瞄准偏移范围设置为（-180°，180°），相机旋转一周对应的角度为（0°，360°）。</p><p><img src="/2021/01/02/FPS问题解决记录/angle1.jpg" alt="angle1"></p><p>根据上面提到的相机在人后和人前对应的逻辑不同，分情况讨论并完成逻辑：</p><h4 id="1-当相机在人前对着人时，人看向相机，此时CameraYaw的范围为（90°，270°）"><a href="#1-当相机在人前对着人时，人看向相机，此时CameraYaw的范围为（90°，270°）" class="headerlink" title="1. 当相机在人前对着人时，人看向相机，此时CameraYaw的范围为（90°，270°）"></a>1. 当相机在人前对着人时，人看向相机，此时CameraYaw的范围为（90°，270°）</h4><p>举个例子，当相机和人物的位置关系为这样时，相机Yaw为120°，人物看向相机，Yaw应为-60°，即CharacterYaw = CameraYaw - 180，并且CharacterPitch = -CameraPitch（因为相机俯拍时，人的视线上仰）</p><h4 id="2-当相机在人后时，人和相机看向的位置一致，此时CameraYaw范围为（0°，90°）∪（270°，360°）"><a href="#2-当相机在人后时，人和相机看向的位置一致，此时CameraYaw范围为（0°，90°）∪（270°，360°）" class="headerlink" title="2. 当相机在人后时，人和相机看向的位置一致，此时CameraYaw范围为（0°，90°）∪（270°，360°）"></a>2. 当相机在人后时，人和相机看向的位置一致，此时CameraYaw范围为（0°，90°）∪（270°，360°）</h4><p>此时不做上面的处理，还是保持原本的一般视角的逻辑。</p><p>至此解决了人物朝向的问题，接下来还需要解决人物的平滑旋转问题，自由视角中人物不需要跟着视角方向做平滑旋转。</p><p>那么只需要在原本的角色平滑旋转功能中添加一个逻辑，决定什么时候（一般视角）进行角色平滑旋转，什么时候（自由视角）不进行平滑旋转。</p><p>首先在操作映射中添加FreeView事件，绑定到Alt键，然后在人物事件图表中添加变量FreeViewButtonDown，并修改原本的角色平滑旋转的逻辑（红色框为修改部分）。</p><p><img src="/2021/01/02/FPS问题解决记录/rotate.png" alt="rotate"></p><h3 id="准星和视角跟随"><a href="#准星和视角跟随" class="headerlink" title="准星和视角跟随"></a>准星和视角跟随</h3><p>这部分主要是通过获取枪支的插槽变换，然后由通道检测线条(LineTraceByChannel)确定HUD在屏幕的显示位置。</p><p>创建瞄准偏移（混合空间）并采样枪瞄准九个方向的九个帧（并搭配前面说的角色平滑旋转）可使人物持枪瞄准各个方向。</p><h3 id="怎样设置靶子仅被子弹命中时才计分，其它物体命中不计分"><a href="#怎样设置靶子仅被子弹命中时才计分，其它物体命中不计分" class="headerlink" title="怎样设置靶子仅被子弹命中时才计分，其它物体命中不计分"></a>怎样设置靶子仅被子弹命中时才计分，其它物体命中不计分</h3><p>最开始完成靶子命中计分功能时没有很好的区分命中物体，我想要完成只有子弹类命中时才计分；先是尝试Event Hit的“Other”而不是“Other Comp”引脚判断子弹的命中计分，经过测试发现如果使用前者，获取的是Bullet实体，这样用Get Object Name会发现每发子弹都对应不同的实体名，难以做判断，因此改成获取组件，这样对于每一类子弹，只需要添加该类子弹的组件名进行子弹的命中判断。</p><p><img src="/2021/01/02/FPS问题解决记录/target.png" alt="target"></p><h3 id="设计换枪功能是遇到的换枪后人物瞬移问题"><a href="#设计换枪功能是遇到的换枪后人物瞬移问题" class="headerlink" title="设计换枪功能是遇到的换枪后人物瞬移问题"></a>设计换枪功能是遇到的换枪后人物瞬移问题</h3><p>设计换枪功能时，发现将地上的枪支捡起换枪后人物瞬间以飞快的速度瞬移，且按下人物移动键时也没有向相同的方向瞬移，而是奇怪的未知方向。</p><p>一开始我以为是哪里逻辑错误导致人物的移动和子弹绑定到了一起，因为这种瞬移的速度类似于子弹，但是经检测后发现不是这样的问题，而且人物瞬移的方向也并不是子弹发射的方向。</p><p>既然不是这样的原因，想到了既然能使人飞速位移，还有一种可能原因，就是“力”。经过检测，果然是物理方面出现了设置错误，因为枪支Box的碰撞检测的错误设定导致和持枪人物冲撞，再加上人物移动时会有骨骼动画，和枪支Box冲撞使人物被弹飞。</p><p>解决办法是将枪支Box的碰撞检测从BlockAll设定为Block Visibility。</p><h3 id="换枪后枪支反向的问题"><a href="#换枪后枪支反向的问题" class="headerlink" title="换枪后枪支反向的问题"></a>换枪后枪支反向的问题</h3><p>在换枪功能中发现换枪后，换上来的枪支是反向的，但是在骨骼中检查的时候插槽没有问题，是正向的。</p><p>这部分在解决的过程中我首先检查的是枪支的骨骼网格体的骨骼是不是在设计的时候就出了错，检查发现网格体骨骼本身和方向都没有问题。</p><p>于是调整组件之间的相对旋转，但是因为原本的枪支方向没有问题，新换的枪支却是反的，这样调整相对旋转又会导致原来的枪支方向出错。</p><p>想到可能是其他设置的选择参数出了问题，经过排查，发现再将组件添加到组件(AttachComponenetToComponent)之前设置了相对旋转。</p><p>解决办法有两种，如果设置了相对旋转，要么删除相对旋转，要么在AttachComponenetToComponent中选择“Rotation Rule”为“对齐到目标”而不是“保持相对”。</p><h3 id="怎样使不同类型的子弹命中场景中不同的静态网格体时有不同的反馈"><a href="#怎样使不同类型的子弹命中场景中不同的静态网格体时有不同的反馈" class="headerlink" title="怎样使不同类型的子弹命中场景中不同的静态网格体时有不同的反馈"></a>怎样使不同类型的子弹命中场景中不同的静态网格体时有不同的反馈</h3><p>因为场景中的各种静态网格体为不同的材质，如树木，箱子，地面等，为了真实感，不同类的场景网格体应该对子弹射击有不同的特效和音效反馈，同一物体对不同类型的子弹（如子弹，炮弹）命中也应有不同的音效和特效反馈。</p><p>这部分我的解决办法是把特效和音效的区分放到各个网格体（已转换为蓝图）的事件图表中。</p><p><img src="/2021/01/02/FPS问题解决记录/bullethit.png" alt="bullethit"></p><p>上图是场景中某一类物体的事件图表，添加了对两种类型子弹命中的音效和特效反馈。这种解决办法的缺点也很明显，就是为了完成这种反馈，许多静态网格体都要转换为蓝图类型，以便在其中添加逻辑。</p><h3 id="怎样很好的混合使用蓝图和c"><a href="#怎样很好的混合使用蓝图和c" class="headerlink" title="怎样很好的混合使用蓝图和c++"></a>怎样很好的混合使用蓝图和c++</h3><p>对于复杂的功能，纯蓝图实现还是显得很乏力和冗余，那么怎么混合使用蓝图和C++？方法是让蓝图继承某个C++类。</p><p>在编译角度来看二者，发现编译时需遵守C++只能调用C++，蓝图只能调用蓝图，但是C++类在运行时调用，可调用蓝图函数，运行时调用其实时一个C++类调用另一个C++类的接口，间接调用了蓝图函数。</p><p>具体来说，如果我想要给BP_Grabber创建对应的C++类：</p><p>先到BP_Grabber的“类设置”中查看它的父类，为场景组件类“Scene Component”，因此我新建一个C++的“Scene Component”类，名为Grabber，然后便可以设置BP_Grabber的父类为Grabber（要注意Blueprintable）。</p><h3 id="将蓝图中的变量迁移到C"><a href="#将蓝图中的变量迁移到C" class="headerlink" title="将蓝图中的变量迁移到C++"></a>将蓝图中的变量迁移到C++</h3><p>因为混合使用蓝图和C++，我想要我的变量也能在C++中访问。</p><p>解决办法是在C++类体中添加同名的变量，设置合适的UPROPERTY访问修饰符，修改后发现蓝图中对应的同名变量都出现了warning，再次编译即可，这些蓝图中的变量都会成为一个副本，将它们删掉即可，对应的变量节点也要删掉重新放置成C++版本的变量。</p><h3 id="在将蓝图中的函数迁移到C-的过程中如何找到对应节点的函数"><a href="#在将蓝图中的函数迁移到C-的过程中如何找到对应节点的函数" class="headerlink" title="在将蓝图中的函数迁移到C++的过程中如何找到对应节点的函数"></a>在将蓝图中的函数迁移到C++的过程中如何找到对应节点的函数</h3><p>在这个问题之前首先解决的是如何将蓝图的函数迁移到C++，心得基本就是注意几点：选择合适的UFUNCTION访问修饰符，没有输入引脚的设置为BlueprintPure，时刻注意根据函数功能添加或不添加const。将蓝图中的函数在C++中实现后便可将原本的蓝图删掉了。</p><p>然而有一个基本但又很麻烦的问题，因为C++中对应的函数命名可能和蓝图节点不同，我怎么找到与蓝图节点对应的函数？</p><p>例如：如何知道蓝图中的GetWorldLocation对应C++中的GetComponentLocation()？如何知道需要用到Kismet数学库？</p><p>我的方法是一层一层的往下找，先在蓝图节点上看到GetWorldLocation为场景组件Scene Component，它对应C++中的USceneComponent（这块通过命名规则确定），选中USceneComponent利用VA插件可以找到SceneComponent头文件，在头文件中继续搜索GetWorldLocation发现他是添加在UFUNCTION中的元数据，UFUNCTION下面就是它在C++中的命名了。</p><p>然而好像还是比较奇怪，因为下面显示的是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">FVector <span class="hljs-title">USceneComponent::K2_GetComponent</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span><br></span>&#123;<br>    <span class="hljs-keyword">return</span> GetComponentLocation();<br>&#125;<br></code></pre></td></tr></table></figure><p>继续F12看GetComponentLocation()发现才是正确的对应，到上一步总结下来是遇到名字奇怪的对应函数还是看一下它return的函数。</p><h3 id="怎么找到需要引入的头文件的路径"><a href="#怎么找到需要引入的头文件的路径" class="headerlink" title="怎么找到需要引入的头文件的路径"></a>怎么找到需要引入的头文件的路径</h3><p>常用的头文件有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Engine/World.h<br>GameFramework/Actor.h<br>Components/ActorComponent.h<br>Kismet/GameplayStatics.h<br>Math/UnrealMathUtility.h<br></code></pre></td></tr></table></figure><p>那么我如果已知头文件名，怎么找到这些路径以引入头文件？路径名截取到哪个位置？</p><p>总结下来是在VS中ctrl+‘，’搜索头文件，然后鼠标悬停到窗口标签上会有路径，通常只截取“Class”或者“Public”后的部分。</p><h3 id="迁移复杂的函数"><a href="#迁移复杂的函数" class="headerlink" title="迁移复杂的函数"></a>迁移复杂的函数</h3><p>其实这些都是有一定经验便没什么难度的问题，但刚开始接触的时候也确确实实卡住自己很久。</p><p>对于蓝图函数GetPhysicsComponent()，我要将其迁移至C++。</p><p>为了在C++中创建同名函数，先查看蓝图函数的返回值类型。</p><p>看到蓝图返回类型为“Physics Handle Component Object”，去找C++中对应的返回类型。</p><p>VS中搜PhysicsHandleComponent.h，打开对应头文件。</p><p>在头文件中找具体的类名，发现其名为UPhysicsHandleComponent。</p><p>到此可写出同名C++函数声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">UFUNCTION(BlueprintCallable, BlueprintPure)<br><span class="hljs-function">UPhysicsHandleComponent* <span class="hljs-title">GetPhysicsComponent</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br></code></pre></td></tr></table></figure><p>根据节点在蓝图中的前后关系，要用到GetOwner和Get Component by Class（如下图），它的返回类型为Actor，于是添加Actor头文件（怎么判断什么时候需要添加头文件？没有联想功能的时候想想是不是未引入头文件）</p><img src="/2021/01/02/FPS问题解决记录/Users\DELL\Desktop\新建文件夹\func.png" alt="func" style="zoom:50%;"><p>此时函数体可以写到这里：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">UPhysicsHandleComponent* <span class="hljs-title">GetPhysicsComponent</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span><br></span>&#123;<br>    GetOwner()-&gt;GetComponentByClass<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在GetComponentByClass按F12进入头文件搜索函数，发现附近有一个模板函数FindComponentByClass。</p><p>通过其中的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">return</span> (T*)FindComponentByClass(T::StaticClass());<br></code></pre></td></tr></table></figure><p>可以知道它自动转换类型，可以确保返回正确的类型，用这个！</p><p>然后上面的函数体可以继续写为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">UPhysicsHandleComponent* <span class="hljs-title">GetPhysicsComponent</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span><br></span>&#123;<br>    <span class="hljs-keyword">return</span> GetOwner()-&gt;FindComponentByClass&lt;UPhysicsHandleComponent&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><p>至此完成此函数功能的迁移。</p><h3 id="爆炸效果中的冲量"><a href="#爆炸效果中的冲量" class="headerlink" title="爆炸效果中的冲量"></a>爆炸效果中的冲量</h3><p>在实现抛体炸弹爆炸的功能时，抛体爆炸无法炸开周围物体，此时使用的是蓝图函数：添加径向冲量“Add Radial Impulse”。</p><p>关于这个蓝图函数的问题我至今没有找到原因，开始以为是物体的重量，子弹的重量，冲力的大小等设定不合理导致看不到效果，但实际把径向冲量增加到很大的数值仍然没有效果。</p><p>在UE4的官方论坛中尝试过搜索这个问题，据说是在某个版本后确实失效了（不确定）。</p><p>所以使用了其他方法来替代，就是使用径向力组件，在子弹速度降低到某个阈值以下后，将径向力组件激活产生爆炸（这个有效）。</p><p><img src="/2021/01/02/FPS问题解决记录/force.png" alt="force"></p><h3 id="安卓端测试时发现的UMG-Button冲突："><a href="#安卓端测试时发现的UMG-Button冲突：" class="headerlink" title="安卓端测试时发现的UMG Button冲突："></a>安卓端测试时发现的UMG Button冲突：</h3><p>测试时发现按下Button大约1s左右Button会自动弹起，但此时我的手仍然是持续按压Button的；除此之外，在按下Button同时按操控杆，Button会瞬间弹起。</p><p>解决方法是将UMG Button的IsFocusable属性设置为False。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;FPS制作中的一些问题解决记录&quot;&gt;&lt;a href=&quot;#FPS制作中的一些问题解决记录&quot; class=&quot;headerlink&quot; title=&quot;FPS制作中的一些问题解决记录&quot;&gt;&lt;/a&gt;FPS制作中的一些问题解决记录&lt;/h1&gt;&lt;h3 id=&quot;怎样实现人物的边走边进行装弹，即上半身和下半身动画的组合&quot;&gt;&lt;a href=&quot;#怎样实现人物的边走边进行装弹，即上半身和下半身动画的组合&quot; class=&quot;headerlink&quot; title=&quot;怎样实现人物的边走边进行装弹，即上半身和下半身动画的组合&quot;&gt;&lt;/a&gt;怎样实现人物的边走边进行装弹，即上半身和下半身动画的组合&lt;/h3&gt;&lt;p&gt;为实现这一功能，先圈一个大概的定位，在“动画”、“状态机”、“蒙太奇”等关键词上面。&lt;/p&gt;
&lt;p&gt;在“动画”部分看到了两个概念“动画合成”和“动画融合”都有点像完成这一功能的样子，所以先分清动画合成和动画融合两个概念，原来动画合成(composite)只是动画序列的组合，基本是newSequence = sequence1 + sequence2 + … + sequenceN，其中单个的序列可以调整开始、结束时间来控制长度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="GameDev" scheme="https://chasencenge.github.io/categories/GameDev/"/>
    
    
      <category term="UE" scheme="https://chasencenge.github.io/tags/UE/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="https://chasencenge.github.io/2020/12/30/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://chasencenge.github.io/2020/12/30/单例模式/</id>
    <published>2020-12-30T15:02:11.000Z</published>
    <updated>2020-12-30T15:05:13.959Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单例模式："><a href="#单例模式：" class="headerlink" title="单例模式："></a>单例模式：</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;单例模式：&quot;&gt;&lt;a href=&quot;#单例模式：&quot; class=&quot;headerlink&quot; title=&quot;单例模式：&quot;&gt;&lt;/a&gt;单例模式：&lt;/h3&gt;
      
    
    </summary>
    
    
      <category term="DesignPattern" scheme="https://chasencenge.github.io/categories/DesignPattern/"/>
    
    
      <category term="C++" scheme="https://chasencenge.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式</title>
    <link href="https://chasencenge.github.io/2020/12/29/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://chasencenge.github.io/2020/12/29/工厂模式/</id>
    <published>2020-12-29T06:42:06.000Z</published>
    <updated>2020-12-30T15:00:32.028Z</updated>
    
    <content type="html"><![CDATA[<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式分三种，从简单到复杂依次为：简单工厂模式、工厂方法模式、抽象工厂模式。</p><p>简单工厂模式结构包括：工厂类、抽象产品类和具体产品类。</p><a id="more"></a><p>以一个工厂生产各种品牌的鞋为例，工厂单开一类，内设CreateShoes()函数，函数通过switch结构根据输入的鞋子类型名决定生产哪个牌子的鞋子；鞋子作为抽象产品类，覆盖了各个具体的鞋子牌子，细分到各个牌子的鞋子的模块则为具体产品类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*简单工厂*/</span><br><br><span class="hljs-comment">/*抽象产品类和具体产品类*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shoes</span><br>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">/*虚析构函数，保证各个子类能正确析构*/</span><br><span class="hljs-keyword">virtual</span> ~Shoes() &#123;&#125;<br><span class="hljs-comment">/*纯虚函数，具体功能在具体的子类中定义*/</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">/*公有继承，成员函数公有*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NikeShoes</span> :</span> <span class="hljs-keyword">public</span> Shoes<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span><br></span>&#123;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Nike's show"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdidasShoes</span> :</span> <span class="hljs-keyword">public</span> Shoes<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span><br></span>&#123;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Adidas's show"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><br><span class="hljs-comment">/*工厂类*/</span><br><span class="hljs-keyword">enum</span> SHOES_TYPE<br>&#123;<br>NIKE,<br>ADIDAS<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShoesFactory</span><br>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">/*根据鞋子的类型创建对应的鞋子对象*/</span><br><span class="hljs-function">Shoes* <span class="hljs-title">CreateShoes</span><span class="hljs-params">(SHOES_TYPE type)</span><br></span>&#123;<br><span class="hljs-keyword">switch</span> (type)<br>&#123;<br><span class="hljs-keyword">case</span> NIKE:<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NikeShoes();<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> ADIDAS:<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AdidasShoes();<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-comment">/*简单工厂模式*/</span><br>ShoesFactory shoesFactory;<br><br><span class="hljs-comment">/*从工厂对象创建nike鞋对象*/</span><br>Shoes* pNikeShoes = shoesFactory.CreateShoes(NIKE);<br><span class="hljs-keyword">if</span> (pNikeShoes != <span class="hljs-literal">nullptr</span>)<br>&#123;<br>pNikeShoes-&gt;Show();<br><span class="hljs-comment">/*用完释放资源*/</span><br><span class="hljs-keyword">delete</span> pNikeShoes;<br>pNikeShoes = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br>Shoes* pAdidasShoes = shoesFactory.CreateShoes(ADIDAS);<br><span class="hljs-keyword">if</span> (pAdidasShoes != <span class="hljs-literal">nullptr</span>)<br>&#123;<br>pAdidasShoes-&gt;Show();<br><span class="hljs-keyword">delete</span> pAdidasShoes;<br>pAdidasShoes = <span class="hljs-literal">nullptr</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以为各种不同牌子的鞋子开设独立的生产线，每个生产线只生产同品牌的鞋子，此时转为工厂方法模式。</p><p>工厂方法模式相比简单工厂模式，将工厂类分为抽象工厂类和具体工厂类，工厂和产品（鞋子）两块都有各自的抽象和具体。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FMShoes</span><br>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">virtual</span> ~FMShoes() &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FMShow</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FMNikeShoes</span> :</span> <span class="hljs-keyword">public</span> FMShoes<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FMShow</span><span class="hljs-params">()</span><br></span>&#123;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Nike's show"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FMAdidasShoes</span> :</span> <span class="hljs-keyword">public</span> FMShoes<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FMShow</span><span class="hljs-params">()</span><br></span>&#123;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Adidas's show"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FMShoesFactory</span><br>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> FMShoes* <span class="hljs-title">FMCreateShoes</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">virtual</span> ~FMShoesFactory() &#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FMNikeProducer</span> :</span> <span class="hljs-keyword">public</span> FMShoesFactory<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">FMShoes* <span class="hljs-title">FMCreateShoes</span><span class="hljs-params">()</span><br></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FMNikeShoes();<br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FMAdidasProducer</span> :</span> <span class="hljs-keyword">public</span> FMShoesFactory<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">FMShoes* <span class="hljs-title">FMCreateShoes</span><span class="hljs-params">()</span><br></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FMAdidasShoes();<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当工厂与产品的生产关系不是一对一，而变成一对多时，比如原本只生产耐克鞋子的工厂现在生产耐克的各种产品，包括鞋子，衣服等，模式从工厂方法模式变为抽象工厂模式，不过四部分结构：抽象工厂类、具体工厂类、抽象产品类、具体产品类，仍然是这四部分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AFShoes</span><br>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AFShow</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">virtual</span> ~AFShoes() &#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AFNikeShoes</span> :</span> <span class="hljs-keyword">public</span> AFShoes<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AFShow</span><span class="hljs-params">()</span><br></span>&#123;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"nike shoes show"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AFAdidasShoes</span> :</span> <span class="hljs-keyword">public</span> AFShoes<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AFShow</span><span class="hljs-params">()</span><br></span>&#123;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"adidas shoes show"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AFClothes</span><br>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">virtual</span> ~AFClothes() &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AFShow</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AFNikeClothes</span> :</span> <span class="hljs-keyword">public</span> AFClothes<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AFShow</span><span class="hljs-params">()</span><br></span>&#123;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"nike clothes show"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AFAdidasClothes</span> :</span> <span class="hljs-keyword">public</span> AFClothes<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AFShow</span><span class="hljs-params">()</span><br></span>&#123;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"adidas clothes show"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AFFactory</span><br>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AFShoes* <span class="hljs-title">AFCreateShoes</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AFClothes* <span class="hljs-title">AFCreateClothes</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">virtual</span> ~AFFactory() &#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AFNikeProducer</span> :</span> <span class="hljs-keyword">public</span> AFFactory<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/*一个具体工厂管理生产多款该品牌的产品*/</span><br><span class="hljs-function">AFShoes* <span class="hljs-title">AFCreateShoes</span><span class="hljs-params">()</span><br></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AFNikeShoes();<br>&#125;<br><br><span class="hljs-function">AFClothes* <span class="hljs-title">AFCreateClothes</span><span class="hljs-params">()</span><br></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AFNikeClothes();<br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AFAdidasProducer</span> :</span> <span class="hljs-keyword">public</span> AFFactory<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">AFShoes* <span class="hljs-title">AFCreateShoes</span><span class="hljs-params">()</span><br></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AFAdidasShoes();<br>&#125;<br><br><span class="hljs-function">AFClothes* <span class="hljs-title">AFCreateClothes</span><span class="hljs-params">()</span><br></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AFAdidasClothes();<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="进一步提高工厂类的封装性"><a href="#进一步提高工厂类的封装性" class="headerlink" title="进一步提高工厂类的封装性"></a>进一步提高工厂类的封装性</h4><p>以上三种方式在新增产品时，总要修改工厂类或新增具体的工厂类，怎样做到新增产品时不需要修改工厂类、不需要新增具体工厂类？</p><p>使用模板工厂，将工厂方法封装成模板工厂类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TFShoes</span><br>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TFShow</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">virtual</span> ~TFShoes() &#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TFNikeShoes</span> :</span> <span class="hljs-keyword">public</span> TFShoes<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TFShow</span><span class="hljs-params">()</span><br></span>&#123;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"nike shoes show"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TFClothes</span><br>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TFShow</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">virtual</span> ~TFClothes() &#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TFUniqloClothes</span> :</span> <span class="hljs-keyword">public</span> TFClothes<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TFShow</span><span class="hljs-params">()</span><br></span>&#123;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"uniqlo clothes show"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">/*抽象模板工厂*/</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TFAbstractProduct_t</span>&gt;<br><span class="hljs-title">class</span> <span class="hljs-title">TFAbstractFactory</span><br>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> TFAbstractProduct_t* <span class="hljs-title">TFCreateProduct</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">virtual</span> ~TFAbstractFactory() &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TFAbstractProduct_t</span>, <span class="hljs-title">class</span> <span class="hljs-title">TFConcreteProduct_t</span>&gt;<br><span class="hljs-title">class</span> <span class="hljs-title">TFConcreteFactory</span> :</span> <span class="hljs-keyword">public</span> TFAbstractFactory&lt;TFAbstractProduct_t&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">TFAbstractProduct_t* <span class="hljs-title">TFCreateProduct</span><span class="hljs-params">()</span><br></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TFConcreteProduct_t();<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-comment">/*模板工厂*/</span><br><span class="hljs-comment">/*创建nike鞋的工厂对象，这种方式是创建在栈上*/</span><br>TFConcreteFactory&lt;TFShoes, TFNikeShoes&gt; nikeFactory;<br><span class="hljs-comment">/*创建nike鞋对象*/</span><br>TFShoes* pNikeShoes = nikeFactory.TFCreateProduct();<br>pNikeShoes-&gt;TFShow();<br><span class="hljs-keyword">delete</span> pNikeShoes;<br>pNikeShoes = <span class="hljs-literal">NULL</span>;<br><br>TFConcreteFactory&lt;TFClothes, TFUniqloClothes&gt; uniqloFactory;<br>TFClothes* pUniqloClothes = uniqloFactory.TFCreateProduct();<br>pUniqloClothes-&gt;TFShow();<br><span class="hljs-keyword">delete</span> pUniqloClothes;<br>pUniqloClothes = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="产品注册模板类-单例工厂模板类"><a href="#产品注册模板类-单例工厂模板类" class="headerlink" title="产品注册模板类+单例工厂模板类"></a>产品注册模板类+单例工厂模板类</h4><p>模板工厂缺少一个可以统一随时随地获取指定的产品对象的类，解决办法是：可以把产品注册的对象用map保存，通过key-value方式获取对应的产品对象的实例。</p><p>思路：产品注册功能封装成注册模板类，注册的产品对象保存在工厂模板类的map，便于产品对象的获取。把获取产品对象的功能封装成工厂模板类，为了能随时随地获取指定的产品对象，把工厂设计成单例模式。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs c++">class PRShoes<br>&#123;<br>public:    <br>    virtual void PRShow() = 0;<br>    virtual ~PRShoes() &#123;&#125;<br>&#125;;<br><br>class PRNikeShoes : public PRShoes<br>&#123;<br>public:<br>void PRShow()<br>    &#123;<br>        std::cout &lt;&lt; "NikeShoes show" &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br>class PRClothe<br>&#123;<br>public:<br>virtual void PRShow() = 0;<br>    virtual ~PRClothe() &#123;&#125;<br>&#125;;<br><br>class PRUniqlo : public PRClothe<br>&#123;<br>public:<br>void PRShow()<br>    &#123;<br>        std::cout &lt;&lt; "UniqloClothe show" &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br>/*产品注册模板接口类*/<br>template&lt;class ProductType_t&gt;<br>class IProductRegistrar<br>&#123;<br>public:<br>    /*纯虚函数，产生产品的功能在产品注册模板类中实现（这个类只是个接口类）*/<br>    virtual ProductType_t* CreateProduct() = 0;<br>    <br>protected:<br>    /*禁止外部进行构造和析构，想让子类（产品注册模板类）使用*/<br>    IProductRegistrar() &#123;&#125;<br>    virtual ~IProductRegistrar() &#123;&#125;<br>    <br>private:<br>    /*禁止外部拷贝和赋值*/<br>    IProductRegistrar(const IProductRegistrar&amp;);<br>    const IProductRegistrar&amp; operator=(const IProductRegistrar&amp;);<br>&#125;;<br><br>/*工厂模板类，用于获取和注册产品对象*/<br>template&lt;class ProductType_t&gt;<br>class ProductFactory<br>&#123;<br>public:<br>    /*工厂单例的实现是使用static搭配private的构造和析构函数*/<br>    static ProductFactory&lt;ProductType_t&gt;&amp; Instance()<br>    &#123;<br>        static ProductFactory&lt;ProductType_t&gt; instance;<br>        return instance;<br>    &#125;<br> <br>    /*注册产品对象，名字+注册员*/<br>    void RegisterProduct(IProductRegistrar&lt;ProductType_t&gt;* registrar, std::string name)<br>    &#123; <br>        m_ProductRegistry[name] = registrar;<br>    &#125;<br>    <br>    /*获取产品对象，通过“名字”找到对应的“注册员”，来产生产品*/<br>    ProductType_t* GetProduct(std::string name)<br>    &#123;<br>        if(m_ProductRegistry.find(name) != m_ProductRegistry.end())<br>        &#123;<br>            return m_ProductRegistry[name]-&gt;CreateProduct();<br>        &#125;<br>        std::cout &lt;&lt; "No product found for" &lt;&lt; name &lt;&lt; std::endl;<br>        return NULL;<br>    &#125;<br>    <br>private:<br>    ProductFactory() &#123;&#125;<br>    ~ProductFactory() &#123;&#125;<br>    <br>    ProductFactory(const ProductFactory&amp;);<br>    const ProductFactory&amp; operator=(const ProductFactory&amp;);<br>    <br>    std::map&lt;std::string, IProductRegistrar&lt;ProductType_t&gt;*&gt; m_ProductRegistry;<br>&#125;;<br><br>/*产品注册模板类，用于创建具体的产品和从工厂里注册产品*/<br>template&lt;class ProductType_t, class ProductImpl_t&gt;<br>class ProductRegistrar : public IProductRegistrar&lt;ProductType_t&gt;<br>&#123;<br>public:<br>    /*构造函数，explicit使得其只能显式调用，必须要提供name，不提供名字我怎么知道自己要注册什么产品？*/<br>    explicit ProductRegistrar(std::string name)<br>    &#123;   <br>        /*用（大种类ProductType_t）相应工厂的实例去注册map*/<br>        ProductFactory&lt;ProductType_t&gt;::Instance().RegisterProduct(this, name);<br>    &#125;<br>    /*产生一个具体产品，返回其指针*/<br>    ProductType_t* CreateProduct()<br>    &#123;<br>        return new ProductImpl_t();<br>    &#125;<br>&#125;;<br><br>void main()<br>&#123;<br>    /*生产nike鞋的过程*/<br>    /*注册产品的种类（大类）为PRShoes，产品（子类）为PRNikeShoes，产品名为nike（通过显式调用）*/<br>    ProductRegistrar&lt;PRShoes, PRNikeShoes&gt; nikeShoes("nike");<br>    /*从PRShoes工厂单例中获取nike产品对象*/<br>    PRShoes* pNikeShoes = ProductFactory&lt;PRShoes&gt;::Instance().GetProduct("nike");<br>    pNikeShoes-&gt;PRShow();<br>    if(pNikeShoes)<br>    &#123;<br>        delete pNikeShoes;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerlink&quot; title=&quot;工厂模式&quot;&gt;&lt;/a&gt;工厂模式&lt;/h3&gt;&lt;p&gt;工厂模式分三种，从简单到复杂依次为：简单工厂模式、工厂方法模式、抽象工厂模式。&lt;/p&gt;
&lt;p&gt;简单工厂模式结构包括：工厂类、抽象产品类和具体产品类。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DesignPattern" scheme="https://chasencenge.github.io/categories/DesignPattern/"/>
    
    
      <category term="C++" scheme="https://chasencenge.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>手撸算法终版</title>
    <link href="https://chasencenge.github.io/2020/11/30/%E6%89%8B%E6%92%B8%E7%AE%97%E6%B3%95%E7%BB%88%E7%89%88/"/>
    <id>https://chasencenge.github.io/2020/11/30/手撸算法终版/</id>
    <published>2020-11-30T12:43:44.000Z</published>
    <updated>2020-12-28T08:55:21.493Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-两数之和（为目标值）-3min"><a href="#1-两数之和（为目标值）-3min" class="headerlink" title="1. 两数之和（为目标值）   3min"></a>1. 两数之和（为目标值）   3min</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span><br></span>&#123;<br>    umordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; hashtable;<br>    <span class="hljs-comment">/* xiaoguo */</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++)<br>    &#123;<br>        <span class="hljs-keyword">auto</span> it = hashtable.find(target - nums[i]);<br>        <span class="hljs-keyword">if</span>(it != hashtable.end())<br>            <span class="hljs-keyword">return</span> &#123;it-&gt;second, i&#125;;<br>        hashtable[nums[i]] = i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><a id="more"></a><h3 id="2-两数相加（链表形式给出，返回同样格式的链表）-4min"><a href="#2-两数相加（链表形式给出，返回同样格式的链表）-4min" class="headerlink" title="2. 两数相加（链表形式给出，返回同样格式的链表）  4min"></a>2. 两数相加（链表形式给出，返回同样格式的链表）  4min</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span><br></span>&#123;<br>ListNode* head = <span class="hljs-literal">nullptr</span>;<br>    ListNode* tail = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(l1 || l2)<br>    &#123;<br>        <span class="hljs-keyword">int</span> n1 = l1 ? l1-&gt;val : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> n2 = l2 ? l2-&gt;val : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> sum = n1 + n2 + carry;<br>        <span class="hljs-keyword">if</span>(!head)<br>        &#123;<br>            head = tail = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            tail-&gt;next = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>);<br>            tail = tail-&gt;next;<br>        &#125;<br>        carry = sum / <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">if</span>(l1)<br>            l1 = l1-&gt;next;<br>        <span class="hljs-keyword">if</span>(l2)<br>            l2 = l2-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(carry)<br>    &#123;<br>        tail-&gt;next = <span class="hljs-keyword">new</span> ListNode(carry);<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-无重复字符的最长字串-2min"><a href="#3-无重复字符的最长字串-2min" class="headerlink" title="3. 无重复字符的最长字串     2min"></a>3. 无重复字符的最长字串     2min</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span><br></span>&#123;<br><span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt; st;<br>    <span class="hljs-keyword">int</span> n = s.size();<br>    <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>, ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>; left &lt; n; left++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(left != <span class="hljs-number">0</span>)<br>        &#123;<br>            st.erase(s[left - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(right &lt; n &amp;&amp; !st.count(s[right]))<br>        &#123;<br>            st.insert(s[right]);<br>            right++;<br>        &#125;<br>        ret = max(ret, right - left);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="15-三数之和（等于0）-9min"><a href="#15-三数之和（等于0）-9min" class="headerlink" title="15. 三数之和（等于0）  9min"></a>15. 三数之和（等于0）  9min</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">threeSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span><br></span>&#123;<br>    sort(nums.begin(), nums.end());<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; ret;<br>    <span class="hljs-keyword">int</span> n = nums.size();<br>    <span class="hljs-keyword">if</span>(n &gt;= <span class="hljs-number">3</span> &amp;&amp; nums[n - <span class="hljs-number">1</span>] + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">3</span>] &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> ret;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> first = <span class="hljs-number">0</span>; first &lt; n - <span class="hljs-number">2</span>; first++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(nums[first] + nums[first + <span class="hljs-number">1</span>] + nums[first + <span class="hljs-number">2</span>] &gt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span>(first &gt; <span class="hljs-number">0</span> &amp;&amp; nums[first] == nums[first - <span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">int</span> target = -nums[first];<br>        <span class="hljs-keyword">int</span> third = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> second = first + <span class="hljs-number">1</span>; second &lt; n - <span class="hljs-number">1</span>; second++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(second &gt; first + <span class="hljs-number">1</span> &amp;&amp; nums[second] == nums[second - <span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">while</span>(second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target)<br>                --third;<br>            <span class="hljs-keyword">if</span>(second == third)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span>(nums[second] + nums[third] == target)<br>                ret.push_back(&#123;nums[first], nums[second], nums[third]&#125;);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="84-柱状图中的最大矩形-8min"><a href="#84-柱状图中的最大矩形-8min" class="headerlink" title="84. 柱状图中的最大矩形    8min"></a>84. 柱状图中的最大矩形    8min</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++">int largestRectangleArea(vector&lt;int&gt;&amp; heights)<br>&#123;<br>    int ret = 0;<br>    int n = heights.size();<br>    vector&lt;int&gt; left(n), right(n, n);<br>    stack&lt;int&gt; monoStack;<br>    for(int i = 0; i &lt; n; i++)<br>    &#123;<br>        while(!monoStack.empty() &amp;&amp; heights[monoStack.top()] &gt;= heights[i])<br>        &#123;<br>            right[monoStack.top()] = i;<br>            monoStack.pop();<br>        &#125;<br>        left[i] = monoStack.empty() ? -1 : monoStack.top();<br>        monoStack.push(i);<br>    &#125;<br>    for(int i = 0; i &lt; n; i++)<br>    &#123;<br>        ret = max(ret, (right[i] - left[i] - 1) * heights[i]);<br>    &#125;<br>    return ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="85-最大矩形-15min"><a href="#85-最大矩形-15min" class="headerlink" title="85. 最大矩形     15min"></a>85. 最大矩形     15min</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++">int lagestRectangleArea(vector&lt;int&gt;&amp; heights)<br>&#123;<br>    int ret = 0;<br>    int n = heights.size();<br>    vector&lt;int&gt; left(n), right(n, n);<br>    stack&lt;int&gt; monoStack;<br>    for(int i = 0; i &lt; n; i++)<br>    &#123;<br>        while(!monoStack.empty() &amp;&amp; heights[monoStack.top()] &gt;= heights[i])<br>        &#123;<br>            right[monoStack.top()] = i;<br>            monoStack.pop();<br>        &#125;<br>        left[i] = monoStack.empty() ? -1 : monoStack.top();<br>        monoStack.push(i);<br>    &#125;<br>    for(int i = 0; i &lt; n; i++)<br>    &#123;<br>        ret = max(ret, (right[i] - left[i] - ) * heights[i]);<br>    &#125;<br>    return ret;<br>&#125;<br>int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix)<br>&#123;<br> int ret = 0;<br>    int m = matrix.size();<br>    if(m == 0)<br>        return 0;<br>    int n = matrix[0].size();<br>    vector&lt;int&gt; dp (n, 0);<br>    for(int i = 0; i &lt; m; i++)<br>    &#123;<br>        for(int j = 0; j &lt; n; j++)<br>        &#123;<br>            dp[j] = matrix[i][j] == '0' ? 0 : dp[j] + 1;<br>        &#125;<br>        ret = max(ret, largestRectangleArea(dp));<br>    &#125;<br>    return ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a>94. 二叉树的中序遍历</h3><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; ret)</span><br></span>&#123;<br>    <span class="hljs-keyword">if</span>(!root)<br>        <span class="hljs-keyword">return</span>;<br>    inorder(root-&gt;left, ret);<br>    ret.push_back(root-&gt;val);<br>    inorder(root-&gt;right, ret);<br>&#125;<br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span><br></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ret;<br>    inorder(root, ret);<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="非递归-栈"><a href="#非递归-栈" class="headerlink" title="非递归(栈)"></a>非递归(栈)</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span><br></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ret;<br>    <span class="hljs-built_in">stack</span>&lt;TreeNode*&gt; stk;<br>    <span class="hljs-keyword">while</span>(root || !stk.empty())<br>    &#123;<br>        <span class="hljs-keyword">while</span>(root)<br>        &#123;<br>            stk.push(root);<br>            root = root-&gt;left;<br>        &#125;<br>        root = stk.top();<br>        stk.pop();<br>        ret.push_back(root-&gt;val);<br>        root = root-&gt;right;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Morris"><a href="#Morris" class="headerlink" title="Morris"></a>Morris</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span><br></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ret;<br>    TreeNode* predecessor = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span>(root)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(root-&gt;left != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            predecessor = root-&gt;left;<br>            <span class="hljs-keyword">while</span>(predecessor-&gt;right != <span class="hljs-literal">nullptr</span> &amp;&amp; predecessor-&gt;right != root)<br>            &#123;<br>                predecessor = predecessor-&gt;right;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(predecessor-&gt;right == <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                predecessor-&gt;right = root;<br>                root = root-&gt;left;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                ret.push_back(root-&gt;val);<br>                predecessor-&gt;right = <span class="hljs-literal">nullptr</span>;<br>                root = root-&gt;right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            ret.push_back(root-&gt;val);<br>            root = root-&gt;right;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="96-（n个点能组成的）不同的二叉搜索树-1min"><a href="#96-（n个点能组成的）不同的二叉搜索树-1min" class="headerlink" title="96. （n个点能组成的）不同的二叉搜索树     1min"></a>96. （n个点能组成的）不同的二叉搜索树     1min</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span><br></span>&#123;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> m = <span class="hljs-number">2</span>; m &lt;= n; m++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>        &#123;<br>            dp[m] += dp[i - <span class="hljs-number">1</span>] * dp[m - i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="98-验证（一棵树是否为）二叉搜索树-3min"><a href="#98-验证（一棵树是否为）二叉搜索树-3min" class="headerlink" title="98. 验证（一棵树是否为）二叉搜索树     3min"></a>98. 验证（一棵树是否为）二叉搜索树     3min</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span><br></span>&#123;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> inorder = (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)INT_MIN - <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">stack</span>&lt;TreeNode*&gt; stk;<br>    <span class="hljs-keyword">while</span>(root || !stk.empty())<br>    &#123;<br>        <span class="hljs-keyword">while</span>(root)<br>        &#123;<br>            stk.push(root);<br>            root = root-&gt;left;<br>        &#125;<br>        root = stk.top();<br>        stk.pop();<br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt;= inorder)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        inorder = root-&gt;val;<br>        root = root-&gt;right;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="102-二叉树的层序遍历-按层次打印到二维数组中）-6min"><a href="#102-二叉树的层序遍历-按层次打印到二维数组中）-6min" class="headerlink" title="102. 二叉树的层序遍历(按层次打印到二维数组中） 6min"></a>102. 二叉树的层序遍历(按层次打印到二维数组中） 6min</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode* root)</span><br></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; ret;<br>    <span class="hljs-keyword">if</span>(!root)<br>    &#123;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; que;<br>    que.push(root);<br>    <span class="hljs-keyword">while</span>(!que.empty())<br>    &#123;<br>        <span class="hljs-keyword">int</span> n = que.size();<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; temp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> node = que.front();<br>            que.pop();<br>            temp.push_back(node-&gt;val);<br>            <span class="hljs-keyword">if</span>(node-&gt;left)<br>                que.push(node-&gt;left);<br>            <span class="hljs-keyword">if</span>(node-&gt;right)<br>                que.push(node-&gt;right);<br>        &#125;<br>        ret.push_back(temp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="114-二叉树（原地）展开为链表（顺着右子节点连）-3min"><a href="#114-二叉树（原地）展开为链表（顺着右子节点连）-3min" class="headerlink" title="114. 二叉树（原地）展开为链表（顺着右子节点连）  3min"></a>114. 二叉树（原地）展开为链表（顺着右子节点连）  3min</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode* root)</span><br></span>&#123;<br>    TreeNode* cur = root;<br>    <span class="hljs-keyword">while</span>(cur)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(cur-&gt;left)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> next = cur-&gt;left;<br>            <span class="hljs-keyword">auto</span> predecessor = next;<br>            <span class="hljs-keyword">while</span>(predecessor-&gt;right)<br>                predecessor = predecessor-&gt;right;<br>            predecessor-&gt;right = cur-&gt;right;<br>            cur-&gt;left = <span class="hljs-literal">nullptr</span>;<br>            cur-&gt;right = next;<br>&#125;<br>        cur = cur-&gt;right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="121-买卖股票的最佳时机-1min"><a href="#121-买卖股票的最佳时机-1min" class="headerlink" title="121. 买卖股票的最佳时机     1min"></a>121. 买卖股票的最佳时机     1min</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span><br></span>&#123;<br>    <span class="hljs-keyword">int</span> minprice = <span class="hljs-number">1e9</span>, maxprofit = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> price : prices)<br>    &#123;<br>        minprice = min(price, minprice);<br>        maxprofit = max(maxprofit, price - minprice);<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxprofit;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="124-（从任意点起的）二叉树中的最大路径和"><a href="#124-（从任意点起的）二叉树中的最大路径和" class="headerlink" title="124. （从任意点起的）二叉树中的最大路径和"></a>124. （从任意点起的）二叉树中的最大路径和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxGain</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span>&amp; maxSum)</span><br></span>&#123;<br>    <span class="hljs-keyword">if</span>(root)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> left = max(maxGain(root-&gt;left), <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">int</span> right = max(maxGain(root-&gt;right), <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">int</span> curMaxSum = root-&gt;val + left + right;<br>    maxSum = max(maxSum, curMaxSum);<br>    <span class="hljs-keyword">return</span> root-&gt;val + max(left, right);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span><br></span>&#123;<br>    <span class="hljs-keyword">int</span> maxSum = INT_MIN;<br>    maxGain(root, maxSum);<br>    <span class="hljs-keyword">return</span> maxSum;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="128-（无序数组中能找出的）最长连续序列（需要O-n-时间复杂度）"><a href="#128-（无序数组中能找出的）最长连续序列（需要O-n-时间复杂度）" class="headerlink" title="128. （无序数组中能找出的）最长连续序列（需要O(n)时间复杂度）"></a>128. （无序数组中能找出的）最长连续序列（需要O(n)时间复杂度）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span><br></span>&#123;<br>    <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">int</span>&gt; st;<br>    <span class="hljs-keyword">int</span> longestSeq = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)<br>        st.insert(num);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> s : st)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!st.count(s - <span class="hljs-number">1</span>))<br>        &#123;<br>            <span class="hljs-keyword">int</span> curSeq = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">int</span> curNum = s;<br>            <span class="hljs-keyword">while</span>(st.count(curNum + <span class="hljs-number">1</span>))<br>            &#123;<br>                curSeq++;<br>                curNum++;<br>            &#125;<br>            longestSeq = max(longestSeq, curSeq);<br>        &#125;<br>&#125;<br>    <span class="hljs-keyword">return</span> longestSeq;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="136-（在其余数字都出现两次的数组中找）只出现一次的数字（要求线性时间，不使用额外空间）"><a href="#136-（在其余数字都出现两次的数组中找）只出现一次的数字（要求线性时间，不使用额外空间）" class="headerlink" title="136. （在其余数字都出现两次的数组中找）只出现一次的数字（要求线性时间，不使用额外空间）"></a>136. （在其余数字都出现两次的数组中找）只出现一次的数字（要求线性时间，不使用额外空间）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span><br></span>&#123;<br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)<br>        ret ^= num;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="139-单词（是否可以）拆分（成字符串数组中的元素）-4min"><a href="#139-单词（是否可以）拆分（成字符串数组中的元素）-4min" class="headerlink" title="139. 单词（是否可以）拆分（成字符串数组中的元素）  4min"></a>139. 单词（是否可以）拆分（成字符串数组中的元素）  4min</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; wordDict)</span><br></span>&#123;<br>    <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt; st;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">string</span> word : wordDict)<br>        st.insert(word);<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(s.size() + <span class="hljs-number">1</span>)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= s.size();i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)<br>            <span class="hljs-keyword">if</span>(dp[j] &amp;&amp; st.find(s.substr(j, i - j)) != st.end())<br>            &#123;<br>                dp[i] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[s.size()];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="146-LRU缓存机制"><a href="#146-LRU缓存机制" class="headerlink" title="146. LRU缓存机制"></a>146. LRU缓存机制</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DLinkedNode</span><br>&#123;</span><br>    <span class="hljs-keyword">int</span> key, value;<br>    DLinkedNode* prev;<br>    DLinkedNode* next;<br>    DLinkedNode() : key(<span class="hljs-number">0</span>), value(<span class="hljs-number">0</span>), prev(<span class="hljs-literal">nullptr</span>), next(<span class="hljs-literal">nullptr</span>)&#123;&#125;;<br>    DLinkedNode(<span class="hljs-keyword">int</span> _key, <span class="hljs-keyword">int</span> _value) : key(_key), value(_value), prev(<span class="hljs-literal">nullptr</span>), next(<span class="hljs-literal">nullptr</span>)&#123;&#125;;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span><br>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, DLinkedNode*&gt; cache;<br>    <span class="hljs-keyword">int</span> size, capacity;<br>    DLinkedNode* head;<br>    DLinkedNode* tail;<br><span class="hljs-keyword">public</span>:<br>    LRUCache(<span class="hljs-keyword">int</span> _capacity) : size(<span class="hljs-number">0</span>), capacity(_capacity)<br>    &#123;<br>        head = <span class="hljs-keyword">new</span> DLinkedNode();<br>        tail = <span class="hljs-keyword">new</span> DLinkedNode();<br>        head-&gt;next = tail;<br>        tail-&gt;prev = head;<br> &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span><br>    </span>&#123;<br>        <span class="hljs-keyword">if</span>(!cache.count(key))<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        DLinkedNode* node = cache[key];<br>        moveToHead(node);<br>        <span class="hljs-keyword">return</span> node-&gt;value;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span><br>    </span>&#123;<br>        <span class="hljs-keyword">if</span>(!cache.count(key))<br>        &#123;<br>            DLinkedNode* node = <span class="hljs-keyword">new</span> DLinkedNode(key, value);<br>            cache[key] = node;<br>            addToHead(node);<br>            size++;<br>            <span class="hljs-keyword">if</span>(size &gt; capacity)<br>            &#123;<br>                DLinkedNode* remove = tail-&gt;prev;<br>                cache.erase(remove-&gt;key);<br>                removeTail();<br>                size--;<br>                <span class="hljs-keyword">delete</span> remove;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            DLinkedNode* node = cache[key];<br>            node-&gt;value = value;<br>            moveToHead(node);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addToHead</span><span class="hljs-params">(DLinkedNode* node)</span><br>    </span>&#123;<br>        node-&gt;prev = head;<br>        node-&gt;next = head-&gt;next;<br>        head-&gt;next-&gt;prev = node;<br>        head-&gt;next = node;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeNode</span><span class="hljs-params">(DLinkedNode* node)</span><br>    </span>&#123;<br>        node-&gt;next-&gt;prev = node-&gt;prev;<br>        node-&gt;prev-&gt;next = node-&gt;next;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">moveToHead</span><span class="hljs-params">(DLinkedNode* node)</span><br>    </span>&#123;<br>        removeNode(node);<br>        addToHead(node);<br>    &#125;<br>    <span class="hljs-function">DLinkedNode* <span class="hljs-title">removeTail</span><span class="hljs-params">()</span><br>    </span>&#123;<br>        DLinkedNode* node = tail-&gt;prev;<br>        removeNode(node);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="148-排序链表（要求时间复杂度O-nlogn-，空间复杂度O-1-）"><a href="#148-排序链表（要求时间复杂度O-nlogn-，空间复杂度O-1-）" class="headerlink" title="148. 排序链表（要求时间复杂度O(nlogn)，空间复杂度O(1)）"></a>148. 排序链表（要求时间复杂度O(nlogn)，空间复杂度O(1)）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span><br></span>&#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    ListNode* node = head;<br>    <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(node != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        length++;<br>        node = node-&gt;next;<br>    &#125;<br>    ListNode* dummyHead = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>, head);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> subLength = <span class="hljs-number">1</span>; subLength &lt; length; subLength &lt;&lt;= <span class="hljs-number">1</span>)<br>    &#123;<br>        ListNode* prev = dummyHead;<br>        ListNode* curr = dummyHead-&gt;next;<br>        <span class="hljs-keyword">while</span>(curr != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            ListNode* head1 = curr;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; subLength &amp;&amp; curr-&gt;next != <span class="hljs-literal">nullptr</span>; i++)<br>            &#123;<br>                curr = curr-&gt;next;<br>            &#125;<br>            ListNode* head2 = curr-&gt;next;<br>            curr-&gt;next = <span class="hljs-literal">nullptr</span>;<br>            curr = head2;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; subLength &amp;&amp; curr != <span class="hljs-literal">nullptr</span> &amp;&amp; curr-&gt;next != <span class="hljs-literal">nullptr</span>; i++)<br>            &#123;<br>                curr = curr-&gt;next;<br>            &#125;<br>            ListNode* next = <span class="hljs-literal">nullptr</span>;<br>            <span class="hljs-keyword">if</span>(curr != <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                next = curr-&gt;next;<br>                curr-&gt;next = <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>            <span class="hljs-comment">//curr = next;</span><br>            ListNode* merged = merge(head1, head2);<br>            prev-&gt;next = merged;<br>            <span class="hljs-keyword">while</span>(prev-&gt;next != <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                prev = prev-&gt;next;<br>            &#125;<br>            curr = next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br>&#125;<br><span class="hljs-function">ListNode* <span class="hljs-title">merge</span><span class="hljs-params">(ListNode* head1, ListNode* head2)</span><br></span>&#123;<br>    ListNode* dummyHead = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>    ListNode* temp = dummyHead;<br>    ListNode* temp1 = head1;<br>    ListNode* temp2 = head2;<br>    <span class="hljs-keyword">while</span>(temp1 != <span class="hljs-literal">nullptr</span> &amp;&amp; temp2 != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(temp1-&gt;val &lt;= temp2-&gt;val)<br>        &#123;<br>            temp-&gt;next = temp1;<br>            temp1 = temp1-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            temp-&gt;next = temp2;<br>            temp2 = temp2-&gt;next;<br>        &#125;<br>        temp = temp-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(temp1 != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        temp-&gt;next = temp1;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(temp2 != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        temp-&gt;next = temp2;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a>152. 乘积最大子数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span><br></span>&#123;<br>    <span class="hljs-keyword">int</span> maxF = nums[<span class="hljs-number">0</span>], minF = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> ans = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.size(); i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> mx = maxF, mn = minF;<br>        maxF = max(mx * nums[i], max(mn * nums[i], nums[i]));<br>        minF = min(mx * nums[i], min(mn * nums[i], nums[i]));<br>        ans = max(maxF, ans);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="155-最小栈（保证能常数时间内返回最小值）"><a href="#155-最小栈（保证能常数时间内返回最小值）" class="headerlink" title="155. 最小栈（保证能常数时间内返回最小值）"></a>155. 最小栈（保证能常数时间内返回最小值）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span><br>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; xStack;<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; mStack;<br>    MinStack()<br>    &#123;<br>        mStack.push(INT_MIN);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span><br>    </span>&#123;<br>        xStack.push(x);<br>        mStack.push(min(x, mStack.pop()));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span><br>    </span>&#123;<br>        xStack.pop();<br>        mStack.pop();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span><br>    </span>&#123;<br>        <span class="hljs-keyword">return</span> xStack.top();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span><br>    </span>&#123;<br>        <span class="hljs-keyword">return</span> mStack.top();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a>198. 打家劫舍</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span><br></span>&#123;<br>    <span class="hljs-keyword">if</span>(nums.empty())<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> n = nums.size();<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>    dp[<span class="hljs-number">1</span>] = max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++)<br>    &#123;<br>        dp[i] = max(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + nums[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a>200. 岛屿数量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span><br>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; parent;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; rank;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br>    UnionFind(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; grid)<br>    &#123;<br><span class="hljs-keyword">int</span> m = grid.size();<br>        <span class="hljs-keyword">int</span> n = grid[<span class="hljs-number">0</span>].size();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; m; r++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; n; c++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(grid[r][c] == <span class="hljs-string">'1'</span>)<br>                &#123;<br>                    parent.push_back(r * n + c);<br>                    count++;<br>&#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    parent.push_back(<span class="hljs-number">-1</span>);<br>                &#125;<br>                rank.push_back(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span><br>    </span>&#123;<br>        <span class="hljs-keyword">if</span>(parent[i] != i)<br>            parent[i] = find(parent[i]);<br>        <span class="hljs-keyword">return</span> parent[i];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span><br>    </span>&#123;<br>        <span class="hljs-keyword">int</span> rootx = find(x);<br>        <span class="hljs-keyword">int</span> rooty = find(y);<br>        <span class="hljs-keyword">if</span>(rootx != rooty)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(rank[rootx] &lt; rank[rooty])<br>            &#123;<br>                swap(rootx, rooty);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(rank[rootx] == rank[rooty])<br>            &#123;<br>                rank[rootx] += <span class="hljs-number">1</span>;<br>            &#125;<br>parent[rooty] = rootx;<br>            count--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span><br>    </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><br>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; grid)</span><br>    </span>&#123;<br>        <span class="hljs-keyword">int</span> nr = grid.size();<br>        <span class="hljs-keyword">int</span> nc = grid[<span class="hljs-number">0</span>].size();<br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(grid)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; nr; r++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; nc; c++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(grid[r][c] == <span class="hljs-string">'1'</span>)<br>                &#123;<br>                    grid[r][c] = <span class="hljs-string">'0'</span>;<br>                    <span class="hljs-keyword">if</span>(r - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[r - <span class="hljs-number">1</span>][c] == <span class="hljs-string">'1'</span>) uf.unite(r * nc + c, (r - <span class="hljs-number">1</span>) * nc + c);<br>                    <span class="hljs-keyword">if</span>(r + <span class="hljs-number">1</span> &lt; nr &amp;&amp; grid[r + <span class="hljs-number">1</span>][c] == <span class="hljs-string">'1'</span>) uf.unite(r * nc + c, (r + <span class="hljs-number">1</span>) * nc + c);<br>                    <span class="hljs-keyword">if</span>(c - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[r][c - <span class="hljs-number">1</span>] == <span class="hljs-string">'1'</span>) uf.unite(r * nc + c, r * nc + c - <span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">if</span>(c + <span class="hljs-number">1</span> &lt; nc &amp;&amp; grid[r][c + <span class="hljs-number">1</span>] == <span class="hljs-string">'1'</span>) uf.unite(r * nc + c, r * nc + c + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uf.getCount();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="206-翻转链表"><a href="#206-翻转链表" class="headerlink" title="206. 翻转链表"></a>206. 翻转链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 递归</span><br><span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span><br></span>&#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    ListNode* ret = reverseList(head-&gt;next);<br>    head-&gt;next-&gt;next = head;<br>    head-&gt;next = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><span class="hljs-comment">// 双指针迭代</span><br><span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span><br></span>&#123;<br>    ListNode* pre = head;<br>    ListNode* cur = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span>(pre != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        ListNode* p = pre-&gt;next;<br>        pre-&gt;next = cur;<br>        cur = pre;<br>        pre = p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cur;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="208-实现Trie-前缀树"><a href="#208-实现Trie-前缀树" class="headerlink" title="208. 实现Trie(前缀树)"></a>208. 实现Trie(前缀树)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span><br>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">bool</span> isEnd;<br>    Trie* next[<span class="hljs-number">26</span>];<br><span class="hljs-keyword">public</span>:<br>    Trie()<br>    &#123;<br>        isEnd = <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">memset</span>(next, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(next));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-built_in">string</span> word)</span><br>    </span>&#123;<br>        Trie* node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : word)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(node-&gt;next[c - <span class="hljs-string">'a'</span>] == <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                node-&gt;next[c - <span class="hljs-string">'a'</span>] = <span class="hljs-keyword">new</span> Trie();<br>            &#125;<br>            node = node-&gt;next[c - <span class="hljs-string">'a'</span>];<br>        &#125;<br>        node-&gt;isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-built_in">string</span> word)</span><br>    </span>&#123;<br>        Trie* node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : word)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(node-&gt;next[c - <span class="hljs-string">'a'</span>] == <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            node = node-&gt;next[c - <span class="hljs-string">'a'</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> node-&gt;isEnd;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(<span class="hljs-built_in">string</span> prefix)</span><br>    </span>&#123;<br>        Trie* node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : prefix)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(node-&gt;next[c - <span class="hljs-string">'a'</span>] == <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            node = node-&gt;next[c - <span class="hljs-string">'a'</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="739-每日温度（每天找下一个比今天更高的温度）"><a href="#739-每日温度（每天找下一个比今天更高的温度）" class="headerlink" title="739. 每日温度（每天找下一个比今天更高的温度）"></a>739. 每日温度（每天找下一个比今天更高的温度）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dailyTemperature</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; T)</span><br></span>&#123;<br>    <span class="hljs-keyword">int</span> n = T.size();<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ret</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; stk;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(!stk.empty() &amp;&amp; T[i] &gt; T[stk.top()])<br>        &#123;<br>            <span class="hljs-keyword">int</span> prevIndex = stk.top();<br>            ret[prevIndex] = i - prevIndex;<br>            stk.pop();<br>        &#125;<br>        stk.push(i);<br>    &#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-两数之和（为目标值）-3min&quot;&gt;&lt;a href=&quot;#1-两数之和（为目标值）-3min&quot; class=&quot;headerlink&quot; title=&quot;1. 两数之和（为目标值）   3min&quot;&gt;&lt;/a&gt;1. 两数之和（为目标值）   3min&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs c++&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;twoSum&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; nums, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; target)&lt;/span&gt;&lt;br&gt;&lt;/span&gt;&amp;#123;&lt;br&gt;    umordered_map&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt; hashtable;&lt;br&gt;    &lt;span class=&quot;hljs-comment&quot;&gt;/* xiaoguo */&lt;/span&gt;&lt;br&gt;    &lt;br&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; nums.size(); i++)&lt;br&gt;    &amp;#123;&lt;br&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; it = hashtable.find(target - nums[i]);&lt;br&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(it != hashtable.end())&lt;br&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &amp;#123;it-&amp;gt;second, i&amp;#125;;&lt;br&gt;        hashtable[nums[i]] = i;&lt;br&gt;    &amp;#125;&lt;br&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&amp;#125;;&lt;br&gt;&amp;#125;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>哈希专题</title>
    <link href="https://chasencenge.github.io/2020/10/29/%E5%93%88%E5%B8%8C%E4%B8%93%E9%A2%98/"/>
    <id>https://chasencenge.github.io/2020/10/29/哈希专题/</id>
    <published>2020-10-29T06:07:49.000Z</published>
    <updated>2020-12-28T08:56:55.493Z</updated>
    
    <content type="html"><![CDATA[<h4 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a>49. 字母异位词分组</h4><p>如何将异位词分到一组？</p><p>对于每个字符串，对其进行字典排序，利用排序后的string作为map的key，将排序前的string推到value中</p><p>用到的数据结构为：unordered_map&lt;string, vector<string>&gt; mp</string></p><p>最后将mp中的每个元素的second push_back到结果集ret中</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;49-字母异位词分组&quot;&gt;&lt;a href=&quot;#49-字母异位词分组&quot; class=&quot;headerlink&quot; title=&quot;49. 字母异位词分组&quot;&gt;&lt;/a&gt;49. 字母异位词分组&lt;/h4&gt;&lt;p&gt;如何将异位词分到一组？&lt;/p&gt;
&lt;p&gt;对于每个字符串，对其进行字典排序，利用排序后的string作为map的key，将排序前的string推到value中&lt;/p&gt;
&lt;p&gt;用到的数据结构为：unordered_map&amp;lt;string, vector&lt;string&gt;&amp;gt; mp&lt;/string&gt;&lt;/p&gt;
&lt;p&gt;最后将mp中的每个元素的second push_back到结果集ret中&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>特殊技巧专题</title>
    <link href="https://chasencenge.github.io/2020/10/29/%E7%89%B9%E6%AE%8A%E6%8A%80%E5%B7%A7%E4%B8%93%E9%A2%98/"/>
    <id>https://chasencenge.github.io/2020/10/29/特殊技巧专题/</id>
    <published>2020-10-29T05:15:00.000Z</published>
    <updated>2020-12-28T12:32:33.350Z</updated>
    
    <content type="html"><![CDATA[<h4 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a>48. 旋转图像</h4><p>对矩阵的<strong>原地</strong>旋转操作可通过转置并翻转来实现</p><p>本题要求完成90°旋转，可先求转置，再对每一行进行翻转</p><p>如果要旋转180°，可以先对列翻转，再对行翻转</p><p>如果要逆时针旋转90°，则先求转置，再对列进行翻转</p><a id="more"></a><h4 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29. 顺时针打印矩阵"></a>29. 顺时针打印矩阵</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">处理移动四个移动方向用：<br>vector&lt;vector&lt;int&gt;&gt; move&#123; &#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125; &#125;;<br>或者：<br>static constexpr int directions[4][2] = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;<br>标记矩阵的已访问元素和未访问元素用一个相同大小的bool矩阵visit<br>输入一个空matrix时，如果对其求matrix[0].size()会报错，因为没有matrix[0]<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; order;<br><br>    <span class="hljs-keyword">if</span> (matrix.size() == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].size() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> rowRange = matrix.size();<br>    <span class="hljs-keyword">int</span> colRange = matrix[<span class="hljs-number">0</span>].size();<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-title">visit</span><span class="hljs-params">(rowRange, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(colRange))</span></span>;<br>    <span class="hljs-keyword">int</span> total = rowRange * colRange;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; move&#123; &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125; &#125;;<br>    <span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> moveIndex = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> nextRow, nextCol;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; total; i++)<br>    &#123;<br>        order.push_back(matrix[row][col]);<br>        visit[row][col] = <span class="hljs-literal">true</span>;<br>        nextRow = row + move[moveIndex][<span class="hljs-number">0</span>];<br>        nextCol = col + move[moveIndex][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (nextRow &gt;= rowRange || nextRow &lt; <span class="hljs-number">0</span> || nextCol &gt;= colRange || nextCol &lt; <span class="hljs-number">0</span> || visit[nextRow][nextCol])<br>        &#123;<br>            moveIndex = (moveIndex + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;<br>        &#125;<br>        row += move[moveIndex][<span class="hljs-number">0</span>];<br>        col += move[moveIndex][<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> order;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a>56. 合并区间</h4><p>先按区间左边界进行升序排序</p><p>每次检查是否能合并时，比较：当前区间的左边界和结果集合中最后一个区间的右边界</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(intervals[i][<span class="hljs-number">0</span>] &lt;= ret.back()[<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p>如果当前区间左边界小于结果集合中最后一个区间的右边界，说明区间重叠，修改当前区间的右边界，选择当前比较的两个区间的右边界中的较大值作为新的右边界</p><p>如果不能合并，在结果集合ret中push_back当前检查的区间</p><h4 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a>62. 不同路径</h4><p>求只能往右或者往下走的全路径：排列组合中的组合</p><p>尽可能的防止溢出，每次循环中更新完分子和分母后，都用分子和分母分别除以公约数</p><p>公约数计算方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span>   <br>    </span>&#123;<br>        <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : gcd(b, a % b);<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;48-旋转图像&quot;&gt;&lt;a href=&quot;#48-旋转图像&quot; class=&quot;headerlink&quot; title=&quot;48. 旋转图像&quot;&gt;&lt;/a&gt;48. 旋转图像&lt;/h4&gt;&lt;p&gt;对矩阵的&lt;strong&gt;原地&lt;/strong&gt;旋转操作可通过转置并翻转来实现&lt;/p&gt;
&lt;p&gt;本题要求完成90°旋转，可先求转置，再对每一行进行翻转&lt;/p&gt;
&lt;p&gt;如果要旋转180°，可以先对列翻转，再对行翻转&lt;/p&gt;
&lt;p&gt;如果要逆时针旋转90°，则先求转置，再对列进行翻转&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>栈和队列专题</title>
    <link href="https://chasencenge.github.io/2020/10/29/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E4%B8%93%E9%A2%98/"/>
    <id>https://chasencenge.github.io/2020/10/29/栈和队列专题/</id>
    <published>2020-10-29T05:14:13.000Z</published>
    <updated>2020-12-28T08:57:06.498Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>树专题</title>
    <link href="https://chasencenge.github.io/2020/10/28/%E6%A0%91%E5%9B%BE%E4%B8%93%E9%A2%98/"/>
    <id>https://chasencenge.github.io/2020/10/28/树图专题/</id>
    <published>2020-10-28T11:50:18.000Z</published>
    <updated>2020-12-28T07:01:51.738Z</updated>
    
    <content type="html"><![CDATA[<h4 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a>207. 课程表</h4><p>我们可以将本题建模成一个求拓扑排序的问题：将每一门课看成一个节点，如果想要学习课程 A之前必须完成课程 B，那么我们从B到A连接一条有向边。这样以来，在拓扑排序中，B一定出现在 A的前面</p><a id="more"></a><p><strong>思路：</strong></p><p>考虑拓扑排序中最前面的节点，该节点一定不会有任何入边，也就是它没有任何的先修课程要求。当我们将一个节点加入答案中后，我们就可以移除它的所有出边，代表着它的相邻节点少了一门先修课程的要求。如果某个相邻节点变成了「没有任何入边的节点」，那么就代表着这门课可以开始学习了。按照这样的流程，我们不断地将没有入边的节点加入答案，直到答案中包含所有的节点（得到了一种拓扑排序）或者不存在没有入边的节点（图中包含环）</p><p><strong>算法：</strong></p><p>使用一个队列来进行广度优先搜索。初始时，所有入度为 00 的节点都被放入队列中，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。</p><p>在广度优先搜索的每一步中，我们取出队首的节点u：</p><p>我们将u放入答案中</p><p>我们移除 u的所有出边，也就是将u的所有相邻节点的入度减少1。如果某个相邻节点v的入度变为0，那么我们就将v放入队列中</p><p>在广度优先搜索的过程结束后。如果答案中包含了这n个节点，那么我们就找到了一种拓扑排序，否则说明图中存在环，也就不存在拓扑排序了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numCourses, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br>    <span class="hljs-comment">//入度 in degree</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; indeg;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; edges;<br>    <span class="hljs-comment">//resize内的默认初始化值为0</span><br>    indeg.resize(numCourses);<br>    edges.resize(numCourses);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; info : prerequisites)<br>    &#123;<br>        <span class="hljs-comment">//以info[1]为起始的边，指向info[0]</span><br>        edges[info[<span class="hljs-number">1</span>]].push_back(info[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">//info[0]的入度加一，指向它的是info[1]</span><br>        ++indeg[info[<span class="hljs-number">0</span>]];<br>    &#125;<br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++)<br>    &#123;<br>        <span class="hljs-comment">//把最开始入度为0的点push进去</span><br>        <span class="hljs-keyword">if</span> (indeg[i] == <span class="hljs-number">0</span>)<br>        &#123;<br>            q.push(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> visited = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!q.empty())<br>    &#123;<br>        visited++;<br>        <span class="hljs-keyword">int</span> u = q.front();<br>        q.pop();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v : edges[u])<br>        &#123;<br>            --indeg[v];<br>            <span class="hljs-comment">//如果去掉指向它的u之后，v点的入度变为0，那么push进队列</span><br>            <span class="hljs-keyword">if</span> (indeg[v] == <span class="hljs-number">0</span>)<br>            &#123;<br>                q.push(v);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> visited == numCourses;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-字符串转换整数"><a href="#8-字符串转换整数" class="headerlink" title="8. 字符串转换整数"></a>8. 字符串转换整数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 有限自动机，写一个有限自动机类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Automation</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; table = &#123;<br>        &#123;<span class="hljs-string">"start"</span>, &#123;<span class="hljs-string">"start"</span>, <span class="hljs-string">"signed"</span>, <span class="hljs-string">"in_number"</span>, <span class="hljs-string">"end"</span>&#125;&#125;,<br>        &#123;<span class="hljs-string">"signed"</span>, &#123;<span class="hljs-string">"end"</span>, <span class="hljs-string">"end"</span>, <span class="hljs-string">"in_number"</span>, <span class="hljs-string">"end"</span>&#125;&#125;,<br>        &#123;<span class="hljs-string">"in_number"</span>, &#123;<span class="hljs-string">"end"</span>, <span class="hljs-string">"end"</span>, <span class="hljs-string">"in_number"</span>, <span class="hljs-string">"end"</span>&#125;&#125;,<br>        &#123;<span class="hljs-string">"end"</span>, &#123;<span class="hljs-string">"end"</span>, <span class="hljs-string">"end"</span>, <span class="hljs-string">"end"</span>, <span class="hljs-string">"end"</span>&#125;&#125;<br>    &#125;;<br>    <span class="hljs-built_in">string</span> status = <span class="hljs-string">"start"</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_col</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span><br>    </span>&#123;<br>        <span class="hljs-keyword">if</span>(c == <span class="hljs-string">' '</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(c == <span class="hljs-string">'+'</span> || c == <span class="hljs-string">'-'</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isdigit</span>(c))<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> sign = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span><br>    </span>&#123;<br>        status = table[status][get_col(c)];<br>        <span class="hljs-keyword">if</span>(status == <span class="hljs-string">"in_number"</span>)<br>        &#123;<br>            res =  res * <span class="hljs-number">10</span> + (c - <span class="hljs-string">'0'</span>);<br>            res = sign == <span class="hljs-number">1</span> ? min(res, (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)INT_MAX) : min(res, -(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)INT_MIN);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(status == <span class="hljs-string">"signed"</span>)<br>        &#123;<br>            sign = c == <span class="hljs-string">'+'</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str)</span> </span>&#123;<br>        Automation atmn;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : str)<br>        &#123;<br>            atmn.get(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> atmn.sign * atmn.res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id><a href="#" class="headerlink" title></a></h4>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;207-课程表&quot;&gt;&lt;a href=&quot;#207-课程表&quot; class=&quot;headerlink&quot; title=&quot;207. 课程表&quot;&gt;&lt;/a&gt;207. 课程表&lt;/h4&gt;&lt;p&gt;我们可以将本题建模成一个求拓扑排序的问题：将每一门课看成一个节点，如果想要学习课程 A之前必须完成课程 B，那么我们从B到A连接一条有向边。这样以来，在拓扑排序中，B一定出现在 A的前面&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>空间换时间专题</title>
    <link href="https://chasencenge.github.io/2020/10/28/%E7%A9%BA%E9%97%B4%E6%8D%A2%E6%97%B6%E9%97%B4%E4%B8%93%E9%A2%98/"/>
    <id>https://chasencenge.github.io/2020/10/28/空间换时间专题/</id>
    <published>2020-10-28T11:49:39.000Z</published>
    <updated>2020-12-28T12:33:01.703Z</updated>
    
    <content type="html"><![CDATA[<h4 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h4><p>此题首先需知如何计算总雨水量：</p><p>总雨水量的计算需知数组中的每个数左侧和右侧的最高值，取二者较小值减去当前高度，即为当前点处能蓄水的量</p><p>如果不用空间换时间，计算每个点左右两侧的最大值都需要遍历一次所有数据</p><p>所以用两个数组leftMax和rightMax分别存储每个点左侧的最大值和右侧的最大值</p><p>最后再一次遍历计算总蓄水量</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;42-接雨水&quot;&gt;&lt;a href=&quot;#42-接雨水&quot; class=&quot;headerlink&quot; title=&quot;42. 接雨水&quot;&gt;&lt;/a&gt;42. 接雨水&lt;/h4&gt;&lt;p&gt;此题首先需知如何计算总雨水量：&lt;/p&gt;
&lt;p&gt;总雨水量的计算需知数组中的每个数左侧和右侧的最高值，取二者较小值减去当前高度，即为当前点处能蓄水的量&lt;/p&gt;
&lt;p&gt;如果不用空间换时间，计算每个点左右两侧的最大值都需要遍历一次所有数据&lt;/p&gt;
&lt;p&gt;所以用两个数组leftMax和rightMax分别存储每个点左侧的最大值和右侧的最大值&lt;/p&gt;
&lt;p&gt;最后再一次遍历计算总蓄水量&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lambda表达式</title>
    <link href="https://chasencenge.github.io/2020/10/25/C-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://chasencenge.github.io/2020/10/25/C-Lambda表达式/</id>
    <published>2020-10-25T09:01:24.000Z</published>
    <updated>2020-12-28T12:28:48.792Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lambda申明方式"><a href="#Lambda申明方式" class="headerlink" title="Lambda申明方式"></a>Lambda申明方式</h1><p>Lambda表达式允许在函数内部创建一个匿名函数</p><h3 id="声明方式：-captrues-params-gt-ret-Statements"><a href="#声明方式：-captrues-params-gt-ret-Statements" class="headerlink" title="声明方式：[captrues(params) -&gt;ret {Statements};"></a>声明方式：[captrues(params) -&gt;ret {Statements};</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> fadd = [](<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)<br>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;; <span class="hljs-comment">// 注意最后有分号</span><br></code></pre></td></tr></table></figure><p>[]表示开始定定义Lambda表达式，()里面是函数的参数 ，{}里面是函数体</p><a id="more"></a><h3 id="显示指明返回值："><a href="#显示指明返回值：" class="headerlink" title="显示指明返回值："></a>显示指明返回值：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> fadd = [](<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) -&gt; ret<br>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="Lambda表达式的变量截取"><a href="#Lambda表达式的变量截取" class="headerlink" title="Lambda表达式的变量截取"></a>Lambda表达式的变量截取</h1><p>[] 不截取任何变量</p><p>[&amp;] 截取外部作用域的所有变量，并作为引用在函数体中使用</p><p>[=] 截取外部作用域中的所有变量，并拷贝一份在函数体中使用</p><p>[=, &amp;foo] 截取外部作用域中所有变量并拷贝一份在函数体中使用，但对foo变量使用引用</p><p>[bar] 截取bar变量并拷贝一份在函数体使用，不截取其他变量</p><p>[this] 截取当前类中的指针</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Lambda申明方式&quot;&gt;&lt;a href=&quot;#Lambda申明方式&quot; class=&quot;headerlink&quot; title=&quot;Lambda申明方式&quot;&gt;&lt;/a&gt;Lambda申明方式&lt;/h1&gt;&lt;p&gt;Lambda表达式允许在函数内部创建一个匿名函数&lt;/p&gt;
&lt;h3 id=&quot;声明方式：-captrues-params-gt-ret-Statements&quot;&gt;&lt;a href=&quot;#声明方式：-captrues-params-gt-ret-Statements&quot; class=&quot;headerlink&quot; title=&quot;声明方式：[captrues(params) -&amp;gt;ret {Statements};&quot;&gt;&lt;/a&gt;声明方式：[captrues(params) -&amp;gt;ret {Statements};&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs c++&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; fadd = [](&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; b)&lt;br&gt;&amp;#123;&lt;br&gt;	&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a + b;&lt;br&gt;&amp;#125;; &lt;span class=&quot;hljs-comment&quot;&gt;// 注意最后有分号&lt;/span&gt;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;[]表示开始定定义Lambda表达式，()里面是函数的参数 ，{}里面是函数体&lt;/p&gt;
    
    </summary>
    
    
      <category term="cpp" scheme="https://chasencenge.github.io/categories/cpp/"/>
    
    
      <category term="cpp" scheme="https://chasencenge.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>双指针专题</title>
    <link href="https://chasencenge.github.io/2020/10/16/%E5%8F%8C%E6%8C%87%E9%92%88%E4%B8%93%E9%A2%98/"/>
    <id>https://chasencenge.github.io/2020/10/16/双指针专题/</id>
    <published>2020-10-15T16:08:03.000Z</published>
    <updated>2020-12-28T12:32:41.452Z</updated>
    
    <content type="html"><![CDATA[<h4 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a>16. 最接近的三数之和</h4><p>相对于暴力解法，双指针能够通过首尾指针和合理移动，减少不合理情况的遍历，即a+b+c &lt; target，则c向左移动，a+b+c &gt; target，b向右移动</p><p>进一步可以总结出：<strong>若想要使两数之和逼近某一个目标值</strong>，可使用双指针对已排序数组进行查找</p><a id="more"></a><p><strong>对已排序数组的遍历时跳过重复值</strong>的通用优化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> p0 = p + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(nums[p0] == nums[p] &amp;&amp; p0 &lt; q)<br>    p0++;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">threeSumClosest</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1e7</span>;<br>    <span class="hljs-keyword">int</span> n = nums.size();<br>    sort(nums.begin(), nums.end());<br>    <span class="hljs-keyword">int</span> sum;<br>    <span class="hljs-keyword">auto</span> update = [&amp;](<span class="hljs-keyword">int</span> cur)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(cur - target) &lt; <span class="hljs-built_in">abs</span>(ans - target))<br>        &#123;<br>            ans = cur;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">2</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>])<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">int</span> p = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> q = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(p &lt; q)<br>        &#123;<br>            sum = nums[i] + nums[p] + nums[q];<br>            <span class="hljs-keyword">if</span>(sum == target)<br>            &#123;<br>                <span class="hljs-keyword">return</span> target;<br>            &#125;<br>            update(sum);<br>            <span class="hljs-keyword">if</span>(sum &lt; target)<br>            &#123;<br>                <span class="hljs-keyword">int</span> p0 = p + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span>(nums[p0] == nums[p] &amp;&amp; p0 &lt; q)<br>                    p0++;<br>                p = p0;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(sum &gt; target)<br>            &#123;<br>                <span class="hljs-keyword">int</span> q0 = q - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span>(q0 &gt; p &amp;&amp; nums[q0] == nums[q])<br>                &#123;<br>                    q0--;<br>                &#125;<br>                q = q0;<br>            &#125;<br><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a>19. 删除链表的倒数第N个节点</h4><h5 id="怎样一次遍历找到倒数第N个节点？"><a href="#怎样一次遍历找到倒数第N个节点？" class="headerlink" title="怎样一次遍历找到倒数第N个节点？"></a>怎样一次遍历找到倒数第N个节点？</h5><p>双指针，前面的指针在后面的指针前N+1的位置，同步前进，然后当前面的指针指到nullptr时，后面的指针处于倒数N+1位置，这时令：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">p-&gt;next = p-&gt;next-&gt;next;<br></code></pre></td></tr></table></figure><h5 id="怎样保证最后返回正确的头节点？（原链表的头节点可能被删除）"><a href="#怎样保证最后返回正确的头节点？（原链表的头节点可能被删除）" class="headerlink" title="怎样保证最后返回正确的头节点？（原链表的头节点可能被删除）"></a>怎样保证最后返回正确的头节点？（原链表的头节点可能被删除）</h5><p>开始时在head前new一个节点hair：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">ListNode* hair = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>, head); <span class="hljs-comment">// (val, next)</span><br></code></pre></td></tr></table></figure><p>最后返回hair-&gt;next</p><h4 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a>18. 四数之和</h4><p>先将数组用sort()进行排序</p><p>双重循环遍历前两个数，后两个数分配双指针一前一后</p><p>外面双重循环：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n<span class="hljs-number">-3</span>; i++)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>; j &lt; n<span class="hljs-number">-2</span>; j++)<br>&#123;<br>......<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>双指针起始位置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> p = j + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> q = n - <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>剪枝操作：</p><p>在外层的两重循环中分别做如下几种情况的剪枝：</p><p>当前值nums[i]与上一个值nums[i-1]相同时，continue</p><p>当前值nums[i]加上后面连续三个数nums[i+1], nums[i+2], nums[i+3]的和大于target，则之后不论如何取值都一定大于target，直接跳出循环break</p><p>当前值nums[i]加上倒数三个最大的值nums[n-1], nums[n-2], nums[n-3]的和小于target，说明以nums[i]起始的任意四个数的和均小于target，跳出本次循环continue</p><p>对于第二层循环做类似的三种情况的剪枝处理</p><h4 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a>415. 字符串相加</h4><p>实现两个字符串的数值相加，不能用类型转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">addStrings</span><span class="hljs-params">(<span class="hljs-built_in">string</span> num1, <span class="hljs-built_in">string</span> num2)</span> </span>&#123;<br>    <span class="hljs-comment">//双指针，双指针的“指针”不一定非得是指针类型，能做flag标记就行</span><br><span class="hljs-keyword">int</span> i = num1.length() - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> j = num2.length() - <span class="hljs-number">1</span>;<br><span class="hljs-built_in">string</span> res;<br><span class="hljs-keyword">int</span> multi = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//进位</span><br><span class="hljs-keyword">int</span> add = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span> || add &gt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>)<br>&#123;<br>            <span class="hljs-comment">//两者相减得到的是int型</span><br>x = num1[i] - <span class="hljs-string">'0'</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (j &gt;= <span class="hljs-number">0</span>)<br>&#123;<br>y = num2[j] - <span class="hljs-string">'0'</span>;<br>&#125;<br><span class="hljs-keyword">int</span> result = x + y + add;<br>res.push_back(<span class="hljs-string">'0'</span> + result % <span class="hljs-number">10</span>);<br>add = result / <span class="hljs-number">10</span>;<br>i--;<br>j--;<br>&#125;<br>    <span class="hljs-comment">//因为每次push_back是从低位到高位的，所以结果要翻转</span><br>reverse(res.begin(), res.end());<br><span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a>75. 颜色分类</h4><p>数组中只有0，1，2三种值，对其排序的方式：</p><p>双指针p0和p2，p0用于交换0，p2用于交换2</p><p>p0 = 0，p2 = n - 1</p><p>一次遍历，当前值如果为0，交换当前位置和p0位置的值，当前值如果为2，和p2交换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 这里while的使用要注意，对照输入[2,1,2]</span><br><span class="hljs-keyword">while</span>(i &lt;= p2 &amp;&amp; nums[i] == <span class="hljs-number">2</span>)<br>&#123;<br>    swap(nums[i], nums[p2]);<br>    --p2;<br>&#125;<br><span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>)<br>&#123;<br>    swap(nums[i], nums[p0]);<br>    ++p0;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;16-最接近的三数之和&quot;&gt;&lt;a href=&quot;#16-最接近的三数之和&quot; class=&quot;headerlink&quot; title=&quot;16. 最接近的三数之和&quot;&gt;&lt;/a&gt;16. 最接近的三数之和&lt;/h4&gt;&lt;p&gt;相对于暴力解法，双指针能够通过首尾指针和合理移动，减少不合理情况的遍历，即a+b+c &amp;lt; target，则c向左移动，a+b+c &amp;gt; target，b向右移动&lt;/p&gt;
&lt;p&gt;进一步可以总结出：&lt;strong&gt;若想要使两数之和逼近某一个目标值&lt;/strong&gt;，可使用双指针对已排序数组进行查找&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>UE学习文档</title>
    <link href="https://chasencenge.github.io/2020/10/12/UE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://chasencenge.github.io/2020/10/12/UE学习笔记/</id>
    <published>2020-10-12T08:43:46.000Z</published>
    <updated>2021-01-02T02:44:14.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UE4源码编译"><a href="#UE4源码编译" class="headerlink" title="UE4源码编译"></a>UE4源码编译</h1><p>git clone源码</p><p>运行Setup.bat下载依赖文件</p><p>运行GenerateProjectFiles.bat生成工程文件</p><p>运行UE.sln</p><p>在vs打开的工程中，最上方的解决方案配置设置为Development Editor，启动项目设置为UE4，平台WIN64，右键UE4 – Build进行编译</p><p>编译完成后按F5在vs中启动</p><p><strong>注意</strong></p><p>生成工程文件前可能会报错，根据报错信息可判断是否缺少相应的.NET Framework，如果缺少在vs installer中选中相应版本的vs – 修改 – 添加相应的.NET工具</p><p>Epic Game Launcher中不能识别非公版的引擎，向编译版的引擎创建的工程中添加保管库中的素材时，点击添加到工程–显示所有工程–为相应工程手动选择对应的版本号即可添加素材（因为又编译版引擎创建的工程在Launcher中显示的版本标识为“其他”，不选择相应的版本号则素材或插件都会显示不兼容）</p><a id="more"></a><h1 id="项目打包"><a href="#项目打包" class="headerlink" title="项目打包"></a>项目打包</h1><h2 id="项目打包注意事项"><a href="#项目打包注意事项" class="headerlink" title="项目打包注意事项"></a>项目打包注意事项</h2><h3 id="启动地图"><a href="#启动地图" class="headerlink" title="启动地图"></a>启动地图</h3><p>构建项目时会从游戏默认地图开始，需要点击Project Settings — Maps &amp; Modes 设置game default map</p><p><img src="/2020/10/12/UE学习笔记/map.png" alt="设置启动地图"></p><h3 id="选择目标平台"><a href="#选择目标平台" class="headerlink" title="选择目标平台"></a>选择目标平台</h3><p><img src="/2020/10/12/UE学习笔记/platform.png" alt="设置平台"></p><p>还要记得选择目标硬件(Target Hardware)</p><h3 id="编辑器查看方式"><a href="#编辑器查看方式" class="headerlink" title="编辑器查看方式"></a>编辑器查看方式</h3><p><img src="/2020/10/12/UE学习笔记/editorview.png" alt="选择编辑器视口"></p><h3 id="细化平台性能控制"><a href="#细化平台性能控制" class="headerlink" title="细化平台性能控制"></a>细化平台性能控制</h3><p><img src="/2020/10/12/UE学习笔记/deviceprofile.png" alt="查看和修改设备描述"></p><p>打开Device Profiles以后点击想要修改的设备型号后面的扳手即可对其值进行修改</p><p><img src="/2020/10/12/UE学习笔记/everydevice.png" alt="对其修改"></p><h2 id="Android设置和打包方式"><a href="#Android设置和打包方式" class="headerlink" title="Android设置和打包方式"></a>Android设置和打包方式</h2><h3 id="设置方式"><a href="#设置方式" class="headerlink" title="设置方式"></a>设置方式</h3><p>寻找UE4 Android Works文件夹，一般默认为C:/Program Files/Epic Games/UE_4_版本/Engine/Extras/Android Works/Win64</p><p>安装后可看到CodeWorks Manager窗口</p><p>在手机端，有时需找到usb driver才能使用，一般连数据线即可</p><p><a href="http://developer.android.com/tools/extras/oem-usb.html" target="_blank" rel="noopener">http://developer.android.com/tools/extras/oem-usb.html</a></p><p>解锁设备时要开启开发者模式，开启usb调试</p><p>在设置主页找到“已连接设备”选择启用文件传输</p><p>在电脑上cmd输入adb devices，如果列出了自己的手机设备名，则准备就绪</p><p><strong>注意：</strong></p><p>手机开发者选项中不但需开启USB调试，还打开USB安装，允许通过USB安装应用</p><h3 id="打包方式"><a href="#打包方式" class="headerlink" title="打包方式"></a>打包方式</h3><p>为了更准确的测试，使用Play – Mobile Preview</p><p><img src="/2020/10/12/UE学习笔记/MobilePreview.png" alt="模拟移动端测试"></p><p><strong>退出游戏方式：</strong> “~”打开控制台，输入quit game</p><p><strong>确保项目做好准备：</strong></p><p>Settings – Project Settings – Platforms – Android </p><p>页面顶部会有警告称项目尚未对Android完成配置，点击configure now</p><p>设置文件包名称，格式为：com.MyGameCompany.MyCoolGame</p><p>并完成项目命名</p><p>如果要计划使用Google Play服务，向下滚动到Google Play Services并点击Configure Now，以将平台构建到游戏中</p><p><img src="/2020/10/12/UE学习笔记/GooglePlayServices.png" alt="计划使用Google Play服务"></p><p><strong>构建到设备：</strong></p><p><img src="/2020/10/12/UE学习笔记/toDivice.png" alt="构建到设备"></p><p>测试并部署到自己的设备很方便，如果需要部署到其他设备，需打包</p><p><img src="/2020/10/12/UE学习笔记/package.png" alt="打包"></p><p>双击生成的.bat项目可以将其安装到自己的Android设备上</p><p><strong>注意</strong></p><p>记得在项目设置 – Android勾选将游戏数据打包至.apk中</p><h1 id="UE4游戏框架"><a href="#UE4游戏框架" class="headerlink" title="UE4游戏框架"></a>UE4游戏框架</h1><p> 游戏架构的基类是GameMode，设置游戏规则，也分则处理生成玩家</p><h3 id="Pawn"><a href="#Pawn" class="headerlink" title="Pawn"></a>Pawn</h3><p>作为世界中的一个“代理”Actor，可由控制器处理 ，可接收输入并且可执行各种各样类似于玩家的动作（但不假定Pawn就是类人的）</p><h3 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h3><p>类人的Pawn，本身默认具有用于碰撞的CapsuleComponent（胶囊体组件）和CharacterMovementComponent（角色运动组件）；可进行基本的拟人运动、平滑地在网格上复制运动，并具有一些动画相关的功能</p><h3 id="控制Pawn"><a href="#控制Pawn" class="headerlink" title="控制Pawn"></a>控制Pawn</h3><p>Controller负责管理Pawn的Actor，一般分为PlayerController和AIController，控制器可以“具有”一个Pawn并控制它</p><h3 id="HUD"><a href="#HUD" class="headerlink" title="HUD"></a>HUD</h3><p>平视显示信息</p><h3 id="GameMode"><a href="#GameMode" class="headerlink" title="GameMode"></a>GameMode</h3><p>游戏的定义，包括像游戏规则和获胜条件这样的内容；仅存在于服务器上，一般在游戏过程中不会有太多数据改变，并且一定不会具有客户端需要的临时数据</p><h3 id="GameState"><a href="#GameState" class="headerlink" title="GameState"></a>GameState</h3><p>包含游戏状态，包括像关联玩家的列表、分数、象棋游戏中的棋子位置或在开放世界中已经完成的任务列表</p><p>存在于服务器和所有客户端上，可以自由地进行复制来保持同步</p><h3 id="PlayerState"><a href="#PlayerState" class="headerlink" title="PlayerState"></a>PlayerState</h3><p>表示游戏中一个参与者的状态（AI没有PlayerState），适合包含的实例数据有：玩家姓名，分数，多人在线竞技场比赛中的级别，夺旗模式游戏中玩家当前是否占领旗帜</p><p>所有玩家的PlayerStates在所有的机器上都存在，并且可以自由复制包持同步</p><h1 id="UE-C"><a href="#UE-C" class="headerlink" title="UE C++"></a>UE C++</h1><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><p>派生自<code>Actor</code>的类前缀为A</p><p>派生自<code>Object</code>的类前缀为U</p><p>派生自<code>Swidget</code>（Slate UI）的类前缀为S</p><p><code>Enums</code>的类前缀为E</p><p><code>Interface</code>类的前缀通常为I</p><p><code>Template</code>类的前缀为T</p><p>其余类的前缀均为F</p><p>布尔值用b前缀</p><p>全局元素用G前缀</p><p>输入参数用In前缀</p><p>输出参数用Out前缀</p><h2 id="在API文档寻找类或函数"><a href="#在API文档寻找类或函数" class="headerlink" title="在API文档寻找类或函数"></a>在API文档寻找类或函数</h2><p>进入UE4文档 –&gt; Unreal Engine API Reference –&gt; Contents</p><p>Contents下面点击All classes或者All Functions查看所有的类和函数</p><h2 id="防止头文件被编译多次的两种方法"><a href="#防止头文件被编译多次的两种方法" class="headerlink" title="防止头文件被编译多次的两种方法"></a>防止头文件被编译多次的两种方法</h2><p>（1）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta"># <span class="hljs-meta-keyword">ifndef</span> _SOMEFILE_H_</span><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> _SOMEFILE_H_</span><br>......<br><span class="hljs-meta"># <span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>（2）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta"># <span class="hljs-meta-keyword">pragma</span> once</span><br></code></pre></td></tr></table></figure><h2 id="UCLASS"><a href="#UCLASS" class="headerlink" title="UCLASS()"></a>UCLASS()</h2><p>UCLASS 宏（在头文件）可用于标记从 <code>UObject</code> 派生的类，使 UObject 处理系统识别到它们</p><p>GENERATED_BODY 宏不获取参数，但会对类进行设置，以支持引擎要求的基础结构。所有 UCLASS 均有此要求</p><h2 id="UPROPERTY"><a href="#UPROPERTY" class="headerlink" title="UPROPERTY()"></a>UPROPERTY()</h2><p>为将变量公开到虚幻引擎，需使其成为 <strong>UPROPERTY</strong>。利用此操作，可在启动游戏或加载保存的关卡时保留变量的值。带有空括号的 <code>UPROPERTY</code> 标记，将被添加到受其它影响的变量正上方</p><p><code>UPROPERTY</code> 支持改变虚幻引擎使用变量方式的参数。将变量设为可编辑，可添加 <code>EditAnywhere</code> 参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">UPROPERTY(EditAnywhere)<br>int32 CountdownTime;<br></code></pre></td></tr></table></figure><p>然后该变量的修改便可在Details（细节面板）中进行</p><h2 id="UFUNCTION"><a href="#UFUNCTION" class="headerlink" title="UFUNCTION()"></a>UFUNCTION()</h2><p>UFUNCTION()宏把C++函数对反射系统公开，BlueprintCallable选项将对其蓝图虚拟机公开</p><p><strong>BlueprintCallable</strong>：该函数可以在蓝图或关卡蓝图图表中执行</p><p><strong>BlueprintImplementableEvent</strong>：此函数可以在蓝图或关卡蓝图图表内进行重载</p><p><strong>BlueprintNativeEvent</strong>：此函数将由蓝图进行重载，但同时也包含native类的执行。提供一个名称为[FunctionName]_Implementation的函数本体而非[FunctionName];自动生成的代码将包含转换程序,此程序在需要时会调用实施方式</p><h2 id="游戏客户端公开课学习文档"><a href="#游戏客户端公开课学习文档" class="headerlink" title="游戏客户端公开课学习文档"></a>游戏客户端公开课学习文档</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;UE4源码编译&quot;&gt;&lt;a href=&quot;#UE4源码编译&quot; class=&quot;headerlink&quot; title=&quot;UE4源码编译&quot;&gt;&lt;/a&gt;UE4源码编译&lt;/h1&gt;&lt;p&gt;git clone源码&lt;/p&gt;
&lt;p&gt;运行Setup.bat下载依赖文件&lt;/p&gt;
&lt;p&gt;运行GenerateProjectFiles.bat生成工程文件&lt;/p&gt;
&lt;p&gt;运行UE.sln&lt;/p&gt;
&lt;p&gt;在vs打开的工程中，最上方的解决方案配置设置为Development Editor，启动项目设置为UE4，平台WIN64，右键UE4 – Build进行编译&lt;/p&gt;
&lt;p&gt;编译完成后按F5在vs中启动&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;生成工程文件前可能会报错，根据报错信息可判断是否缺少相应的.NET Framework，如果缺少在vs installer中选中相应版本的vs – 修改 – 添加相应的.NET工具&lt;/p&gt;
&lt;p&gt;Epic Game Launcher中不能识别非公版的引擎，向编译版的引擎创建的工程中添加保管库中的素材时，点击添加到工程–显示所有工程–为相应工程手动选择对应的版本号即可添加素材（因为又编译版引擎创建的工程在Launcher中显示的版本标识为“其他”，不选择相应的版本号则素材或插件都会显示不兼容）&lt;/p&gt;
    
    </summary>
    
    
      <category term="GameDev" scheme="https://chasencenge.github.io/categories/GameDev/"/>
    
    
      <category term="UE" scheme="https://chasencenge.github.io/tags/UE/"/>
    
  </entry>
  
  <entry>
    <title>实时计算机图形学笔记</title>
    <link href="https://chasencenge.github.io/2020/10/02/%E5%AE%9E%E6%97%B6%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://chasencenge.github.io/2020/10/02/实时计算机图形学笔记/</id>
    <published>2020-10-02T12:04:03.000Z</published>
    <updated>2020-10-26T09:31:51.557Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="GameDev" scheme="https://chasencenge.github.io/categories/GameDev/"/>
    
    
      <category term="GameDev" scheme="https://chasencenge.github.io/tags/GameDev/"/>
    
  </entry>
  
  <entry>
    <title>腾讯游戏开发精粹笔记</title>
    <link href="https://chasencenge.github.io/2020/09/25/%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E7%B2%BE%E7%B2%B9%E7%AC%94%E8%AE%B0/"/>
    <id>https://chasencenge.github.io/2020/09/25/腾讯游戏开发精粹笔记/</id>
    <published>2020-09-25T06:07:13.000Z</published>
    <updated>2020-12-28T12:31:24.697Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、游戏数学"><a href="#一、游戏数学" class="headerlink" title="一、游戏数学"></a>一、游戏数学</h1><a id="more"></a><h2 id="1-基于SDF的摇杆移动"><a href="#1-基于SDF的摇杆移动" class="headerlink" title="1.基于SDF的摇杆移动"></a>1.基于SDF的摇杆移动</h2><h3 id="SDF："><a href="#SDF：" class="headerlink" title="SDF："></a>SDF：</h3><p>SDF全称Signed Distance Field（有号距离场），定义为空间中的点到形状表面的最小距离，并用正值表示点在形状外部，负值表示点在形状内部。</p><h3 id="为什么要使用SDF？"><a href="#为什么要使用SDF？" class="headerlink" title="为什么要使用SDF？"></a>为什么要使用SDF？</h3><p>空间换时间，在O(1)时间复杂度计算出是否碰撞。</p><h3 id="如何判断碰撞？"><a href="#如何判断碰撞？" class="headerlink" title="如何判断碰撞？"></a>如何判断碰撞？</h3><p>基于已有SDF信息的栅格，使用其邻近四个角的SD信息进行插值，得到当前点的SD，若SD&lt;=0, 则判定该点和碰撞物发生了碰撞。</p><h3 id="插值获得任意点的SD值："><a href="#插值获得任意点的SD值：" class="headerlink" title="插值获得任意点的SD值："></a>插值获得任意点的SD值：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//计算位置pos的SD值</span><br><span class="hljs-comment">//每个栅格的实际尺寸为grid，横向栅格数量为width</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">Sample</span><span class="hljs-params">(Vector2 pos)</span><br></span>&#123;<br>    pos = pos / grid;<br>    <span class="hljs-keyword">int</span> fx = Mathf.FloorToInt(pos.x);<br>    <span class="hljs-keyword">int</span> fy = Mathf.FloorToInt(pos.y);<br>    <span class="hljs-keyword">float</span> rx = pos.x - fx;<br>    <span class="hljs-keyword">float</span> ry = pos.y - fy;<br>    <span class="hljs-keyword">int</span> i = fy * width + fx;<br>    <span class="hljs-keyword">return</span> (sdf[i]*(<span class="hljs-number">1</span>-rx) + sdf[i+<span class="hljs-number">1</span>]*rx)*(<span class="hljs-number">1</span>-ry) + (sdf[i+width]*(<span class="hljs-number">1</span>-rx) + sdf[i+width+<span class="hljs-number">1</span>]*rx)*ry;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何实现发生碰撞后绕障碍物滑行？"><a href="#如何实现发生碰撞后绕障碍物滑行？" class="headerlink" title="如何实现发生碰撞后绕障碍物滑行？"></a>如何实现发生碰撞后绕障碍物滑行？</h3><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/1.6%E6%BB%91%E8%A1%8C.png" alt="1.6滑行"></p><p>v表示摇杆方向，与障碍物发生碰撞后需要沿着v’方向滑行，n为碰撞法线，v’和v有以上关系。</p><h4 id="如何获取碰撞法线n？"><a href="#如何获取碰撞法线n？" class="headerlink" title="如何获取碰撞法线n？"></a>如何获取碰撞法线n？</h4><p>利用SDF的梯度作为碰撞法线。</p><h4 id="求梯度方向："><a href="#求梯度方向：" class="headerlink" title="求梯度方向："></a>求梯度方向：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">public</span> Vector2 <span class="hljs-title">Gradient</span><span class="hljs-params">(Vector2 pos)</span><br></span>&#123;<br>    <span class="hljs-keyword">float</span> delta = <span class="hljs-number">1f</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0.5f</span> * <span class="hljs-keyword">new</span> Vector2(<br>    Sample(<span class="hljs-keyword">new</span> Vector2(pos.x+delta, pos.y)) - Sample(<span class="hljs-keyword">new</span> Vector2(pos.x-delta, pos.y)), <br>    Sample(<span class="hljs-keyword">new</span> Vector2(pos.x, pos.y+delta)) - Sample(<span class="hljs-keyword">new</span> Vector2(pos.x, pos.y-delta))<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="发生碰撞后实际移动方向代码："><a href="#发生碰撞后实际移动方向代码：" class="headerlink" title="发生碰撞后实际移动方向代码："></a>发生碰撞后实际移动方向代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//获取在移动过程使用SDF得到的最佳位置</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Vector2 <span class="hljs-title">GetValidPositionBySDF</span><span class="hljs-params">(Vector2 pos, Vector2 dir, <span class="hljs-keyword">float</span> speed)</span><br></span>&#123;<br>    Vector2 newPos = pos + dir * speed;<br>    <span class="hljs-keyword">float</span> SD = Sample(newPos);<br>    <br>    <span class="hljs-comment">//不可行走</span><br>    <span class="hljs-keyword">if</span>(SD &lt; playerRadius)<br>    &#123;<br>        Vector2 gradient = Gradient(newPos);<br>        Vector2 adjustDir = dir - gradient * Vector2.Dot(gradient, dir);<br>        newPos = pos + adjustDir.normalized * speed;<br>    &#125;<br>    <br>    <span class="hljs-comment">//多次迭代</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>    &#123;<br>        SD = Sample(newPos);<br>        <span class="hljs-keyword">if</span>(SD &gt;= playerRadius)<br>            <span class="hljs-keyword">break</span>;<br>        newPos += Gradient(newPos) * (playerRadius - SD);<br>    &#125;<br>    <br>    <span class="hljs-comment">//避免往返</span><br>    <span class="hljs-keyword">if</span>(Vector2.Dot(newPos - pos, dir) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        newPos = pos;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newPos;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="角色不能越过障碍物的远距离移动"><a href="#角色不能越过障碍物的远距离移动" class="headerlink" title="角色不能越过障碍物的远距离移动"></a>角色不能越过障碍物的远距离移动</h3><p>用于当校色进行瞬时远距离移动但不能越过障碍物的情况。</p><p>使用连续碰撞检测规避穿越障碍物的情况，具体方法是<strong>圆盘投射（Disk Casting）</strong>。</p><h4 id="使用圆盘投射计算位置："><a href="#使用圆盘投射计算位置：" class="headerlink" title="使用圆盘投射计算位置："></a>使用圆盘投射计算位置：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//oriPos:原始位置，dir:冲刺方向，radius:角色半径，maxDist:最大冲刺距离</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Vector2 <span class="hljs-title">DiskCast</span><span class="hljs-params">(Vector2 origin, Vector2 dir, <span class="hljs-keyword">float</span> radius, <span class="hljs-keyword">float</span> maxDist)</span><br></span>&#123;<br>    <span class="hljs-keyword">float</span> t = <span class="hljs-number">0f</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>    &#123;<br>        Vector2 p = origin + dir * t;<br>        <span class="hljs-keyword">float</span> sd = Sample(p);<br>        <span class="hljs-keyword">if</span>(sd &lt;= radius)<br>            <span class="hljs-keyword">return</span> p;<br>        t += sd - radius;<br>        <span class="hljs-keyword">if</span>(t &gt;= maxDist)<br>            <span class="hljs-keyword">return</span> origin + dir * maxDist;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态地图"><a href="#动态地图" class="headerlink" title="动态地图"></a>动态地图</h3><p>在均匀网格地图上，当角色在一帧内的行走距离不会超过单个网格大小时，可以通过检测每一帧与玩家所在网格相邻的8个网格的碰撞来实现规避障碍物的功能。</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/1.16%E8%A7%92%E8%89%B2%E5%9C%A8%E5%9D%87%E5%8C%80%E7%BD%91%E6%A0%BC%E5%9C%B0%E5%9B%BE%E7%A7%BB%E5%8A%A8.png" alt="1.16角色在均匀网格地图移动"></p><p>红色为障碍物区域，虚线圆圈为角色。</p><h4 id="实现规避障碍物："><a href="#实现规避障碍物：" class="headerlink" title="实现规避障碍物："></a>实现规避障碍物：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">EvalSDF</span><span class="hljs-params">(Vector2 p)</span><br></span>&#123;<br>    <span class="hljs-comment">//坐标离散成网格</span><br>    <span class="hljs-keyword">int</span> x = posToGridX(p);<br>    <span class="hljs-keyword">int</span> y = posToGridY(p);<br>    <span class="hljs-keyword">float</span> dist = cellSize;<br>    <span class="hljs-keyword">int</span> center = grid[y * width + x];<br>    <span class="hljs-comment">//WALL格子不可行走</span><br>    <span class="hljs-comment">//检测与玩家最近的距离</span><br>    <span class="hljs-keyword">if</span>(center == WALL)<br>    &#123;<br>        dist = min(dist, sdBox(centerPos - vecTopLeft, cellExtents));<br>    &#125;<br>    <span class="hljs-keyword">int</span> topleft = grid[(y - <span class="hljs-number">1</span>) * width + (x - <span class="hljs-number">1</span>)];<br>    <span class="hljs-keyword">if</span>(topleft == WALL)<br>    &#123;<br>        dist = min(dist, sdBox(centerPos - vecTop, cellExtents));<br>    &#125;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">return</span> dist;<br>&#125;<br><br><span class="hljs-function">Vector2 <span class="hljs-title">EvalGradient</span><span class="hljs-params">(Vector2 p)</span><br></span>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-comment">//新目标位置</span><br>    Vector2 nextPlayerPos = playerPos + moveDir * moveSpeed;<br>    <span class="hljs-comment">//目标位置的最近距离</span><br>    <span class="hljs-keyword">float</span> d = EvalSDF(nextPlayerPos);<br>    <span class="hljs-comment">//距离小于玩家半径，有穿插</span><br>    <span class="hljs-keyword">if</span>(d &lt; playerRadius)<br>    &#123;<br>        <span class="hljs-comment">//计算最近表面的法线</span><br>        Vector2 n = EvalGradient(nextPlayerPos);<br>        <span class="hljs-comment">//将玩家推出障碍区域</span><br>        nextPlayerPos = nextPlayerPos + n * (playerRadius - d);<br>    &#125;<br>    playerPos = nextPlayerPos;<br>&#125;<br></code></pre></td></tr></table></figure><p>场景中的其他障碍物，如较大的汽车、其他玩家等，可通过<strong>矩形、圆形的SDF函数</strong>来表示，并将结果与网格地图取出的SDF做<strong>交集</strong>操作。</p><h4 id="圆盘SDF"><a href="#圆盘SDF" class="headerlink" title="圆盘SDF:"></a>圆盘SDF:</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//x为任意点坐标，c为圆盘中心，r为圆盘半径</span><br><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">sdCircle</span><span class="hljs-params">(Vector2 x, Vector2 c, <span class="hljs-keyword">float</span> r)</span><br></span>&#123;<br>    <span class="hljs-keyword">return</span> (x - c).length() - r;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="矩形SDF"><a href="#矩形SDF" class="headerlink" title="矩形SDF:"></a>矩形SDF:</h4><p>d = (x - c)R(-θ) - b</p><p>Φ<del>x</del> = min(max(d<del>x</del>, d<del>y</del>), 0) + ||max(d, 0)||</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/1.14%E7%9F%A9%E5%BD%A2SDF.png" alt="1.14矩形SDF"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//x为任意点坐标，c为矩形中心，rot为矩形旋转角度，b为矩形边长</span><br><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">sdBox</span><span class="hljs-params">(Vector2 x, Vector c, Vector2 rot, Vector2 b)</span><br></span>&#123;<br>    Vector2 p = Vector2.Dot(x - c, -rot);<br>    Vector2 d = Vector2.Abs(p) - b;<br>    <span class="hljs-keyword">return</span> Mathf.Min(Mathf.Max(d.x, d.y), <span class="hljs-number">0f</span>) + Vector2.Max(d, Vector2.zero).Length(); <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-高性能的定点数实现方案"><a href="#2-高性能的定点数实现方案" class="headerlink" title="2. 高性能的定点数实现方案"></a>2. 高性能的定点数实现方案</h2><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>解决不同平台上的浮点数运算结果不同而导致的对帧同步的严重影响。</p><h3 id="32位浮点数结构"><a href="#32位浮点数结构" class="headerlink" title="32位浮点数结构"></a>32位浮点数结构</h3><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/32%E4%BD%8D%E6%B5%AE%E7%82%B9%E6%95%B0%E7%BB%93%E6%9E%84.png" alt="32位浮点数结构"></p><p>S=0时为正数，S=1时为负数</p><h3 id="基于整数的二进制表示的定点数原理"><a href="#基于整数的二进制表示的定点数原理" class="headerlink" title="基于整数的二进制表示的定点数原理"></a>基于整数的二进制表示的定点数原理</h3><p>设a为定点数，f(a)为这个定点数对应的整数值</p><p>a = 2^-n^f(a)</p><h3 id="32和64位定点数表示原理"><a href="#32和64位定点数表示原理" class="headerlink" title="32和64位定点数表示原理"></a>32和64位定点数表示原理</h3><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/%E5%AE%9A%E7%82%B9%E6%95%B0%E7%BB%93%E6%9E%84.png" alt="定点数结构"></p><p>32位定点数表示的范围：[-2^21^, 2^21^ - 2^-10^]</p><p>64位定点数表示的范围：[-2^31^, 2^31^ - 2^-32^]</p><h3 id="定点数四则运算"><a href="#定点数四则运算" class="headerlink" title="定点数四则运算"></a>定点数四则运算</h3><p>a + b = 2^-n^ (f(a) + f(b))</p><p>a - b = 2^-n^ (f(a) - f(b))</p><p>ab = (2^-n^)^2^ f(a) f(b) = 2^-n^ (2^-n^ f(a) f(b))</p><p>a / b = 2^-n^ (2^n^ f(a) / f(b))</p><h1 id="二、游戏物理"><a href="#二、游戏物理" class="headerlink" title="二、游戏物理"></a>二、游戏物理</h1><h2 id="1-一种高效的弧长参数化路径系统"><a href="#1-一种高效的弧长参数化路径系统" class="headerlink" title="1. 一种高效的弧长参数化路径系统"></a>1. 一种高效的弧长参数化路径系统</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>在跑酷游戏中，人物的移动靠路径引导；想要实现“弧长参数化”的特性—即令曲线参数t与曲线长度为L为线性关系，从而将参数t的线性变化映射到长度的线性变化上，实现曲线上的匀线速度运动。</p><h4 id="曲线路径系统需求："><a href="#曲线路径系统需求：" class="headerlink" title="曲线路径系统需求："></a>曲线路径系统需求：</h4><p>路径布置简单，最直观的就是布置路点。</p><p>修改具有局部性，修改一个路点只会影响上下游。</p><p>曲线至少具有C1连续性，满足基本的光滑需求。</p><p>两个路点之间的曲线可以是异面曲线，等同于可以自由控制邻接路点曲线的方向。</p><p>与曲线相关的计算尽量简单，尽量少地进行迭代计算。</p><h3 id="端点间二次样条的构建"><a href="#端点间二次样条的构建" class="headerlink" title="端点间二次样条的构建"></a>端点间二次样条的构建</h3><h4 id="为什么要拼接两条二次曲线？"><a href="#为什么要拼接两条二次曲线？" class="headerlink" title="为什么要拼接两条二次曲线？"></a>为什么要拼接两条二次曲线？</h4><p>要求两个路点可以自由控制位置和朝向（切线方向），单一的一段二次曲线自由度不够。</p><h4 id="二次样条曲线："><a href="#二次样条曲线：" class="headerlink" title="二次样条曲线："></a>二次样条曲线：</h4><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/3.1%E4%BA%8C%E6%AC%A1%E6%A0%B7%E6%9D%A1%E6%9B%B2%E7%BA%BF%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="3.1二次样条曲线示意图"></p><p>起点P<del>0</del>、起点切线T<del>0</del>、终点P<del>1</del>、终点切线T<del>1</del>。</p><p>f<del>1</del>(t) = a<del>1</del>t^2^ + b<del>1</del>t + c<del>1</del></p><p>f<del>2</del>(t) = a<del>2</del>t^2^ + b<del>2</del>t + c<del>2</del></p><p>为了将分段曲线当作一段曲线使用，需将两段曲线的参数t归一化到统一的[0, 1]范围内，f<del>s</del>(0) = P<del>0</del>，f<del>s</del>(1) = P<del>1</del>。</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/%E5%8F%82%E6%95%B0t%E5%BD%92%E4%B8%80%E5%8C%96%E5%90%8E%E7%9A%84%E5%88%86%E6%AE%B5%E4%BA%8C%E6%AC%A1%E6%9B%B2%E7%BA%BF.png" alt="参数t归一化后的分段二次曲线"></p><p>例如当L<del>1</del>长度为4，L<del>2</del>长度为6，归一化t = 0.3时，f<del>s</del>(t) = f<del>s</del>(0.3) = f<del>1</del>(0.3 x 10 / 4) = f<del>1</del>(3/4)，恰好对应L<del>1</del>的四分之三位置。</p><h3 id="路径的构建"><a href="#路径的构建" class="headerlink" title="路径的构建"></a>路径的构建</h3><p>路径为路点间曲线的拼接，切线的设置模仿Catmull-Rom这类Cardinal曲线的做法：路点i处的切线由路点i-1和路点i+1的位置决定：</p><p>T<del>i</del> = τ(P<del>i+1</del> - P<del>i-1</del>), τ为切线的缩放因子（张弛因子）</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/3.2Cardinal%E6%9B%B2%E7%BA%BF%E5%88%87%E7%BA%BF%E8%AE%BE%E7%BD%AE.png" alt="3.2Cardinal曲线切线设置"></p><p>使用邻接路点的信息构建曲线时，将邻接路点转换到自己的<strong>局部坐标系</strong>下，在上图的构建中，P<del>i</del>处于坐标原点且旋转为(0, 0, 0)，最后在使用路径时，每段曲线的计算结果要做一次<strong>从局部到世界坐标系的转换</strong>，<strong>好处</strong>是路径作为一个整体不受刚体变换的影响，适合游戏中场景动态拼接的需求。</p><h3 id="弧长的重参数化（arc-length-parametrization）"><a href="#弧长的重参数化（arc-length-parametrization）" class="headerlink" title="弧长的重参数化（arc-length parametrization）"></a>弧长的重参数化（arc-length parametrization）</h3><h4 id="为什么要做弧长的重参数化？"><a href="#为什么要做弧长的重参数化？" class="headerlink" title="为什么要做弧长的重参数化？"></a>为什么要做弧长的重参数化？</h4><p>可近似理解为在曲线上，每一点处的<strong>速度</strong>不同，相同的Δt内对应“走过”的弧长也不相同。</p><p>例如，对于曲线：</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/%E6%9B%B2%E7%BA%BF.png" alt="曲线"></p><p>直接用t取点，具有明显不均匀现象：</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/%E7%9B%B4%E6%8E%A5t%E5%8F%96%E7%82%B9.png" alt="直接t取点"></p><h4 id="arc-length"><a href="#arc-length" class="headerlink" title="arc-length:"></a>arc-length:</h4><p>定义一个映射Δ: [a, b] -&gt; [0, L], 获取原弧线参数t的定义域到弧长区间上的一个满射：</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/%E6%BB%A1%E5%B0%84.png" alt="满射"></p><p>其反函数设为Φ(s)，那么在给定s位置下，对应曲线参数为Φ(s)，对于上述曲线，先求Δ(t)，再求其反函数：</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/%E9%87%8D%E5%8F%82%E6%95%B01.png" alt="重参数1"></p><p>其反函数：</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/%E9%87%8D%E5%8F%82%E6%95%B02.png" alt="重参数2"></p><p>重参数化形式：</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/%E9%87%8D%E5%8F%82%E6%95%B03.png" alt="重参数3"></p><p>arc-length参数化后结果：</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/%E9%87%8D%E5%8F%82%E6%95%B04.png" alt="重参数4"></p><h3 id="曲线上的简单运动"><a href="#曲线上的简单运动" class="headerlink" title="曲线上的简单运动"></a>曲线上的简单运动</h3><p>法平面定义：过空间曲线的切点并且与切线垂直的平面。</p><h3 id="相邻路径的切换"><a href="#相邻路径的切换" class="headerlink" title="相邻路径的切换"></a>相邻路径的切换</h3><p>路径切换的过程中，使用当前路径上的基准点的法平面与另一路径的交点（等位点），由于路径的切换不能瞬时完成，将当前基准点变换到相邻路径基准点的局部坐标系下，将变换后的值和(O, X, Y, Z)插值的结果转换到世界坐标系，作为当前基准点及其关联的局部坐标系输入给物理模块。</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/3.4%E8%B7%AF%E5%BE%84%E5%88%87%E6%8D%A2%E6%8F%92%E5%80%BC%E8%BD%A8%E8%BF%B9.png" alt="3.4路径切换插值轨迹"></p><h3 id="曲线上的旋转插值"><a href="#曲线上的旋转插值" class="headerlink" title="曲线上的旋转插值"></a>曲线上的旋转插值</h3><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/3.5%E6%97%8B%E8%BD%AC%E6%8F%92%E5%80%BC%E5%AF%B9%E6%AF%94.png" alt="3.5旋转插值对比"></p><h2 id="2-船的物理模拟及同步设计"><a href="#2-船的物理模拟及同步设计" class="headerlink" title="2. 船的物理模拟及同步设计"></a>2. 船的物理模拟及同步设计</h2><h3 id="船的两种刚体"><a href="#船的两种刚体" class="headerlink" title="船的两种刚体"></a>船的两种刚体</h3><p>移动碰撞体：用于计算浮力的动态刚体</p><p>射击碰撞体：用来做射击检测的动力学动态刚体</p><h3 id="浮力计算中计算多面体入水体积"><a href="#浮力计算中计算多面体入水体积" class="headerlink" title="浮力计算中计算多面体入水体积"></a>浮力计算中计算多面体入水体积</h3><p>分成三角面判断，一个三角面只有三种状态：完全入水、完全出水、部分出水。</p><p>三角面完全入水，则三角面可以和P形成四面体为入水体积（点P必须在水面上）。</p><p>三角面完全出水，丢弃。</p><p>三角面部分入水，分两种情况，两点入水和一点入水。两点入水，分成的三个三角形，将水面上部的丢弃；一点入水，分成的三个三角形将水面上的两个三角形丢弃。</p><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/%E4%B8%89%E8%A7%92%E9%9D%A2%E9%83%A8%E5%88%86%E5%85%A5%E6%B0%B4.png" alt="三角面部分入水"></p><p><strong>于是，入水体积的求解收敛为两个问题：</strong></p><p>求一个四面体的体积。</p><p>已知三角形的顶点A, B, C, 求与水面的交点问题。</p><h3 id="浮力系统物理更新机制"><a href="#浮力系统物理更新机制" class="headerlink" title="浮力系统物理更新机制"></a>浮力系统物理更新机制</h3><p><img src="/2020/09/25/腾讯游戏开发精粹笔记/%E7%AC%AC%E4%B8%80%E6%96%B9%E5%92%8C%E7%AC%AC%E4%B8%89%E6%96%B9Component.png" alt="第一方和第三方Component"></p><p>三种第三方位置同步方法：</p><p>设置位置：会造成物体瞬移。</p><p>设置速度：通过计算位移差求出速度，在物理引擎进行物理模拟前应用到动态刚体上。</p><p>设置力：增加了一层间接性。</p><h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><p>第三方同步组件会每帧更新刚体的速度，浮力组件会每帧更新刚体受到的力，会造成位置的不一致（例如第三方刚体本来以速度v移动到位置X，但是浮力组件在速度方向上施加了阻力、浮力和升力，从而使物理系统算出的速度和v有偏差，导致最终物理模拟结束时物体的位置不是X）。</p><h4 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h4><p>浮力系统根据是否是第一方选择最终计算结果是力还是速度。</p><h4 id="Component物理更新的过程："><a href="#Component物理更新的过程：" class="headerlink" title="Component物理更新的过程："></a>Component物理更新的过程：</h4><p>第一方通过引擎组件(EngineComponent)计算出驱动力，通过浮力组件(BuoyancyComponent)计算出浮力，将这些力在物理引擎进行物理模拟之前统一施加在刚体组件(PhyComponent)上；</p><p>第三方通过同步组件(SyncComponent)计算出下一帧的同步速度，通过浮力组件计算出的浮力推算出下一帧的浮力速度，将这两个速度糅合后，在物理引擎进行物理模拟之前设置在刚体组件上。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、游戏数学&quot;&gt;&lt;a href=&quot;#一、游戏数学&quot; class=&quot;headerlink&quot; title=&quot;一、游戏数学&quot;&gt;&lt;/a&gt;一、游戏数学&lt;/h1&gt;
    
    </summary>
    
    
      <category term="GameDev" scheme="https://chasencenge.github.io/categories/GameDev/"/>
    
    
      <category term="GameDev" scheme="https://chasencenge.github.io/tags/GameDev/"/>
    
  </entry>
  
  <entry>
    <title>容器</title>
    <link href="https://chasencenge.github.io/2020/09/15/%E5%AE%B9%E5%99%A8/"/>
    <id>https://chasencenge.github.io/2020/09/15/容器/</id>
    <published>2020-09-15T13:50:54.000Z</published>
    <updated>2020-12-28T12:31:32.081Z</updated>
    
    <content type="html"><![CDATA[<h3 id="容器与镜像"><a href="#容器与镜像" class="headerlink" title="容器与镜像"></a>容器与镜像</h3><p>进程可见、可相互通信、共享一份文件系统</p><p>高级权限的进程可能破环低权限的进程</p><p>资源抢占</p><p>Linux通过 <code>chroot</code> 可将一个子目录变成根目录</p><p><code>namespace</code>在资源视图上进行隔离</p><p><code>cgroup</code>限制资源使用率</p><h4 id="容器："><a href="#容器：" class="headerlink" title="容器："></a>容器：</h4><p>容器是一个视图隔离、资源可限制、独立文件系统的进程集合</p><h4 id="镜像："><a href="#镜像：" class="headerlink" title="镜像："></a>镜像：</h4><p>运行容器需要的所有文件集合</p><p>构建步骤所带来的文件系统的变化叫做changeset</p><p>镜像可进行分层复用</p><h4 id="如何构建镜像？"><a href="#如何构建镜像？" class="headerlink" title="如何构建镜像？"></a>如何构建镜像？</h4><p>编写Dockerfile</p><p>// 表示以下的步骤是基于golang构建的</p><p><code>FROM golang:1.12-alpine</code> </p><p>// 类似于cd</p><p><code>WORKDIR /go/src/app</code></p><p>// 把数据拷入到容器内</p><p><code>COPY</code></p><p>//下载依赖</p><p><code>RUN go get -d -v ./...</code></p><p>//创建应用并安装</p><p><code>RUN go install -v ./...</code></p><p>//使用镜像默认程序的名字是什么</p><p><code>CMD [&quot;app&quot;]</code></p><p>有了这样一个Dockerfile<code>之后就可以通过docker build</code>构建镜像（存储到本地的）</p><p>docker registry进行镜像数据的存储和转发，通过 <code>docker push</code>可以将本地的镜像推送到镜像仓库中</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;容器与镜像&quot;&gt;&lt;a href=&quot;#容器与镜像&quot; class=&quot;headerlink&quot; title=&quot;容器与镜像&quot;&gt;&lt;/a&gt;容器与镜像&lt;/h3&gt;&lt;p&gt;进程可见、可相互通信、共享一份文件系统&lt;/p&gt;
&lt;p&gt;高级权限的进程可能破环低权限的进程&lt;/p&gt;
&lt;p&gt;资源抢占&lt;/p&gt;
&lt;p&gt;Linux通过 &lt;code&gt;chroot&lt;/code&gt; 可将一个子目录变成根目录&lt;/p&gt;
&lt;p&gt;&lt;code&gt;namespace&lt;/code&gt;在资源视图上进行隔离&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cgroup&lt;/code&gt;限制资源使用率&lt;/p&gt;
&lt;h4 id=&quot;容器：&quot;&gt;&lt;a href=&quot;#容器：&quot; class=&quot;headerlink&quot; title=&quot;容器：&quot;&gt;&lt;/a&gt;容器：&lt;/h4&gt;&lt;p&gt;容器是一个视图隔离、资源可限制、独立文件系统的进程集合&lt;/p&gt;
&lt;h4 id=&quot;镜像：&quot;&gt;&lt;a href=&quot;#镜像：&quot; class=&quot;headerlink&quot; title=&quot;镜像：&quot;&gt;&lt;/a&gt;镜像：&lt;/h4&gt;&lt;p&gt;运行容器需要的所有文件集合&lt;/p&gt;
&lt;p&gt;构建步骤所带来的文件系统的变化叫做changeset&lt;/p&gt;
&lt;p&gt;镜像可进行分层复用&lt;/p&gt;
&lt;h4 id=&quot;如何构建镜像？&quot;&gt;&lt;a href=&quot;#如何构建镜像？&quot; class=&quot;headerlink&quot; title=&quot;如何构建镜像？&quot;&gt;&lt;/a&gt;如何构建镜像？&lt;/h4&gt;&lt;p&gt;编写Dockerfile&lt;/p&gt;
&lt;p&gt;// 表示以下的步骤是基于golang构建的&lt;/p&gt;
&lt;p&gt;&lt;code&gt;FROM golang:1.12-alpine&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;// 类似于cd&lt;/p&gt;
&lt;p&gt;&lt;code&gt;WORKDIR /go/src/app&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;// 把数据拷入到容器内&lt;/p&gt;
&lt;p&gt;&lt;code&gt;COPY&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;//下载依赖&lt;/p&gt;
&lt;p&gt;&lt;code&gt;RUN go get -d -v ./...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;//创建应用并安装&lt;/p&gt;
&lt;p&gt;&lt;code&gt;RUN go install -v ./...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;//使用镜像默认程序的名字是什么&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CMD [&amp;quot;app&amp;quot;]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;有了这样一个Dockerfile&lt;code&gt;之后就可以通过docker build&lt;/code&gt;构建镜像（存储到本地的）&lt;/p&gt;
&lt;p&gt;docker registry进行镜像数据的存储和转发，通过 &lt;code&gt;docker push&lt;/code&gt;可以将本地的镜像推送到镜像仓库中&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://chasencenge.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://chasencenge.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>贪心专题</title>
    <link href="https://chasencenge.github.io/2020/09/15/%E8%B4%AA%E5%BF%83%E4%B8%93%E9%A2%98/"/>
    <id>https://chasencenge.github.io/2020/09/15/贪心专题/</id>
    <published>2020-09-15T11:24:25.000Z</published>
    <updated>2020-12-28T08:56:46.769Z</updated>
    
    <content type="html"><![CDATA[<h4 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12. 整数转罗马数字"></a>12. 整数转罗马数字</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 处理上有优先级，对于当前的数，优先处理大于1000的部分，然后处理900，500，400.....（每一部分的处理方式也有固定的对应） --&gt; 贪心算法</span><br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">intToRoman</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>    <span class="hljs-built_in">string</span> res;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; store&#123; <span class="hljs-number">1000</span>, <span class="hljs-number">900</span>, <span class="hljs-number">500</span>, <span class="hljs-number">400</span>, <span class="hljs-number">100</span>, <span class="hljs-number">90</span>, <span class="hljs-number">50</span>, <span class="hljs-number">40</span>, <span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span> &#125;;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; strs&#123; <span class="hljs-string">"M"</span>, <span class="hljs-string">"CM"</span>, <span class="hljs-string">"D"</span>, <span class="hljs-string">"CD"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"XC"</span>, <span class="hljs-string">"L"</span>, <span class="hljs-string">"XL"</span>, <span class="hljs-string">"X"</span>, <span class="hljs-string">"IX"</span>, <span class="hljs-string">"V"</span>, <span class="hljs-string">"IV"</span>, <span class="hljs-string">"I"</span> &#125;;<br>    <span class="hljs-keyword">int</span> n = store.size();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (num &gt;= store[i])<br>        &#123;<br>            res.append(strs[i]);<br>            num -= store[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><a id="more"></a><h4 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a>13. 罗马数字转整数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">romanToInt</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; hash&#123; &#123;<span class="hljs-string">'M'</span>, <span class="hljs-number">1000</span>&#125;, &#123;<span class="hljs-string">'D'</span>, <span class="hljs-number">500</span>&#125;, &#123;<span class="hljs-string">'C'</span>, <span class="hljs-number">100</span>&#125;, &#123;<span class="hljs-string">'L'</span>, <span class="hljs-number">50</span>&#125;, &#123;<span class="hljs-string">'X'</span>, <span class="hljs-number">10</span>&#125;, &#123;<span class="hljs-string">'V'</span>, <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-string">'I'</span>, <span class="hljs-number">1</span>&#125; &#125;;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.size(); i++)<br>    &#123;<br>        <span class="hljs-comment">// s.size()为'\0',将'\0'赋给int型变量时，变量值为0；</span><br>        <span class="hljs-keyword">if</span> (hash[s[i]] &lt; hash[s[i + <span class="hljs-number">1</span>]])<br>            res -= hash[s[i]];<br>        <span class="hljs-keyword">else</span><br>            res += hash[s[i]];<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; s[s.size()];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a>55. 跳跃游戏</h4><p>在每个能到达的点检查从该点出发能到达的最远距离，最远距离超过nums.size() - 1则能到达终点</p><p>如何判断中间的某一点是否能到达？</p><p>因为是顺序遍历所有位置，每次遍历当前位置时都用maxPos检查是否能达到下一点，如果无法达到说明已经中断，此时使用break跳出循环</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;12-整数转罗马数字&quot;&gt;&lt;a href=&quot;#12-整数转罗马数字&quot; class=&quot;headerlink&quot; title=&quot;12. 整数转罗马数字&quot;&gt;&lt;/a&gt;12. 整数转罗马数字&lt;/h4&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs c++&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 处理上有优先级，对于当前的数，优先处理大于1000的部分，然后处理900，500，400.....（每一部分的处理方式也有固定的对应） --&amp;gt; 贪心算法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;intToRoman&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; num)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;br&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; res;&lt;br&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt; store&amp;#123; &lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;900&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;500&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;400&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;90&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;40&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &amp;#125;;&lt;br&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;&amp;gt; strs&amp;#123; &lt;span class=&quot;hljs-string&quot;&gt;&quot;M&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;CM&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;D&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;CD&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;C&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;XC&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;L&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;XL&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;X&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;IX&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;V&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;IV&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;I&quot;&lt;/span&gt; &amp;#125;;&lt;br&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; n = store.size();&lt;br&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; n; i++)&lt;br&gt;    &amp;#123;&lt;br&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (num &amp;gt;= store[i])&lt;br&gt;        &amp;#123;&lt;br&gt;            res.append(strs[i]);&lt;br&gt;            num -= store[i];&lt;br&gt;        &amp;#125;&lt;br&gt;    &amp;#125;&lt;br&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; res;&lt;br&gt;&amp;#125;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>递归专题</title>
    <link href="https://chasencenge.github.io/2020/09/08/%E5%9B%9E%E6%BA%AF%E4%B8%93%E9%A2%98/"/>
    <id>https://chasencenge.github.io/2020/09/08/回溯专题/</id>
    <published>2020-09-08T06:17:54.000Z</published>
    <updated>2020-12-28T12:32:15.120Z</updated>
    
    <content type="html"><![CDATA[<h3 id="回溯算法的写法："><a href="#回溯算法的写法：" class="headerlink" title="回溯算法的写法："></a>回溯算法的写法：</h3><h5 id="画出递归树，找到状态变量（回溯函数的参数）"><a href="#画出递归树，找到状态变量（回溯函数的参数）" class="headerlink" title="画出递归树，找到状态变量（回溯函数的参数）"></a>画出递归树，找到状态变量（回溯函数的参数）</h5><h5 id="根据题意确立结束条件"><a href="#根据题意确立结束条件" class="headerlink" title="根据题意确立结束条件"></a>根据题意确立结束条件</h5><h5 id="找准选择列表"><a href="#找准选择列表" class="headerlink" title="找准选择列表"></a>找准选择列表</h5><h5 id="判断是否需要剪枝（去掉重复的集合，即去掉递归树上的某些分支）"><a href="#判断是否需要剪枝（去掉重复的集合，即去掉递归树上的某些分支）" class="headerlink" title="判断是否需要剪枝（去掉重复的集合，即去掉递归树上的某些分支）"></a>判断是否需要剪枝（去掉重复的集合，即去掉递归树上的某些分支）</h5><h5 id="做出选择，递归调用，进入下一层"><a href="#做出选择，递归调用，进入下一层" class="headerlink" title="做出选择，递归调用，进入下一层"></a>做出选择，递归调用，进入下一层</h5><h5 id="撤销选择"><a href="#撤销选择" class="headerlink" title="撤销选择"></a>撤销选择</h5><a id="more"></a><h4 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a>77. 组合</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//给出n，k返回可能的组合</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; temp;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span><br></span>&#123;<br>    <span class="hljs-comment">// 如果[cur, n]中元素的个数加上temo中元素的个数少于k，无法构成需要的组合</span><br>    <span class="hljs-keyword">if</span> (temp.size() + (n - cur + <span class="hljs-number">1</span>) &lt; k)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果temp的size == k，说明找到了组合，插入res</span><br>    <span class="hljs-keyword">if</span> (temp.size() == k)<br>    &#123;<br>        res.push_back(temp);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 小于k的话继续往里添加元素</span><br>    <span class="hljs-keyword">if</span> (temp.size() &lt; k)<br>    &#123;<br>        <span class="hljs-comment">// 考虑选择当前位置</span><br>        temp.push_back(cur);<br>        dfs(cur + <span class="hljs-number">1</span>, n, k);<br>        temp.pop_back();<br>        <span class="hljs-comment">// 考虑不选择当前位置</span><br>        dfs(cur + <span class="hljs-number">1</span>, n, k);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">combine</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    dfs(<span class="hljs-number">1</span>, n, k);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 因为是数据可重复选择的情况，所以在回溯中，可选择跳过和不跳过当前数值，这样就会包括某一个值重复选择的情况，在不跳过当前值的选择中，需要确定当前数值没有超过所需值</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; temp;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; candidates, <span class="hljs-keyword">int</span> remain)</span><br></span>&#123;        <br>    <span class="hljs-keyword">if</span>(cur == n)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(remain == <span class="hljs-number">0</span>)<br>    &#123;<br>        res.push_back(temp);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 不选择当前位置，直接跳过</span><br>    dfs(cur + <span class="hljs-number">1</span>, n, candidates, remain);<br>    <span class="hljs-comment">// 选择当前数，不跳过，不跳过的话需要判断当前数是否还能选择</span><br>    <span class="hljs-keyword">if</span>(candidates[cur] &lt;= remain)<br>    &#123;<br>        temp.push_back(candidates[cur]);<br>        remain -= candidates[cur]; <br>        dfs(cur, n, candidates, remain);<br>        temp.pop_back();<br>    &#125;<br>       <br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">combinationSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; candidates, <span class="hljs-keyword">int</span> target)</span> <br></span>&#123;<br>    <span class="hljs-keyword">int</span> n = candidates.size();<br>    dfs(<span class="hljs-number">0</span>, n,candidates, target);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="401-二进制手表"><a href="#401-二进制手表" class="headerlink" title="401. 二进制手表"></a>401. 二进制手表</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;string&gt; res;<br>unordered_map&lt;int, int&gt; hashdata = &#123;&#123;0,1&#125;,&#123;1,2&#125;,&#123;2,4&#125;,&#123;3,8&#125;,&#123;4,1&#125;,&#123;5,2&#125;,&#123;6,4&#125;,&#123;7,8&#125;,&#123;8,16&#125;,&#123;9,32&#125;&#125;;<br>void backtrack(int num,int start,pair&lt;int,int&gt;&amp; time)&#123;<br>    // 结束条件<br>    if(num == 0)<br>    &#123;<br>        if(time.first &gt; 11 || time.second &gt; 59)<br>        &#123;<br>            return;<br>        &#125;<br>        string temp_hour = to_string(time.first);<br>        string temp_minute = to_string(time.second);<br>        if(temp_minute.size() == 1)<br>        &#123;<br>            temp_minute.insert(0, "0");<br>        &#125;<br>        res.push_back(temp_hour + ":" + temp_minute);<br>        return;<br>    &#125;<br>    for(int i = start; i &lt; 10; i++)<br>    &#123;<br>        if(time.first &gt; 11 || time.second &gt; 59)<br>        &#123;<br>            continue;<br>        &#125;<br>        // 在本层中创建一个变量store用来存储当前的time值，回退时使用<br>        pair&lt;int, int&gt; store = time;<br>        if(i &lt; 4)<br>        &#123;<br>            time.first += hashdata[i];<br>        &#125;<br>        else<br>        &#123;<br>            time.second += hashdata[i];<br>        <br>        &#125;<br>        backtrack(num - 1, i + 1, time);<br>        // 在同层回退时把前面存好的store再赋给time，时time恢复到原状态<br>        time = store;<br>        <br>    &#125;<br>&#125;<br><br>vector&lt;string&gt; readBinaryWatch(int num) &#123;<br>    pair&lt;int, int&gt; time(0, 0);<br>    backtrack(num, 0, time);<br>    return res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="40-组合总数2"><a href="#40-组合总数2" class="headerlink" title="40. 组合总数2"></a>40. 组合总数2</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 去重复结果组合使用pair计数，将给的数组里的相同数值的数放在一起去递归处理</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; temp;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br><span class="hljs-built_in">vector</span>&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; freq;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos, <span class="hljs-keyword">int</span> rest)</span><br></span>&#123;<br>    <span class="hljs-keyword">if</span>(rest == <span class="hljs-number">0</span>)<br>    &#123;<br>        res.push_back(temp);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pos == freq.size() || rest &lt; freq[pos].first)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br><br>    dfs(pos+<span class="hljs-number">1</span>, rest);<br><span class="hljs-comment">// most用来判断处理相同数值的数时，进行几次递归，例如有五个2，但是target是7，那么只进行对2这个数值只进行三次递归</span><br>    <span class="hljs-keyword">int</span> most = min(rest / freq[pos].first, freq[pos].second);    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>; a &lt;= most; a++)<br>    &#123;<br>        temp.push_back(freq[pos].first);<br>        dfs(pos+<span class="hljs-number">1</span>, rest - a * freq[pos].first);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> b = <span class="hljs-number">1</span>; b &lt;= most; b++)<br>    &#123;<br>        temp.pop_back();<br>    &#125;<br>  <br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">combinationSum2</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; candidates, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-comment">// vector&lt;pair&lt;int, int&gt;&gt; freq;</span><br>    sort(candidates.begin(), candidates.end());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : candidates)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(freq.empty() || num != freq.back().first)<br>        &#123;<br>            <span class="hljs-comment">// 用push_back的话需要make_pair，用emplace_back则不需要</span><br>            <span class="hljs-comment">// freq.push_back(make_pair(num, 1));</span><br>            freq.emplace_back(num, <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            ++freq.back().second;<br>        &#125;<br>    &#125;<br>    dfs(<span class="hljs-number">0</span>, target);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="216-组合总数3"><a href="#216-组合总数3" class="headerlink" title="216. 组合总数3"></a>216. 组合总数3</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; temp;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> remain, <span class="hljs-keyword">int</span> k)</span><br></span>&#123;<br>    <span class="hljs-keyword">if</span>(remain == <span class="hljs-number">0</span> &amp;&amp; temp.size() == k)<br>    &#123;<br>        res.push_back(temp);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(cur &gt; remain || temp.size() == k || cur &gt; <span class="hljs-number">9</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    temp.push_back(cur);<br>    dfs(cur+<span class="hljs-number">1</span>, remain-cur, k);<br>    temp.pop_back();<br>    dfs(cur+<span class="hljs-number">1</span>, remain, k);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">combinationSum3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    dfs(<span class="hljs-number">1</span>, n, k);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h4><p>回溯函数参数：要生成的括号对数n，存结果的vector<string> rets，单个结果的string ret，当前左括号数open，当前右括号数close</string></p><p>用<code>ret.size() == 2 * n</code>判断是否将ret添加到结果rets</p><p>用<code>open &lt; n</code>判断是否继续添加左括号</p><p>用<code>close &lt; open</code>判断当前是否能添加右括号</p><h4 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h4><p>什么情况适合使用回溯法：</p><p>通过探索所有可能的候选解来找出所有解</p><p>终止条件为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cur == len<br></code></pre></td></tr></table></figure><p>回溯体结构为：</p><p>从已构造长度开始往后，逐个与当前位置进行数据交换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = cur; i &lt; len; i++)<br>&#123;<br>swap(output[cur], output[i]);<br>    backtrack(ret, output, cur+<span class="hljs-number">1</span>, len);<br>    swap(output[cur], output[i]); <span class="hljs-comment">//回溯里一定要记得的撤销操作</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a>78. 子集</h4><p>没啥说的，最基础的回溯….</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;回溯算法的写法：&quot;&gt;&lt;a href=&quot;#回溯算法的写法：&quot; class=&quot;headerlink&quot; title=&quot;回溯算法的写法：&quot;&gt;&lt;/a&gt;回溯算法的写法：&lt;/h3&gt;&lt;h5 id=&quot;画出递归树，找到状态变量（回溯函数的参数）&quot;&gt;&lt;a href=&quot;#画出递归树，找到状态变量（回溯函数的参数）&quot; class=&quot;headerlink&quot; title=&quot;画出递归树，找到状态变量（回溯函数的参数）&quot;&gt;&lt;/a&gt;画出递归树，找到状态变量（回溯函数的参数）&lt;/h5&gt;&lt;h5 id=&quot;根据题意确立结束条件&quot;&gt;&lt;a href=&quot;#根据题意确立结束条件&quot; class=&quot;headerlink&quot; title=&quot;根据题意确立结束条件&quot;&gt;&lt;/a&gt;根据题意确立结束条件&lt;/h5&gt;&lt;h5 id=&quot;找准选择列表&quot;&gt;&lt;a href=&quot;#找准选择列表&quot; class=&quot;headerlink&quot; title=&quot;找准选择列表&quot;&gt;&lt;/a&gt;找准选择列表&lt;/h5&gt;&lt;h5 id=&quot;判断是否需要剪枝（去掉重复的集合，即去掉递归树上的某些分支）&quot;&gt;&lt;a href=&quot;#判断是否需要剪枝（去掉重复的集合，即去掉递归树上的某些分支）&quot; class=&quot;headerlink&quot; title=&quot;判断是否需要剪枝（去掉重复的集合，即去掉递归树上的某些分支）&quot;&gt;&lt;/a&gt;判断是否需要剪枝（去掉重复的集合，即去掉递归树上的某些分支）&lt;/h5&gt;&lt;h5 id=&quot;做出选择，递归调用，进入下一层&quot;&gt;&lt;a href=&quot;#做出选择，递归调用，进入下一层&quot; class=&quot;headerlink&quot; title=&quot;做出选择，递归调用，进入下一层&quot;&gt;&lt;/a&gt;做出选择，递归调用，进入下一层&lt;/h5&gt;&lt;h5 id=&quot;撤销选择&quot;&gt;&lt;a href=&quot;#撤销选择&quot; class=&quot;headerlink&quot; title=&quot;撤销选择&quot;&gt;&lt;/a&gt;撤销选择&lt;/h5&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>查找专题</title>
    <link href="https://chasencenge.github.io/2020/09/03/%E6%9F%A5%E6%89%BE%E4%B8%93%E9%A2%98/"/>
    <id>https://chasencenge.github.io/2020/09/03/查找专题/</id>
    <published>2020-09-03T12:56:48.000Z</published>
    <updated>2020-12-28T12:32:55.614Z</updated>
    
    <content type="html"><![CDATA[<h4 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a>4. 寻找两个正序数组的中位数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//二分查找</span><br><span class="hljs-comment">//写一个查找第k大的函数，k值在运行过程中会慢慢减小</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthElement</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2, <span class="hljs-keyword">int</span> k)</span><br></span>&#123;<br>    <span class="hljs-keyword">int</span> m = nums1.size();<br>    <span class="hljs-keyword">int</span> n = nums2.size();<br>    <span class="hljs-keyword">int</span> index1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> index2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-comment">//nums1中的指针位置已经到了末尾，直接在num2中找剩下的第k大</span><br>        <span class="hljs-keyword">if</span> (index1 == m)<br>        &#123;<br>            <span class="hljs-keyword">return</span> nums2[index2 + k - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (index2 == n)<br>        &#123;<br>            <span class="hljs-keyword">return</span> nums1[index1 + k - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> min(nums1[index1], nums2[index2]);<br>        &#125;<br><span class="hljs-comment">//边界检测，index如果加了k / 2 - 1越界了，就直接将新的index设置为数组的最后一位</span><br>        <span class="hljs-keyword">int</span> newIndex1 = min(index1 + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>, m - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">int</span> newIndex2 = min(index2 + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">int</span> pivot1 = nums1[newIndex1];<br>        <span class="hljs-keyword">int</span> pivot2 = nums2[newIndex2];<br>        <span class="hljs-keyword">if</span> (pivot1 &lt;= pivot2)<br>        &#123;<br>            <span class="hljs-comment">//更新k和index</span><br>            k -= newIndex1 - index1 + <span class="hljs-number">1</span>;<br>            index1 = newIndex1 + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            k -= newIndex2 - index2 + <span class="hljs-number">1</span>;<br>            index2 = newIndex2 + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> totalLength = nums1.size() + nums2.size();<br>    <span class="hljs-keyword">if</span> (totalLength % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>    &#123;<span class="hljs-comment">//奇数总数和偶数总数分开讨论</span><br>        <span class="hljs-keyword">return</span> findKthElement(nums1, nums2, (totalLength + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> (findKthElement(nums1, nums2, totalLength / <span class="hljs-number">2</span>) + findKthElement(nums1, nums2, totalLength / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>)) / <span class="hljs-number">2.0</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><a id="more"></a><h4 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h4><p>排序数组直接联想二分查找</p><p>对二分查找做适合题目要求的改动，有多个连续的target值，寻找左边界时要找到最左面的target下标，则需要在findLeft函数中添加判断：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(nums[mid] == target)<br>right = mid;<br></code></pre></td></tr></table></figure><p>使有边界逐渐向左逼近，以保证最后走出 <code>while(left &lt; right)</code> 循环时，left在多个相同的target中的最左面</p><p>在findRight函数中不仅需要添加判断：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(nums[mid] == target)<br>left = mid;<br></code></pre></td></tr></table></figure><p>特别注意，还需要修改mid的计算：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">mid = (left + right + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>这里如果不加1的话，当left == right-1时，计算mid永远等于left，无法退出循环</p><h4 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a>347. 前 K 个高频元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 这里的static的添加是因为sory()第三个参数是个函数指针，然而cmp函数是一个非静态成员函数，非静态成员函数指针和普通函数指针是有区别的，为防止报错在类内的成员函数定义前添加static，或者把cmp函数定义写在类外</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; a, pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; b)</span><br>    </span>&#123;<br>        <span class="hljs-keyword">return</span> a.second &gt; b.second;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; countMap;<br>        <span class="hljs-keyword">int</span> n = nums.size();<br>        <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;::iterator it;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-comment">// 判断map中某个key是否存在，使用find()，（find()返回的是迭代器）</span><br>            it = countMap.find(nums[i]);<br>            <span class="hljs-keyword">if</span>(it != countMap.end())<br>            &#123;<br>                countMap[nums[i]]++;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">// map中插入新的&lt;key, value&gt;对</span><br>                countMap.insert(pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;(nums[i], <span class="hljs-number">1</span>));<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// map没有sort()函数，因为map不是线性结构，所以为了排序，将map中的pair形式的成员放到vector中再进行排序</span><br>        <span class="hljs-built_in">vector</span>&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; vec;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;::iterator it = countMap.begin(); it != countMap.end(); it++)<br>        &#123;<br>            vec.push_back(pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;(it-&gt;first, it-&gt;second));<br>        &#125;<br>        sort(vec.begin(), vec.end(), cmp);<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-built_in">vector</span>&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt;::iterator iter = vec.begin();<br>        <span class="hljs-keyword">while</span>(k)<br>        &#123;<br>            res.push_back(iter-&gt;first);<br>            iter++;<br>            k--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id><a href="#" class="headerlink" title></a></h4>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;4-寻找两个正序数组的中位数&quot;&gt;&lt;a href=&quot;#4-寻找两个正序数组的中位数&quot; class=&quot;headerlink&quot; title=&quot;4. 寻找两个正序数组的中位数&quot;&gt;&lt;/a&gt;4. 寻找两个正序数组的中位数&lt;/h4&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs c++&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//二分查找&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//写一个查找第k大的函数，k值在运行过程中会慢慢减小&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;findKthElement&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; nums1, &lt;span class=&quot;hljs-built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; nums2, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; k)&lt;/span&gt;&lt;br&gt;&lt;/span&gt;&amp;#123;&lt;br&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; m = nums1.size();&lt;br&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; n = nums2.size();&lt;br&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; index1 = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;br&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; index2 = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;br&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;)&lt;br&gt;    &amp;#123;&lt;br&gt;        &lt;span class=&quot;hljs-comment&quot;&gt;//nums1中的指针位置已经到了末尾，直接在num2中找剩下的第k大&lt;/span&gt;&lt;br&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (index1 == m)&lt;br&gt;        &amp;#123;&lt;br&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; nums2[index2 + k - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;];&lt;br&gt;        &amp;#125;&lt;br&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (index2 == n)&lt;br&gt;        &amp;#123;&lt;br&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; nums1[index1 + k - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;];&lt;br&gt;        &amp;#125;&lt;br&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (k == &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)&lt;br&gt;        &amp;#123;&lt;br&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; min(nums1[index1], nums2[index2]);&lt;br&gt;        &amp;#125;&lt;br&gt;		&lt;span class=&quot;hljs-comment&quot;&gt;//边界检测，index如果加了k / 2 - 1越界了，就直接将新的index设置为数组的最后一位&lt;/span&gt;&lt;br&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; newIndex1 = min(index1 + k / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, m - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);&lt;br&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; newIndex2 = min(index2 + k / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, n - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);&lt;br&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; pivot1 = nums1[newIndex1];&lt;br&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; pivot2 = nums2[newIndex2];&lt;br&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (pivot1 &amp;lt;= pivot2)&lt;br&gt;        &amp;#123;&lt;br&gt;            &lt;span class=&quot;hljs-comment&quot;&gt;//更新k和index&lt;/span&gt;&lt;br&gt;            k -= newIndex1 - index1 + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br&gt;            index1 = newIndex1 + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br&gt;        &amp;#125;&lt;br&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;&lt;br&gt;        &amp;#123;&lt;br&gt;            k -= newIndex2 - index2 + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br&gt;            index2 = newIndex2 + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br&gt;        &amp;#125;&lt;br&gt;    &amp;#125;&lt;br&gt;&amp;#125;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;findMedianSortedArrays&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; nums1, &lt;span class=&quot;hljs-built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; nums2)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;br&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; totalLength = nums1.size() + nums2.size();&lt;br&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (totalLength % &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; == &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)&lt;br&gt;    &amp;#123;	&lt;span class=&quot;hljs-comment&quot;&gt;//奇数总数和偶数总数分开讨论&lt;/span&gt;&lt;br&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; findKthElement(nums1, nums2, (totalLength + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;);&lt;br&gt;    &amp;#125;&lt;br&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;&lt;br&gt;    &amp;#123;&lt;br&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; (findKthElement(nums1, nums2, totalLength / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) + findKthElement(nums1, nums2, totalLength / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)) / &lt;span class=&quot;hljs-number&quot;&gt;2.0&lt;/span&gt;;&lt;br&gt;    &amp;#125;&lt;br&gt;&lt;br&gt;&amp;#125;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口专题</title>
    <link href="https://chasencenge.github.io/2020/09/03/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%93%E9%A2%98/"/>
    <id>https://chasencenge.github.io/2020/09/03/滑动窗口专题/</id>
    <published>2020-09-03T11:18:54.000Z</published>
    <updated>2020-12-28T12:32:39.887Z</updated>
    
    <content type="html"><![CDATA[<h4 id="3-无重复的最长字串"><a href="#3-无重复的最长字串" class="headerlink" title="3.  无重复的最长字串"></a>3.  无重复的最长字串</h4><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//右指针</span><br>    <span class="hljs-keyword">int</span> rp = <span class="hljs-number">-1</span>;<br>    <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt; seri;<br>    <span class="hljs-comment">//i是左指针</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.size(); i++)<br>    &#123;<br>        <span class="hljs-comment">//每次循环开始的时候把上一次左指针指向的值删掉</span><br>        <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>)<br>        &#123;<br>            seri.erase(s[i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-comment">//例如abcdcefgh，到了第二个c会产生重复，rp会停在d这里，然后删掉a继续循环，发现仍不满足!seri.count(s[rp + 1])，因为c并没被删掉，所以跳过while继续循环，删掉b，知道删掉第一个c，while中才满足!seri.count(s[rp + 1])，这时才能进入while，rp继续向后走</span><br>        <span class="hljs-keyword">while</span> (rp + <span class="hljs-number">1</span> &lt; s.size() &amp;&amp; !seri.count(s[rp + <span class="hljs-number">1</span>]))<br>        &#123;<br>            seri.insert(s[rp + <span class="hljs-number">1</span>]);<br>            rp++;<br>        &#125;<br>        res = max(res, rp - i + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="76-最小覆盖字串"><a href="#76-最小覆盖字串" class="headerlink" title="76. 最小覆盖字串"></a>76. 最小覆盖字串</h4><p>用两个map分别记录所需包含的字母及其个数(ori)，以及当前窗口内所含所需字母及其个数(cnt)</p><p>每次检查时，检查ori中的每个key对应的value和cnt中对应的value，cnt中的值不能小于ori，不然意味着当前窗口未完全包含所需的所有字符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;&amp; ori, <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;&amp; cnt)</span><br></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; p : ori)<br>    &#123;<br>    <span class="hljs-keyword">if</span>(cnt[p.first] &lt; p.second)<br>        &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当check满足条件，检查是否需要更新最小窗口长度len和结果起始点ansL，并且由于check满足条件需要将窗口左侧边界右移一位，所以此时如果最左侧的字母为ori中的一员，cnt对应的key的value减一</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(check(ori, cnt) &amp;&amp; l &lt;= r)<br>&#123;<br><span class="hljs-keyword">if</span>(r - l &lt; minLength)<br>&#123;<br>minLength = r - l;<br>ansL = l;<br>&#125;<br>    <span class="hljs-keyword">if</span>(ori.find(s[l]) != ori.end())<br>    &#123;<br>    --cnt[s[l]];<br>    &#125;<br>l++;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;3-无重复的最长字串&quot;&gt;&lt;a href=&quot;#3-无重复的最长字串&quot; class=&quot;headerlink&quot; title=&quot;3.  无重复的最长字串&quot;&gt;&lt;/a&gt;3.  无重复的最长字串&lt;/h4&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://chasencenge.github.io/2020/08/24/%E5%89%91%E6%8C%87offer/"/>
    <id>https://chasencenge.github.io/2020/08/24/剑指offer/</id>
    <published>2020-08-24T06:51:21.000Z</published>
    <updated>2020-12-28T08:57:02.935Z</updated>
    
    <content type="html"><![CDATA[<h4 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29. 顺时针打印矩阵"></a>29. 顺时针打印矩阵</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">处理移动四个移动方向用：<br>vector&lt;vector&lt;int&gt;&gt; move&#123; &#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125; &#125;;<br>或者：<br>static constexpr int directions[4][2] = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;<br>标记矩阵的已访问元素和未访问元素用一个相同大小的bool矩阵visit<br>输入一个空matrix时，如果对其求matrix[0].size()会报错，因为没有matrix[0]<br></code></pre></td></tr></table></figure><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; order;<br><br>    <span class="hljs-keyword">if</span> (matrix.size() == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].size() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> rowRange = matrix.size();<br>    <span class="hljs-keyword">int</span> colRange = matrix[<span class="hljs-number">0</span>].size();<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-title">visit</span><span class="hljs-params">(rowRange, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(colRange))</span></span>;<br>    <span class="hljs-keyword">int</span> total = rowRange * colRange;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; move&#123; &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125; &#125;;<br>    <span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> moveIndex = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> nextRow, nextCol;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; total; i++)<br>    &#123;<br>        order.push_back(matrix[row][col]);<br>        visit[row][col] = <span class="hljs-literal">true</span>;<br>        nextRow = row + move[moveIndex][<span class="hljs-number">0</span>];<br>        nextCol = col + move[moveIndex][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (nextRow &gt;= rowRange || nextRow &lt; <span class="hljs-number">0</span> || nextCol &gt;= colRange || nextCol &lt; <span class="hljs-number">0</span> || visit[nextRow][nextCol])<br>        &#123;<br>            moveIndex = (moveIndex + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;<br>        &#125;<br>        row += move[moveIndex][<span class="hljs-number">0</span>];<br>        col += move[moveIndex][<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> order;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;29-顺时针打印矩阵&quot;&gt;&lt;a href=&quot;#29-顺时针打印矩阵&quot; class=&quot;headerlink&quot; title=&quot;29. 顺时针打印矩阵&quot;&gt;&lt;/a&gt;29. 顺时针打印矩阵&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs undefined&quot;&gt;处理移动四个移动方向用：&lt;br&gt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; move&amp;#123; &amp;#123;0, 1&amp;#125;, &amp;#123;1, 0&amp;#125;, &amp;#123;0, -1&amp;#125;, &amp;#123;-1, 0&amp;#125; &amp;#125;;&lt;br&gt;或者：&lt;br&gt;static constexpr int directions[4][2] = &amp;#123;&amp;#123;0, 1&amp;#125;, &amp;#123;1, 0&amp;#125;, &amp;#123;0, -1&amp;#125;, &amp;#123;-1, 0&amp;#125;&amp;#125;;&lt;br&gt;标记矩阵的已访问元素和未访问元素用一个相同大小的bool矩阵visit&lt;br&gt;输入一个空matrix时，如果对其求matrix[0].size()会报错，因为没有matrix[0]&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://chasencenge.github.io/tags/Algorithm/"/>
    
  </entry>
  
</feed>
