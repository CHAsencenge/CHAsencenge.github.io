<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">




    <meta name="keywords" content="Algorithm,">



    <meta name="description" content="1. 两数之和12345678910111213vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target)&#123;    /*map*/     umordered_map&lt;int, int&gt; hashta...">


<meta name="Robots" content="all">


    <title>解字 | LeetCode top100刷题</title>


<link rel="icon" href="/images/avatar.ico">
<link rel="stylesheet" href="/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/atom-one-dark.css">
<link rel="stylesheet" href="/css/style.css">
<script src="/js/highlight.min.js"></script>
</head>
<body>
    <div class="main-container">
        <header class="header">
    <div class="global-width">
        <nav class="nav-box">
            
                <a class="nav-item" href="/">Home</a>
            
                <a class="nav-item" href="/resume">Resume</a>
            
                <a class="nav-item" href="/mood" target="_blank">Mood</a>
            
                <a class="nav-item" href="/amusement/tetris" target="_blank">Amusement</a>
            
                <a class="nav-item" href="/about">About</a>
            
        </nav>
    </div>
</header>

        <section class="content global-width">
            <div class="main">
                <article class="box post">
    <div class="post-title align-center detail-title">LeetCode top100刷题</div>
    <div class="post-meta align-center">
        
        <i class="fa fa-calendar"></i> <time>2020-08-03</time>
        <span class="dotted">|</span>
        <i class="fa fa-user"></i> 
        
            
                <span class="dotted">|</span>
                <i class="fa fa-folder-open-o"></i>
                <a class="category-link" href="/categories/Algorithm/">Algorithm</a>

                
                    <span class="dotted">|</span>
                

            
            
                <i class="fa fa-tags"></i>
                <a class="tag-link" href="/tags/Algorithm/">Algorithm</a>
            
        
    </div>

    <div class="post-content">
        <h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span><br></span>&#123;<br>    <span class="hljs-comment">/*map*/</span> <br>    umordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; hashtable;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++)<br>    &#123;<br>        <span class="hljs-keyword">auto</span> it = hashtable.find(target - nums[i]);<br>        <span class="hljs-keyword">if</span>(it != hashtable.end())<br>            <span class="hljs-keyword">return</span> &#123;it-&gt;second, i&#125;;<br>        hashtable[nums[i]] = i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*先排序，再利用双指针遍历，初始i放首部，j放尾部，两数之和大于target的话j--，小于target的话i++，找到对应的i和j*/</span><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; resV&#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; copyV = nums;<br>    <span class="hljs-keyword">int</span> find;<br>    <span class="hljs-keyword">int</span> hasFound = <span class="hljs-number">0</span>;<br>    sort(nums.begin(), nums.end());<br>    <span class="hljs-comment">/* for(int k = 0; k &lt; nums.size(); k++)*/</span><br>    <span class="hljs-comment">/* &#123;cout &lt;&lt; nums[k] &lt;&lt; " ";&#125;*/</span><br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> j = nums.size() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i != j &amp;&amp; hasFound == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (target &gt; nums[i] + nums[j])<br>        &#123;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &lt; nums[i] + nums[j])<br>        &#123;<br>            j--;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">/*找到i和j还没结束，要根据nums[i], nums[j]找到排序前的数组中对应的原始下标<br>            found1防止数组中有相同的值k使得k + k = target导致只能（进入下面的if）更新resV[0]的值<br>            这样，如果在原数组中找到第一个k值时进入if，之后继续找到第二个k值的时候便不会再进入if重复更新resV[0]而导致resV[j]不被更新*/</span><br>            <span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>, found1 = <span class="hljs-number">0</span>, label = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (label != <span class="hljs-number">2</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (copyV[flag] == nums[i] &amp;&amp; found1 == <span class="hljs-number">0</span>)<br>                &#123;<br>                    label++;<br>                    resV[<span class="hljs-number">0</span>] = flag;<br>                    found1 = <span class="hljs-number">1</span>;<br>                    flag++;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (copyV[flag] == nums[j])<br>                &#123;<br>                    label++;<br>                    resV[<span class="hljs-number">1</span>] = flag;<br>                    flag++;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    flag++;<br>                &#125;<br>            &#125;<br>            hasFound = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> resV;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> <br></span>&#123;<br>    ListNode *head = <span class="hljs-literal">nullptr</span>, *tail = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (l1 || l2) &#123;<br>        <span class="hljs-keyword">int</span> n1 = l1 ? l1-&gt;val: <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> n2 = l2 ? l2-&gt;val: <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> sum = n1 + n2 + carry;<br>        <span class="hljs-keyword">if</span> (!head) &#123;<br>            head = tail = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tail-&gt;next = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>);<br>            tail = tail-&gt;next;<br>        &#125;<br>        carry = sum / <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">if</span> (l1) &#123;<br>            l1 = l1-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l2) &#123;<br>            l2 = l2-&gt;next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (carry &gt; <span class="hljs-number">0</span>) &#123;<br>        tail-&gt;next = <span class="hljs-keyword">new</span> ListNode(carry);<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-无重复字符的最长字串"><a href="#3-无重复字符的最长字串" class="headerlink" title="3. 无重复字符的最长字串"></a>3. 无重复字符的最长字串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span><br></span>&#123;<br>    <span class="hljs-comment">/* 滑动窗口 + set */</span><br>	<span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt; st;<br>    <span class="hljs-keyword">int</span> n = s.size();<br>    <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>, ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>; left &lt; n; left++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(left != <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">/* 每一轮循环首先舍弃窗口左端 */</span><br>            st.erase(s[left - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(right &lt; n &amp;&amp; !st.count(s[right]))<br>        &#123;<br>            st.insert(s[right]);<br>            right++;<br>        &#125;<br>        <span class="hljs-comment">/* 这里right - left 不用再加一，因为right从0而不是从-1开始，理解right的意义 */</span><br>        ret = max(ret, right - left);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 排序然后双指针 */</span><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">threeSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span><br></span>&#123;<br>    sort(nums.begin(), nums.end());<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; ret;<br>    <span class="hljs-keyword">int</span> n = nums.size();<br>    <span class="hljs-keyword">if</span>(n &gt;= <span class="hljs-number">3</span> &amp;&amp; nums[n - <span class="hljs-number">1</span>] + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">3</span>] &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">/* 剪枝 */</span><br>        <span class="hljs-keyword">return</span> ret;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> first = <span class="hljs-number">0</span>; first &lt; n - <span class="hljs-number">2</span>; first++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(nums[first] + nums[first + <span class="hljs-number">1</span>] + nums[first + <span class="hljs-number">2</span>] &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">/* 剪枝 */</span><br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span>(first &gt; <span class="hljs-number">0</span> &amp;&amp; nums[first] == nums[first - <span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">int</span> target = -nums[first];<br>        <span class="hljs-keyword">int</span> third = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> second = first + <span class="hljs-number">1</span>; second &lt; n - <span class="hljs-number">1</span>; second++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(second &gt; first + <span class="hljs-number">1</span> &amp;&amp; nums[second] == nums[second - <span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">while</span>(second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target)<br>                --third;<br>            <span class="hljs-keyword">if</span>(second == third)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span>(nums[second] + nums[third] == target)<br>                ret.push_back(&#123;nums[first], nums[second], nums[third]&#125;);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="84-柱状图中的最大矩形"><a href="#84-柱状图中的最大矩形" class="headerlink" title="84. 柱状图中的最大矩形"></a>84. 柱状图中的最大矩形</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++">int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;<br>    int ret = 0;<br>    int n = heights.size();<br>    vector&lt;int&gt; left(n), right(n, n);<br>    stack&lt;int&gt; monoStack;<br><br>    for(int i = 0; i &lt; n; i++)<br>    &#123;<br>        while(!monoStack.empty() &amp;&amp; heights[monoStack.top()] &gt;= heights[i])<br>        &#123;<br>            right[monoStack.top()] = i; /* 终于遇到比stack中的top对应的柱低的柱了（之前可能是连续的比它高，所以无法确定矩形的宽，遇到比它低的时，就可以确定以它为高的矩形的右边界了）*/<br>            monoStack.pop();<br>        &#125;<br>        left[i] = monoStack.empty() ? -1 : monoStack.top(); /* 检索到某下标时就可以确定以它为高的矩形的左边界 */<br>        monoStack.push(i);<br>    &#125;<br>    for(int i = 0; i &lt; n; i++)<br>    &#123;<br>        ret = max(ret, (right[i] - left[i] -1) * heights[i]);<br>    &#125;<br>    return ret;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="85-最大矩形"><a href="#85-最大矩形" class="headerlink" title="85. 最大矩形"></a>85. 最大矩形</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++">int largestRectangleArea(vector&lt;int&gt;&amp; heights)<br>&#123;<br>    int ret = 0;<br>    int n = heights.size();<br>    vector&lt;int&gt; left(n), right(n, n);<br>    stack&lt;int&gt; monoStack;<br>    for(int i = 0; i &lt; n; i++)<br>    &#123;<br>        while(!monoStack.empty() &amp;&amp; heights[monoStack.top()] &gt;= heights[i])<br>        &#123;<br>            right[monoStack.top()] = i;<br>            monoStack.pop();<br>        &#125;<br>        left[i] = monoStack.empty() ? -1 : monoStack.top();<br>        monoStack.push(i);<br>    &#125;<br>    for(int i = 0; i &lt; n; i++)<br>    &#123;<br>        ret = max(ret, (right[i] - left[i] - 1) * heights[i]);<br>    &#125;<br>    return ret;<br>&#125;<br><br>int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;<br>    int ret = 0;<br>    int m = matrix.size();<br>    if(m == 0) /*要写在n的定义之前，因为matrix[0]不一定存在*/<br>        return 0;<br>    int n = matrix[0].size();<br>    vector&lt;int&gt; dp (n, 0);<br>    for(int i = 0; i &lt; m; i++)<br>    &#123;<br>        for(int j = 0; j &lt; n; j++)<br>        &#123;<br>            dp[j] = matrix[i][j] == '0' ? 0 : dp[j] + 1; /* 这个叠加是根据上一行的dp进行的，比如上方是2，下一行如果为‘1’，相应的柱状图加1的长度变为3（即在原dp数组基础上进行修改）*/<br>        &#125;<br>        ret = max(ret, largestRectangleArea(dp));<br>    &#125;<br>    return ret;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="114-二叉树（原地）展开为链表（顺着右子节点连）"><a href="#114-二叉树（原地）展开为链表（顺着右子节点连）" class="headerlink" title="114. 二叉树（原地）展开为链表（顺着右子节点连）"></a>114. 二叉树（原地）展开为链表（顺着右子节点连）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 还可以用前序遍历存到数组，再改节点结构；或者（只能用迭代法）同时存到数组并改节点结构，以上两种方法空间复杂度O(n)，下面是第三种方法不用前序遍历，直接改结构，空间复杂度为O(1) */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode* root)</span><br></span>&#123;<br>    TreeNode* cur = root;<br>    <span class="hljs-keyword">while</span>(cur)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(cur-&gt;left)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> next = cur-&gt;left;<br>            <span class="hljs-keyword">auto</span> predecessor = next;<br>            <span class="hljs-keyword">while</span>(predecessor-&gt;right)<br>                predecessor = predecessor-&gt;right;<br>            <span class="hljs-comment">/* predecessor为当前节点的左子树的最右节点，连到当前节点cur的右子节点 */</span><br>            predecessor-&gt;right = cur-&gt;right;<br>            <span class="hljs-comment">/* 更新当前节点的左右子节点 */</span><br>            cur-&gt;left = <span class="hljs-literal">nullptr</span>;<br>            cur-&gt;right = next;<br>		&#125;<br>        cur = cur-&gt;right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a>124. 二叉树中的最大路径和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxGain</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span>&amp; maxSum)</span><br></span>&#123;<br>    <span class="hljs-keyword">if</span>(root)<br>        <span class="hljs-comment">/* 空节点的最大贡献值等于0 */</span><br>    	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> left = max(maxGain(root-&gt;left), <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">int</span> right = max(maxGain(root-&gt;right), <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">/* 当前子树中的最大路径和为当前节点值加上两个子节点的最大贡献值 */</span><br>    <span class="hljs-keyword">int</span> curMaxSum = root-&gt;val + left + right;<br>    maxSum = max(maxSum, curMaxSum);<br>    <span class="hljs-comment">/* 非空节点的最大贡献值等于节点值与其子节点中的最大贡献值之和 */</span><br>    <span class="hljs-keyword">return</span> root-&gt;val + max(left, right);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span><br></span>&#123;<br>    <span class="hljs-keyword">int</span> maxSum = INT_MIN;<br>    maxGain(root, maxSum);<br>    <span class="hljs-keyword">return</span> maxSum;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="128-（无序数组中能找出的）最长连续序列（需要O-n-时间复杂度）"><a href="#128-（无序数组中能找出的）最长连续序列（需要O-n-时间复杂度）" class="headerlink" title="128. （无序数组中能找出的）最长连续序列（需要O(n)时间复杂度）"></a>128. （无序数组中能找出的）最长连续序列（需要O(n)时间复杂度）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span><br></span>&#123;<br>    <span class="hljs-comment">/* 怎么也该想到用哈希表存来减少时间复杂度 */</span><br>    <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">int</span>&gt; st;<br>    <span class="hljs-keyword">int</span> longestSeq = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)<br>        st.insert(num);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> s : st)<br>    &#123;<br>        <span class="hljs-comment">/* 灵魂的一步剪枝，怎么确定是否检查从某一个数字开始的序列？看set中是否存在num-1，如果存在，则跳过，以此避免查询序列中间的数字 */</span><br>        <span class="hljs-keyword">if</span>(!st.count(s - <span class="hljs-number">1</span>))<br>        &#123;<br>            <span class="hljs-keyword">int</span> curSeq = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">int</span> curNum = s;<br>            <span class="hljs-keyword">while</span>(st.count(curNum + <span class="hljs-number">1</span>))<br>            &#123;<br>                curSeq++;<br>                curNum++;<br>            &#125;<br>            longestSeq = max(longestSeq, curSeq);<br>        &#125;<br>	&#125;<br>    <span class="hljs-keyword">return</span> longestSeq;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="139-单词（是否可以）拆分（成字符串数组中的元素）-4min"><a href="#139-单词（是否可以）拆分（成字符串数组中的元素）-4min" class="headerlink" title="139. 单词（是否可以）拆分（成字符串数组中的元素）  4min"></a>139. 单词（是否可以）拆分（成字符串数组中的元素）  4min</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; wordDict)</span><br></span>&#123;<br>    <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt; st;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">string</span> word : wordDict)<br>        st.insert(word);<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(s.size() + <span class="hljs-number">1</span>)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">/* 这里的i可以理解为字符串s的前i个字符 */</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= s.size();i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)<br>            <span class="hljs-comment">/* 字符串的匹配使用的是s的子串和集合中存的string元素比较 */</span><br>            <span class="hljs-keyword">if</span>(dp[j] &amp;&amp; st.find(s.substr(j, i - j)) != st.end())<br>            &#123;<br>                dp[i] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[s.size()];<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a>160. 相交链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 你走过我走的路，我走过你走的路，我们殊途同归 */</span><br><span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!headA || !headB) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    ListNode *p, *q, *pp, *qq;<br>    p = headA; q = headB;<br>    <span class="hljs-keyword">while</span>(p != q)<br>    &#123;<br>        pp = p; qq = q;<br>        p = (!p -&gt; next &amp;&amp; qq -&gt; next) ? headB : p -&gt; next;<br>        <span class="hljs-comment">/* 用pp的作用体现出来了，经过上面的步骤，p可能已经变为p-&gt;next*/</span><br>        q = (!q -&gt; next &amp;&amp; pp -&gt; next) ? headA : q -&gt; next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="739-每日温度（每天找下一个比今天更高的温度）"><a href="#739-每日温度（每天找下一个比今天更高的温度）" class="headerlink" title="739. 每日温度（每天找下一个比今天更高的温度）"></a>739. 每日温度（每天找下一个比今天更高的温度）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 又是单调栈，相关题目还有84，85 */</span><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dailyTemperature</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; T)</span><br></span>&#123;<br>    <span class="hljs-keyword">int</span> n = T.size();<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ret</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; stk;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(!stk.empty() &amp;&amp; T[i] &gt; T[stk.top()])<br>        &#123;<br>            <span class="hljs-keyword">int</span> prevIndex = stk.top();<br>            ret[prevIndex] = i - prevIndex;<br>            stk.pop();<br>        &#125;<br>        stk.push(i);<br>    &#125;<br>	<span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>


    </div>
</article>
            </div>
            <div class="aside">
    
        <div class="box widget">
    <div class="introduction">
        <p><img src="/images/avatar.png" alt="head-sculpture"></p>
        <p class="name">
            CHAsencenge
        </p>
        <p class="slogan">解字</p>
    </div>
</div>
    
        
<div class="box widget">
    <div class="title">Recent</div>
    <ul class="item-box">
        
            
                <li><a href="/2020/11/30/手撸算法终版/">手撸算法终版</a></li>
            
        
            
                <li><a href="/2020/10/29/哈希专题/">哈希专题</a></li>
            
        
            
                <li><a href="/2020/10/29/特殊技巧专题/">特殊技巧专题</a></li>
            
        
            
                <li><a href="/2020/10/29/栈和队列专题/">栈和队列专题</a></li>
            
        
            
                <li><a href="/2020/10/28/树图专题/">树专题</a></li>
            
        
            
                <li><a href="/2020/10/28/空间换时间专题/">空间换时间专题</a></li>
            
        
            
                <li><a href="/2020/10/25/C-Lambda表达式/">C++ Lambda表达式</a></li>
            
        
            
                <li><a href="/2020/10/16/双指针专题/">双指针专题</a></li>
            
        
    </ul>
</div>

    
        
    <div class="box widget">
        <div class="title">Categories</div>
        <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GameDev/">GameDev</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Laya/">Laya</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Light-Frequency-Authenticate/">Light Frequency Authenticate</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/LoRa/">LoRa</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Unity/">Unity</a><span class="category-list-count">5</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Unity/Unreal/">Unreal</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Writing/">Writing</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cpp/">cpp</a><span class="category-list-count">3</span></li></ul>
    </div>

    
        
  <div class="box widget">
    <div class="title">Archives</div>
    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">2020-11</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">2020-10</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">2020-09</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">2020-08</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">2020-07</a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">2019-11</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">2019-09</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">2019-07</a><span class="archive-list-count">6</span></li></ul>
  </div>

    
        
    <div class="box widget">
        <div class="title">Tags</div>
        <div class="item-box cloud-label">
            <a href="/tags/Algorithm/" style="font-size: 20px;">Algorithm</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/GameDev/" style="font-size: 14px;">GameDev</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/Gradle/" style="font-size: 10px;">Gradle</a> <a href="/tags/Hexo/" style="font-size: 12px;">Hexo</a> <a href="/tags/Laya/" style="font-size: 16px;">Laya</a> <a href="/tags/LoRa/" style="font-size: 10px;">LoRa</a> <a href="/tags/Python/" style="font-size: 16px;">Python</a> <a href="/tags/Unity/" style="font-size: 18px;">Unity</a> <a href="/tags/Unreal/" style="font-size: 10px;">Unreal</a> <a href="/tags/Writing/" style="font-size: 12px;">Writing</a> <a href="/tags/cpp/" style="font-size: 14px;">cpp</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/lightFre/" style="font-size: 10px;">lightFre</a> <a href="/tags/writing/" style="font-size: 10px;">writing</a> <a href="/tags/远程登录/" style="font-size: 10px;">远程登录</a>
        </div>
    </div>

    
</div>
        </section>
        <footer class="footer">
    <div class="global-width footer-box">
        <div class="copyright">
            <span>Copyright &copy; 2019</span>
            <span class="dotted">|</span>
            <span>Powered by <a href="https://hexo.io/">Hexo</a></span>
            <span class="dotted">|</span>
            <span>Theme by <a href="javascript:">Loren</a></span>
            <span class="dotted">|</span>
            <span><a href="http://www.beian.miit.gov.cn">浙ICP备18016660号-1</a></span>
        </div>
    </div>
</footer>
    </div>

<script>
    hljs.initHighlightingOnLoad();
</script>
</body>
</html>