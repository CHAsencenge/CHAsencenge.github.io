<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">




    <meta name="keywords" content>



    <meta name="description" content="解字无果">


<meta name="Robots" content="all">


    <title>解字</title>


<link rel="icon" href="/images/avatar.ico">
<link rel="stylesheet" href="/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/atom-one-dark.css">
<link rel="stylesheet" href="/css/style.css">
<script src="/js/highlight.min.js"></script>
</head>
<body>
    <div class="main-container">
        <header class="header">
    <div class="global-width">
        <nav class="nav-box">
            
                <a class="nav-item" href="/">Home</a>
            
                <a class="nav-item" href="/resume">Resume</a>
            
                <a class="nav-item" href="/mood" target="_blank">Mood</a>
            
                <a class="nav-item" href="/amusement/tetris" target="_blank">Amusement</a>
            
                <a class="nav-item" href="/about">About</a>
            
        </nav>
    </div>
</header>

        <section class="content global-width">
            <div class="main">
                
    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/09/03/滑动窗口专题/">滑动窗口专题</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-09-03</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/09/03/滑动窗口专题/">
                    <p>
                        
                            3.  无重复的最长字串
                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="/categories/Algorithm/">Algorithm</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-link" href="/tags/Algorithm/">Algorithm</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/08/24/剑指offer/"></a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-08-24</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/08/24/剑指offer/">
                    <p>
                        
                            29. 顺时针打印矩阵123456处理移动四个移动方向用：vector&lt;vector&lt;int&gt;&gt; move&#123; &#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125; &#125;;或者：static constexpr int directions[4][2] = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;标记矩阵的已访问元素和未访问元素用一个相同大小的bool矩阵visit输入一个空matrix时，如果对其求matrix[0].size()会报错，因为没有matrix[0]
                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="/categories/Algorithm/">Algorithm</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-link" href="/tags/Algorithm/">Algorithm</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/08/18/dp专题/">dp专题</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-08-18</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/08/18/dp专题/">
                    <p>
                        
                            5.最长回文子串单独处理长度为1和2的字符串
状态转移：字串加上相同的首尾
                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="/categories/Algorithm/">Algorithm</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-link" href="/tags/Algorithm/">Algorithm</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/08/03/LeetCode-top&hot刷题/">LeetCode top100刷题</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-08-03</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/08/03/LeetCode-top&hot刷题/">
                    <p>
                        
                            1. 两数之和12345678910111213vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target)&#123;    /*map*/     umordered_map&lt;int, int&gt; hashtable;    for(int i = 0; i &lt; nums.size(); i++)    &#123;        auto it = hashtable.find(target - nums[i]);        if(it != hashtable.end())            return &#123;it-&gt;second, i&#125;;        hashtable[nums[i]] = i;    &#125;    return &#123;&#125;;&#125;
                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="/categories/Algorithm/">Algorithm</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-link" href="/tags/Algorithm/">Algorithm</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/08/02/LeetCode周赛/">LeetCode200周赛</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-08-02</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/08/02/LeetCode周赛/">
                    <p>
                        
                            给你一个整数数组 arr ，以及 a、b 、c 三个整数。请你统计其中好三元组的数量
如果三元组 (arr[i], arr[j], arr[k]) 满足下列全部条件，则认为它是一个 好三元组 
0 &lt;= i &lt; j &lt; k &lt; arr.length
|arr[i] - arr[j]| &lt;= a
|arr[j] - arr[k]| &lt;= b
|arr[i] - arr[k]| &lt;= c
其中 |x| 表示 x 的绝对值
返回 好三元组的数量 
1234567输入：arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3输出：4解释：一共有 4 个好三元组：[(3,0,1), (3,0,1), (3,1,1), (0,1,1)]输入：arr = [1,1,2,2,3], a = 0, b = 0, c = 1输出：0解释：不存在满足所有条件的三元组

123456789101112131415161718int countGoodTriplets(vector&lt;int&gt;&amp; arr, int a, int b, int c) &#123;	int res = 0;	for (int i = 0; i &lt; arr.size() - 2; i++)	&#123;		for (int j = i + 1; j &lt; arr.size() - 1; j++)		&#123;			for (int k = j + 1; k &lt; arr.size(); k++)			&#123;                //使用abs()需引用cmath头文件				if (abs(arr[i] - arr[j]) &lt;= a &amp;&amp; abs(arr[j] - arr[k]) &lt;= b &amp;&amp; abs(arr[i] - arr[k]) &lt;= c)				&#123;					res++;				&#125;			&#125;		&#125;	&#125;	return res;&#125;

给你一个由 不同 整数组成的整数数组 arr 和一个整数 k 
每回合游戏都在数组的前两个元素（即 arr[0] 和 arr[1] ）之间进行。比较 arr[0] 与 arr[1] 的大小，较大的整数将会取得这一回合的胜利并保留在位置 0 ，较小的整数移至数组的末尾。当一个整数赢得 k 个连续回合时，游戏结束，该整数就是比赛的 赢家 
返回赢得比赛的整数
题目数据 保证 游戏存在赢家
123456789输入：arr = [3,2,1], k = 10输出：3解释：3 将会在前 10 个回合中连续获胜    输入：arr = [1,9,8,2,3,7,6,4,5], k = 7输出：9    输入：arr = [1,11,22,33,44,55,66,77,88,99], k = 1000000000输出：99

123456//vector操作a.erase(a.begin()+1,a.begin()+3); //包前不包后，删除第1、2个元素a.insert(a.begin()+1,5); //在a的第1个元素（从第0个算起）的位置插入数值5a.insert(a.begin()+1,3,5); //在a的第1个元素（从第0个算起）的位置插入3个数，其值都为5a.back(); //返回a的最后一个元素a.front(); //返回a的第一个元素

123456789101112131415161718192021222324252627282930//按命题逻辑操作vector，遇到超长数组同时超大K值时会超时int getWinner(vector&lt;int&gt;&amp; arr, int k) &#123;	int num = 0;	int res = arr[0];	if (k &gt; arr.size())	&#123;		k = arr.size();	&#125;		while (num &lt; k)	&#123;		if (arr[0] &gt; arr[1])		&#123;			num++;			int temp = arr[1];			arr.erase(arr.begin() + 1, arr.begin() + 2);			arr.push_back(temp);		&#125;		else		&#123;			num = 1;			int temp = arr[0];			res = arr[1];			arr.erase(arr.begin(), arr.begin() + 1);			arr.push_back(temp);		&#125;	&#125;	return res;&#125;

123456789101112131415161718192021222324252627282930//trick，不用按题述方式操作vector，从前向后遍历即可int getWinner(vector&lt;int&gt;&amp; arr, int k) &#123;        int num = 0;	    int res = arr[0];	    if (k &gt; arr.size())	    &#123;	    	k = arr.size();	    &#125;	    for(int i = 0; i &lt; arr.size(); i++)        &#123;            if(arr[i]&gt;arr[i+1])            &#123;                //直接修改arr[i+1]的值为arr[i]，这样继续和后面比较时仍是类似命题中的：上一组的较大者和新数值比较                arr[i+1] = arr[i];                num++;            &#125;            else            &#123;                //当遇到前者小于后者的情况，看此时的num值是否满足大于等于k的要求，符合即作为结果返回                if(num &gt;= k)                &#123;                    return arr[i];                &#125;                //不符合则设置num为1，不设置为0的原因是因为已经淘汰掉上一个值，已经赢了一回合                res = arr[i+1];                num = 1;             &#125;        &#125;	    return res;    &#125;

给你一个 n x n 的二进制网格 grid，每一次操作中，你可以选择网格的 相邻两行 进行交换
一个符合要求的网格需要满足主对角线以上的格子全部都是 0 
请你返回使网格满足要求的最少操作次数，如果无法使网格符合要求，请你返回 -1 
主对角线指的是从 (1, 1) 到 (n, n) 的这些格子
123456789输入：grid = [[0,0,1],[1,1,0],[1,0,0]]输出：3输入：grid = [[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,1,1,0]]输出：-1解释：所有行都是一样的，交换相邻行无法使网格符合要求输入：grid = [[1,0,0],[1,1,0],[1,1,1]]输出：0

12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//贪心//从第一行开始，如果该行的后缀0满足条件，那么直接跳过进入下一行（因为需要的后缀0个数是从大到小的顺序（理解这一点非常重要），所以不必担心前面的会抢后面的，自己不够用的时候放心的去抢后面的，因为当前行的需求（优先级）比后面都高）//如果该行后缀0个数不满足条件，那么就往下遍历找到最先（贪心，这是最小次数）满足条件的行，一行一行换上来，记录交换的次数int minSwaps(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;    vector&lt;int&gt; resV;	int res = 0;    int n = grid.size();    //统计每行后缀0个数，存到resV中	for (int i = 0; i &lt; n; i++)	&#123;		int num = 0;		for (int j = 0; j &lt; grid[i].size(); j++)		&#123;			if (grid[i][j] == 0)			&#123;			    num++;			&#125;			else 			&#123;			    num = 0;			&#125;		&#125;		resV.push_back(num);	&#125;    for(int i = 0; i &lt; n - 1; i++)    &#123;        //如果当前行的后缀0个数够用，直接往下遍历，不用担心抢了后面的，因为当前行的需求量比后面的都高        if(resV[i] &gt;= n - i - 1)        continue;        else        &#123;            int j = i + 1;            while(resV[j] &lt; n - i - 1 )            &#123;                j++;                //找到最后都没有找到满足个数的后缀0，就直接退出                if(j == n)                    return -1;            &#125;            //while之后到这里说明找到了一行满足当前行的后缀0的个数需求，把找到的行一行一行的往上换，换到当前行，每次swap的同时更新交换次数            for(int m = j; m &gt; i; m--)            &#123;                swap(resV[m], resV[m - 1]);                res++;            &#125;            &#125;    &#125;    return res;&#125;

5484. 找出第 N 个二进制字符串中的第 K 位12345678910输入：n = 3, k = 1输出：&quot;0&quot;解释：S3 为 &quot;0111001&quot;，其第 1 位为 &quot;0&quot; 输入：n = 4, k = 11输出：&quot;1&quot;解释：S4 为 &quot;011100110110001&quot;，其第 11 位为 &quot;1&quot;输入：n = 1, k = 1输出：&quot;0&quot;

12345678910111213141516private:// invert处理    char ch_not(char ch) &#123;        if(ch == '0') &#123; return '1'; &#125;        else          &#123; return '0'; &#125;    &#125;public:    char findKthBit(int n, int k) &#123;        if(n == 1) &#123; return '0'; &#125;        // 1左移n-1位，pow(2, n-1)        int mid = (1&lt;&lt;(n-1));        if(k == mid) &#123; return '1'; &#125;        if(k &lt; mid) &#123; return findKthBit(n-1, k); &#125;        // k &gt; mid的情况需要把k挪到对称位置：(1&lt;&lt;n) - k，并进行invert        return ch_not(findKthBit(n-1, (1&lt;&lt;n) - k));     &#125;

5483. 整理字符串123456789101112输入：s = &quot;leEeetcode&quot;输出：&quot;leetcode&quot;解释：无论你第一次选的是 i = 1 还是 i = 2，都会使 &quot;leEeetcode&quot; 缩减为 &quot;leetcode&quot;输入：s = &quot;abBAcC&quot;输出：&quot;&quot;解释：存在多种不同情况，但所有的情况都会导致相同的结果。例如：&quot;abBAcC&quot; --&gt; &quot;aAcC&quot; --&gt; &quot;cC&quot; --&gt; &quot;&quot;&quot;abBAcC&quot; --&gt; &quot;abBA&quot; --&gt; &quot;aA&quot; --&gt; &quot;&quot;输入：s = &quot;s&quot;输出：&quot;s&quot;

1234567891011121314151617181920string makeGood(string s) &#123;int i = 0;while (i != s.length() - 1)&#123;    for (i = 0; i &lt; s.length() - 1; i++)    &#123;        if (abs(s[i] - s[i + 1]) == 32)        &#123;            s.erase(i, 2);            i = 0;            break;        &#125;    &#125;    if(s.empty())    &#123;        return "";    &#125;&#125;return s;&#125;

1234567891011121314151617181920212223//William Lin版string makeGood(string s)&#123;    bool ch = 1;    while(ch)    &#123;        ch = 0;        string t = s;        //size()返回类型是size_t, (unsigned) 和后面的int相减可能会溢出        for(int i = 0; i &lt; (int)s.size() - 1; i++)        &#123;            if(s[i] + 32 == s[i + 1] || s[i + 1] + 32 == s[i])            &#123;                //string的substr()使用，带首不带尾，单个参数默认从参数位置取到末尾                t = s.substr(0, i) + s.substr(i + 2);            	ch = 1;                break;            &#125;        &#125;        s = t;    &#125;    return s;&#125;

5468. 第 k 个缺失的正整数1234567输入：arr = [2,3,4,7,11], k = 5输出：9解释：缺失的正整数包括 [1,5,6,8,9,10,12,13,...]输入：arr = [1,2,3,4], k = 2输出：6解释：缺失的正整数包括 [5,6,7,...]

1234567891011121314151617181920212223242526272829int findKthPositive(vector&lt;int&gt;&amp; arr, int k) &#123;    int init = 0;    int res = 0;    int resNum = 0;    res = arr[0] - init -1;    if(res &gt;= k)    &#123;        return k;    &#125;    int i = 1;    while(i &lt; arr.size() &amp;&amp; res &lt; k)    &#123;        if(res + arr[i] - arr[i-1] - 1 &lt; k)        &#123;            res += arr[i] - arr[i-1] - 1;        &#125;        else        &#123;            resNum = arr[i-1] + (k - res);             res = k;        &#125;        i++;    &#125;    if(i == arr.size() &amp;&amp; res &lt; k)    &#123;        resNum = arr.back() + (k - res);    &#125;    return resNum;&#125;

5469. K 次操作转变字符串1234567891011输入：s = &quot;input&quot;, t = &quot;ouput&quot;, k = 9输出：true解释：第 6 次操作时，我们将 &apos;i&apos; 切换 6 次得到 &apos;o&apos; 。第 7 次操作时，我们将 &apos;n&apos; 切换 7 次得到 &apos;u&apos;输入：s = &quot;abc&quot;, t = &quot;bcd&quot;, k = 10输出：false解释：我们需要将每个字符切换 1 次才能得到 t 。我们可以在第 1 次操作时将 &apos;a&apos; 切换成 &apos;b&apos; ，但另外 2 个字母在剩余操作中无法再转变为 t 中对应字母输入：s = &quot;aab&quot;, t = &quot;bbb&quot;, k = 27输出：true解释：第 1 次操作时，我们将第一个 &apos;a&apos; 切换 1 次得到 &apos;b&apos; 。在第 27 次操作时，我们将第二个字母 &apos;a&apos; 切换 27 次得到 &apos;b&apos;

12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//结果出现的位置有数组首之前，数组中间，数组末尾之后，分别处理//创建一个数组存储每一位需要的操作数，将操作数按大小排好，一次遍历去对应k值看是否满足要求//addNum记录某个操作数出现的次数，比如6在某一位上出现一次，某另一位的操作数也是6，那么操作数只能选择6 + 26，第三次出现时操作数为6 + 26 * 2bool canConvertString(string s, string t, int k) &#123;        if (s.length() != t.length())        &#123;            return false;        &#125;        vector&lt;int&gt; resV;        int temp = 0;        vector&lt;int&gt; addNum(26, 0);        for (int i = 0; i &lt; s.length(); i++)        &#123;            if (t[i] - s[i] &gt;= 0)            &#123;                temp = t[i] - s[i];                addNum[temp] += 1;            &#125;            else            &#123;                temp = t[i] - 'a' + 'z' - s[i] + 1;                addNum[temp] += 1;            &#125;            //操作数为0是可以重复的，不需要加重叠次数*26            if (temp != 0)            &#123;                int pushNum = temp + 26 * (addNum[temp] - 1);                resV.push_back(pushNum);            &#125;            else            &#123;                resV.push_back(temp);            &#125;        &#125;        sort(resV.begin(), resV.end());        while (!resV.empty() &amp;&amp; resV.back() != 0)        &#123;            if (k &gt; resV.back())            &#123;                k = resV.back() - 1;                resV.pop_back();            &#125;            else if (k == resV.back())            &#123;                resV.pop_back();                k--;            &#125;            else            &#123;                return false;            &#125;        &#125;        return true;    &#125;

1546. 和为目标值的最大数目不重叠非空子数组数目1234567891011121314输入：nums = [1,1,1,1,1], target = 2输出：2解释：总共有 2 个不重叠子数组（加粗数字表示） [1,1,1,1,1] ，它们的和为目标值 2 输入：nums = [-1,3,5,1,4,2,-9], target = 6输出：2解释：总共有 3 个子数组和为 6 。([5,1], [4,2], [3,5,1,4,2,-9]) 但只有前 2 个是不重叠的输入：nums = [-2,6,6,3,5,4,1,2,8], target = 10输出：3输入：nums = [0,0,0], target = 0输出：3

12345678910111213141516171819202122// 贪心int maxNonOverlapping(vector&lt;int&gt;&amp; nums, int target)&#123;    set&lt;int&gt; s;    //初始时累计值为0，保证在&#123;-1, 3, 5, 1&#125;中找target=6时能找去掉-1, 3，找到&#123;5, 1&#125;    s.insert(0);    int ps = 0, ans = 0;    //一个替代遍历vector中每个值的方法（不关注下标时可使用）    for(int a : nums)    &#123;        //记录到每个当前值的累计值，其中的两个值相减就是两者之间的子数组中的各个值和        ps += a;        //注意理解ps - target的含义，是在当前位置根据target找前面是否有能截断而得到要的子数组的位置        if(s.find(ps - target != s.end()))        &#123;            ++ans;            s.clear();        &#125;        s.insert(ps);    &#125;    return ans;&#125;


                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="/categories/Algorithm/">Algorithm</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-link" href="/tags/Algorithm/">Algorithm</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/08/01/bfs专题/">LeetCode广度优先搜索</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-08-01</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/08/01/bfs专题/">
                    <p>
                        
                            107. 二叉树的层次遍历给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）
STL queue：原理：队尾（rear）插入，队首（front）删除
                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="/categories/Algorithm/">Algorithm</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-link" href="/tags/Algorithm/">Algorithm</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/08/01/字节夏令营20游戏程序笔试题/">字节夏令营20游戏程序笔试题</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-08-01</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/08/01/字节夏令营20游戏程序笔试题/">
                    <p>
                        
                            给素材分类，若作品1中有素材1和素材2，则认为素材1和素材2为一类，若作品2中有素材2和素材3，那么此后认为素材1、2、3为一类
输入：第一行为作品数n，此后n行中每行第一位为该作品中的素材总数m，此后m个数字为素材名（int型）
输出：素材的分类，并且每一类素材，类内顺序由小到大，类外顺序按照类内最小值由小到大排序输出
                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="/categories/Algorithm/">Algorithm</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-link" href="/tags/Algorithm/">Algorithm</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/07/31/网易20秋招Unity工程师笔试编程题/">网易20秋招Unity工程师笔试编程题</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-07-31</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/07/31/网易20秋招Unity工程师笔试编程题/">
                    <p>
                        
                            定义S(n)，表示n在十进制下的各位数字和。
现在给定一个x,请你求出最小正整数n，满足x&lt;=S(n)。
                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="/categories/Algorithm/">Algorithm</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-link" href="/tags/Algorithm/">Algorithm</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/07/26/百度之星2020-1003-Permutation/">百度之星2020---1003.Permutation</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-07-26</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/07/26/百度之星2020-1003-Permutation/">
                    <p>
                        
                            Problem Description
一开始有 n个数，他们按 1…n的顺序排列，要求交换最多 m对数字（同一个数字可以参与多次交换），使得逆序对数目最大。
对于一个序列 A，如果存在正整数 i, j使得1≤i&lt;j≤n 而且 A[i] &gt; A[j]，则 &lt;A[i],A[j]&gt; 这个有序对称为 A的一个逆序对。
Input
第一行一个正整数test (1≤test≤100000) 表示数据组数。
对于每组数据，一行两个整数 n，m (1≤n≤1000000,0≤m≤1000000) 表示数字个数和最多可以交换的数字对数。
                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="/categories/Algorithm/">Algorithm</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-link" href="/tags/Algorithm/">Algorithm</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/07/26/百度之星2020-1002-Game/">百度之星2020---1002.Game</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-07-26</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/07/26/百度之星2020-1002-Game/">
                    <p>
                        
                            Problem Description
Alice 和 Bob 在玩游戏。
桌面上有两堆金币，少的那堆有 x 个金币，多的那堆有 2x 个金币。
假设金币可以被无限细分。Alice 和 Bob 事先都不知道 x是几，但是他们都知道 x是一个 (0, 1]之间均匀分布的随机实数。
Alice 会等概率的被分配到其中的一堆金币，Bob 会得到另一堆。x的值和两堆金币的分配是相互独立的。
拿到金币以后，Alice 会马上数清自己拿到多少金币。然后 Alice 可以选择是否和 Bob 那堆换。
给定 Alice 拿到的金币数目，请问 Alice 要不要交换，使得她期望能得到的金币数目更多？
如果交换期望得到的金币数目多于不交换期望得到的金币数目，输出交换，否则不交换。
Input
第一行一个正整数test (1≤test≤200000) 表示数据组数。
接下来每行一个小数p(0&lt;p≤2)，p最多保留五位小数，表示 Alice 拿到的金币数目。
                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="/categories/Algorithm/">Algorithm</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-link" href="/tags/Algorithm/">Algorithm</a>
                    
                </div>
            
        </article>
    



    <nav class="page-nav">
        <a class="extend prev" rel="prev" href="/tags/Algorithm/">Prev</a><a class="page-number" href="/tags/Algorithm/">1</a><span class="page-number current">2</span><a class="page-number" href="/tags/Algorithm/page/3/">3</a><a class="extend next" rel="next" href="/tags/Algorithm/page/3/">Next</a>
    </nav>

            </div>
            <div class="aside">
    
        <div class="box widget">
    <div class="introduction">
        <p><img src="/images/avatar.png" alt="head-sculpture"></p>
        <p class="name">
            CHAsencenge
        </p>
        <p class="slogan">解字</p>
    </div>
</div>
    
        
<div class="box widget">
    <div class="title">Recent</div>
    <ul class="item-box">
        
            
                <li><a href="/2020/11/30/手撸算法终版/">手撸算法终版</a></li>
            
        
            
                <li><a href="/2020/10/29/哈希专题/">哈希专题</a></li>
            
        
            
                <li><a href="/2020/10/29/特殊技巧专题/">特殊技巧专题</a></li>
            
        
            
                <li><a href="/2020/10/29/栈和队列专题/">栈和队列专题</a></li>
            
        
            
                <li><a href="/2020/10/28/树图专题/">树专题</a></li>
            
        
            
                <li><a href="/2020/10/28/空间换时间专题/">空间换时间专题</a></li>
            
        
            
                <li><a href="/2020/10/25/C-Lambda表达式/">C++ Lambda表达式</a></li>
            
        
            
                <li><a href="/2020/10/16/双指针专题/">双指针专题</a></li>
            
        
    </ul>
</div>

    
        
    <div class="box widget">
        <div class="title">Categories</div>
        <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GameDev/">GameDev</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Laya/">Laya</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Light-Frequency-Authenticate/">Light Frequency Authenticate</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/LoRa/">LoRa</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Unity/">Unity</a><span class="category-list-count">5</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Unity/Unreal/">Unreal</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Writing/">Writing</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cpp/">cpp</a><span class="category-list-count">3</span></li></ul>
    </div>

    
        
  <div class="box widget">
    <div class="title">Archives</div>
    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">2020-11</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">2020-10</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">2020-09</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">2020-08</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">2020-07</a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">2019-11</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">2019-09</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">2019-07</a><span class="archive-list-count">6</span></li></ul>
  </div>

    
        
    <div class="box widget">
        <div class="title">Tags</div>
        <div class="item-box cloud-label">
            <a href="/tags/Algorithm/" style="font-size: 20px;">Algorithm</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/GameDev/" style="font-size: 14px;">GameDev</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/Gradle/" style="font-size: 10px;">Gradle</a> <a href="/tags/Hexo/" style="font-size: 12px;">Hexo</a> <a href="/tags/Laya/" style="font-size: 16px;">Laya</a> <a href="/tags/LoRa/" style="font-size: 10px;">LoRa</a> <a href="/tags/Python/" style="font-size: 16px;">Python</a> <a href="/tags/Unity/" style="font-size: 18px;">Unity</a> <a href="/tags/Unreal/" style="font-size: 10px;">Unreal</a> <a href="/tags/Writing/" style="font-size: 12px;">Writing</a> <a href="/tags/cpp/" style="font-size: 14px;">cpp</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/lightFre/" style="font-size: 10px;">lightFre</a> <a href="/tags/writing/" style="font-size: 10px;">writing</a> <a href="/tags/远程登录/" style="font-size: 10px;">远程登录</a>
        </div>
    </div>

    
</div>
        </section>
        <footer class="footer">
    <div class="global-width footer-box">
        <div class="copyright">
            <span>Copyright &copy; 2019</span>
            <span class="dotted">|</span>
            <span>Powered by <a href="https://hexo.io/">Hexo</a></span>
            <span class="dotted">|</span>
            <span>Theme by <a href="javascript:">Loren</a></span>
            <span class="dotted">|</span>
            <span><a href="http://www.beian.miit.gov.cn">浙ICP备18016660号-1</a></span>
        </div>
    </div>
</footer>
    </div>

<script>
    hljs.initHighlightingOnLoad();
</script>
</body>
</html>