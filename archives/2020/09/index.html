<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">




    <meta name="keywords" content>



    <meta name="description" content="解字无果">


<meta name="Robots" content="all">


    <title>解字</title>


<link rel="icon" href="/images/favicon.ico">
<link rel="stylesheet" href="/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/atom-one-dark.css">
<link rel="stylesheet" href="/css/style.css">
<script src="/js/highlight.min.js"></script>
</head>
<body>
    <div class="main-container">
        <header class="header">
    <div class="global-width">
        <nav class="nav-box">
            
                <a class="nav-item" href="/">Home</a>
            
                <a class="nav-item" href="/resume">Resume</a>
            
                <a class="nav-item" href="/mood" target="_blank">Mood</a>
            
                <a class="nav-item" href="/amusement/tetris" target="_blank">Amusement</a>
            
                <a class="nav-item" href="/about">About</a>
            
        </nav>
    </div>
</header>

        <section class="content global-width">
            <div class="main">
                
    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/09/25/腾讯游戏开发精粹笔记/">腾讯游戏开发精粹笔记</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-09-25</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/09/25/腾讯游戏开发精粹笔记/">
                    <p>
                        
                            一、游戏数学1.基于SDF的摇杆移动SDF：SDF全称Signed Distance Field（有号距离场），定义为空间中的点到形状表面的最小距离，并用正值表示点在形状外部，负值表示点在形状内部。
为什么要使用SDF？空间换时间，在O(1)时间复杂度计算出是否碰撞。
如何判断碰撞？基于已有SDF信息的栅格，使用其邻近四个角的SD信息进行插值，得到当前点的SD，若SD&lt;=0, 则判定该点和碰撞物发生了碰撞。
插值获得任意点的SD值：123456789101112//计算位置pos的SD值//每个栅格的实际尺寸为grid，横向栅格数量为widthpublic float Sample(Vector2 pos)&#123;    pos = pos / grid;    int fx = Mathf.FloorToInt(pos.x);    int fy = Mathf.FloorToInt(pos.y);    float rx = pos.x - fx;    float ry = pos.y - fy;    int i = fy * width + fx;    return (sdf[i]*(1-rx) + sdf[i+1]*rx)*(1-ry) + (sdf[i+width]*(1-rx) + sdf[i+width+1]*rx)*ry;&#125;

如何实现发生碰撞后绕障碍物滑行？
v表示摇杆方向，与障碍物发生碰撞后需要沿着v’方向滑行，n为碰撞法线，v’和v有以上关系。
如何获取碰撞法线n？利用SDF的梯度作为碰撞法线。
求梯度方向：12345678public Vector2 Gradient(Vector2 pos)&#123;    float delta = 1f;    return 0.5f * new Vector2(    Sample(new Vector2(pos.x+delta, pos.y)) - Sample(new Vector2(pos.x-delta, pos.y)),     Sample(new Vector2(pos.x, pos.y+delta)) - Sample(new Vector2(pos.x, pos.y-delta))    );&#125;

发生碰撞后实际移动方向代码：123456789101112131415161718192021222324252627282930//获取在移动过程使用SDF得到的最佳位置public Vector2 GetValidPositionBySDF(Vector2 pos, Vector2 dir, float speed)&#123;    Vector2 newPos = pos + dir * speed;    float SD = Sample(newPos);        //不可行走    if(SD &lt; playerRadius)    &#123;        Vector2 gradient = Gradient(newPos);        Vector2 adjustDir = dir - gradient * Vector2.Dot(gradient, dir);        newPos = pos + adjustDir.normalized * speed;    &#125;        //多次迭代    for(int i = 0; i &lt; 3; i++)    &#123;        SD = Sample(newPos);        if(SD &gt;= playerRadius)            break;        newPos += Gradient(newPos) * (playerRadius - SD);    &#125;        //避免往返    if(Vector2.Dot(newPos - pos, dir) &lt; 0)    &#123;        newPos = pos;    &#125;    return newPos;&#125;

角色不能越过障碍物的远距离移动用于当校色进行瞬时远距离移动但不能越过障碍物的情况。
使用连续碰撞检测规避穿越障碍物的情况，具体方法是圆盘投射（Disk Casting）。
使用圆盘投射计算位置：123456789101112131415//oriPos:原始位置，dir:冲刺方向，radius:角色半径，maxDist:最大冲刺距离public Vector2 DiskCast(Vector2 origin, Vector2 dir, float radius, float maxDist)&#123;    float t = 0f;    while(true)    &#123;        Vector2 p = origin + dir * t;        float sd = Sample(p);        if(sd &lt;= radius)            return p;        t += sd - radius;        if(t &gt;= maxDist)            return origin + dir * maxDist;    &#125;&#125;

动态地图在均匀网格地图上，当角色在一帧内的行走距离不会超过单个网格大小时，可以通过检测每一帧与玩家所在网格相邻的8个网格的碰撞来实现规避障碍物的功能。

红色为障碍物区域，虚线圆圈为角色。
实现规避障碍物：12345678910111213141516171819202122232425262728293031323334353637383940414243float EvalSDF(Vector2 p)&#123;    //坐标离散成网格    int x = posToGridX(p);    int y = posToGridY(p);    float dist = cellSize;    int center = grid[y * width + x];    //WALL格子不可行走    //检测与玩家最近的距离    if(center == WALL)    &#123;        dist = min(dist, sdBox(centerPos - vecTopLeft, cellExtents));    &#125;    int topleft = grid[(y - 1) * width + (x - 1)];    if(topleft == WALL)    &#123;        dist = min(dist, sdBox(centerPos - vecTop, cellExtents));    &#125;    //...    return dist;&#125;Vector2 EvalGradient(Vector2 p)&#123;    //...&#125;void Update()&#123;    //新目标位置    Vector2 nextPlayerPos = playerPos + moveDir * moveSpeed;    //目标位置的最近距离    float d = EvalSDF(nextPlayerPos);    //距离小于玩家半径，有穿插    if(d &lt; playerRadius)    &#123;        //计算最近表面的法线        Vector2 n = EvalGradient(nextPlayerPos);        //将玩家推出障碍区域        nextPlayerPos = nextPlayerPos + n * (playerRadius - d);    &#125;    playerPos = nextPlayerPos;&#125;

场景中的其他障碍物，如较大的汽车、其他玩家等，可通过矩形、圆形的SDF函数来表示，并将结果与网格地图取出的SDF做交集操作。
圆盘SDF:12345//x为任意点坐标，c为圆盘中心，r为圆盘半径float sdCircle(Vector2 x, Vector2 c, float r)&#123;    return (x - c).length() - r;&#125;

矩形SDF:d = (x - c)R(-θ) - b
Φx = min(max(dx, dy), 0) + ||max(d, 0)||

1234567//x为任意点坐标，c为矩形中心，rot为矩形旋转角度，b为矩形边长float sdBox(Vector2 x, Vector c, Vector2 rot, Vector2 b)&#123;    Vector2 p = Vector2.Dot(x - c, -rot);    Vector2 d = Vector2.Abs(p) - b;    return Mathf.Min(Mathf.Max(d.x, d.y), 0f) + Vector2.Max(d, Vector2.zero).Length(); &#125;

2. 高性能的定点数实现方案用途解决不同平台上的浮点数运算结果不同而导致的对帧同步的严重影响。
32位浮点数结构
S=0时为正数，S=1时为负数
基于整数的二进制表示的定点数原理设a为定点数，f(a)为这个定点数对应的整数值
a = 2^-n^f(a)
32和64位定点数表示原理
32位定点数表示的范围：[-2^21^, 2^21^ - 2^-10^]
64位定点数表示的范围：[-2^31^, 2^31^ - 2^-32^]
定点数四则运算a + b = 2^-n^ (f(a) + f(b))
a - b = 2^-n^ (f(a) - f(b))
ab = (2^-n^)^2^ f(a) f(b) = 2^-n^ (2^-n^ f(a) f(b))
a / b = 2^-n^ (2^n^ f(a) / f(b))
二、游戏物理1. 一种高效的弧长参数化路径系统需求在跑酷游戏中，人物的移动靠路径引导；想要实现“弧长参数化”的特性—即令曲线参数t与曲线长度为L为线性关系，从而将参数t的线性变化映射到长度的线性变化上，实现曲线上的匀线速度运动。
曲线路径系统需求：路径布置简单，最直观的就是布置路点。
修改具有局部性，修改一个路点只会影响上下游。
曲线至少具有C1连续性，满足基本的光滑需求。
两个路点之间的曲线可以是异面曲线，等同于可以自由控制邻接路点曲线的方向。
与曲线相关的计算尽量简单，尽量少地进行迭代计算。
端点间二次样条的构建为什么要拼接两条二次曲线？要求两个路点可以自由控制位置和朝向（切线方向），单一的一段二次曲线自由度不够。
二次样条曲线：
起点P0、起点切线T0、终点P1、终点切线T1。
f1(t) = a1t^2^ + b1t + c1
f2(t) = a2t^2^ + b2t + c2
为了将分段曲线当作一段曲线使用，需将两段曲线的参数t归一化到统一的[0, 1]范围内，fs(0) = P0，fs(1) = P1。

例如当L1长度为4，L2长度为6，归一化t = 0.3时，fs(t) = fs(0.3) = f1(0.3 x 10 / 4) = f1(3/4)，恰好对应L1的四分之三位置。
路径的构建路径为路点间曲线的拼接，切线的设置模仿Catmull-Rom这类Cardinal曲线的做法：路点i处的切线由路点i-1和路点i+1的位置决定：
Ti = τ(Pi+1 - Pi-1), τ为切线的缩放因子（张弛因子）

使用邻接路点的信息构建曲线时，将邻接路点转换到自己的局部坐标系下，在上图的构建中，Pi处于坐标原点且旋转为(0, 0, 0)，最后在使用路径时，每段曲线的计算结果要做一次从局部到世界坐标系的转换，好处是路径作为一个整体不受刚体变换的影响，适合游戏中场景动态拼接的需求。
弧长的重参数化（arc-length parametrization）为什么要做弧长的重参数化？可近似理解为在曲线上，每一点处的速度不同，相同的Δt内对应“走过”的弧长也不相同。
例如，对于曲线：

直接用t取点，具有明显不均匀现象：

arc-length:定义一个映射Δ: [a, b] -&gt; [0, L], 获取原弧线参数t的定义域到弧长区间上的一个满射：

其反函数设为Φ(s)，那么在给定s位置下，对应曲线参数为Φ(s)，对于上述曲线，先求Δ(t)，再求其反函数：

其反函数：

重参数化形式：

arc-length参数化后结果：

曲线上的简单运动法平面定义：过空间曲线的切点并且与切线垂直的平面。
相邻路径的切换路径切换的过程中，使用当前路径上的基准点的法平面与另一路径的交点（等位点），由于路径的切换不能瞬时完成，将当前基准点变换到相邻路径基准点的局部坐标系下，将变换后的值和(O, X, Y, Z)插值的结果转换到世界坐标系，作为当前基准点及其关联的局部坐标系输入给物理模块。

曲线上的旋转插值
2. 船的物理模拟及同步设计船的两种刚体移动碰撞体：用于计算浮力的动态刚体
射击碰撞体：用来做射击检测的动力学动态刚体
浮力计算中计算多面体入水体积分成三角面判断，一个三角面只有三种状态：完全入水、完全出水、部分出水。
三角面完全入水，则三角面可以和P形成四面体为入水体积（点P必须在水面上）。
三角面完全出水，丢弃。
三角面部分入水，分两种情况，两点入水和一点入水。两点入水，分成的三个三角形，将水面上部的丢弃；一点入水，分成的三个三角形将水面上的两个三角形丢弃。

于是，入水体积的求解收敛为两个问题：
求一个四面体的体积。
已知三角形的顶点A, B, C, 求与水面的交点问题。
浮力系统物理更新机制
三种第三方位置同步方法：
设置位置：会造成物体瞬移。
设置速度：通过计算位移差求出速度，在物理引擎进行物理模拟前应用到动态刚体上。
设置力：增加了一层间接性。
问题：第三方同步组件会每帧更新刚体的速度，浮力组件会每帧更新刚体受到的力，会造成位置的不一致（例如第三方刚体本来以速度v移动到位置X，但是浮力组件在速度方向上施加了阻力、浮力和升力，从而使物理系统算出的速度和v有偏差，导致最终物理模拟结束时物体的位置不是X）。
解决：浮力系统根据是否是第一方选择最终计算结果是力还是速度。
Component物理更新的过程：第一方通过引擎组件(EngineComponent)计算出驱动力，通过浮力组件(BuoyancyComponent)计算出浮力，将这些力在物理引擎进行物理模拟之前统一施加在刚体组件(PhyComponent)上；
第三方通过同步组件(SyncComponent)计算出下一帧的同步速度，通过浮力组件计算出的浮力推算出下一帧的浮力速度，将这两个速度糅合后，在物理引擎进行物理模拟之前设置在刚体组件上。

                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="/categories/GameDev/">GameDev</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-link" href="/tags/GameDev/">GameDev</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/09/15/容器/">容器</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-09-15</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/09/15/容器/">
                    <p>
                        
                            容器与镜像进程可见、可相互通信、共享一份文件系统
高级权限的进程可能破环低权限的进程
资源抢占
Linux通过 chroot 可将一个子目录变成根目录
namespace在资源视图上进行隔离
cgroup限制资源使用率
容器：容器是一个视图隔离、资源可限制、独立文件系统的进程集合
镜像：运行容器需要的所有文件集合
构建步骤所带来的文件系统的变化叫做changeset
镜像可进行分层复用
如何构建镜像？编写Dockerfile
// 表示以下的步骤是基于golang构建的
FROM golang:1.12-alpine 
// 类似于cd
WORKDIR /go/src/app
// 把数据拷入到容器内
COPY
//下载依赖
RUN go get -d -v ./...
//创建应用并安装
RUN go install -v ./...
//使用镜像默认程序的名字是什么
CMD [&quot;app&quot;]
有了这样一个Dockerfile之后就可以通过docker build构建镜像（存储到本地的）
docker registry进行镜像数据的存储和转发，通过 docker push可以将本地的镜像推送到镜像仓库中

                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="/categories/Docker/">Docker</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-link" href="/tags/Docker/">Docker</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/09/15/贪心专题/">贪心专题</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-09-15</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/09/15/贪心专题/">
                    <p>
                        
                            12. 整数转罗马数字12345678910111213141516// 处理上有优先级，对于当前的数，优先处理大于1000的部分，然后处理900，500，400.....（每一部分的处理方式也有固定的对应） --&gt; 贪心算法string intToRoman(int num) &#123;    string res;    vector&lt;int&gt; store&#123; 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 &#125;;    vector&lt;string&gt; strs&#123; "M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I" &#125;;    int n = store.size();    for (int i = 0; i &lt; n; i++)    &#123;        while (num &gt;= store[i])        &#123;            res.append(strs[i]);            num -= store[i];        &#125;    &#125;    return res;&#125;

13. 罗马数字转整数123456789101112131415int romanToInt(string s) &#123;    int res = 0;    map&lt;char, int&gt; hash&#123; &#123;'M', 1000&#125;, &#123;'D', 500&#125;, &#123;'C', 100&#125;, &#123;'L', 50&#125;, &#123;'X', 10&#125;, &#123;'V', 5&#125;, &#123;'I', 1&#125; &#125;;    for (int i = 0; i &lt; s.size(); i++)    &#123;        // s.size()为'\0',将'\0'赋给int型变量时，变量值为0；        if (hash[s[i]] &lt; hash[s[i + 1]])            res -= hash[s[i]];        else            res += hash[s[i]];    &#125;    cout &lt;&lt; s[s.size()];    return res;&#125;

55. 跳跃游戏在每个能到达的点检查从该点出发能到达的最远距离，最远距离超过nums.size() - 1则能到达终点
如何判断中间的某一点是否能到达？
因为是顺序遍历所有位置，每次遍历当前位置时都用maxPos检查是否能达到下一点，如果无法达到说明已经中断，此时使用break跳出循环

                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="/categories/Algorithm/">Algorithm</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-link" href="/tags/Algorithm/">Algorithm</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/09/08/回溯专题/">递归专题</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-09-08</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/09/08/回溯专题/">
                    <p>
                        
                            回溯算法的写法：画出递归树，找到状态变量（回溯函数的参数）根据题意确立结束条件找准选择列表判断是否需要剪枝（去掉重复的集合，即去掉递归树上的某些分支）做出选择，递归调用，进入下一层撤销选择77. 组合12345678910111213141516171819202122232425262728293031323334//给出n，k返回可能的组合vector&lt;vector&lt;int&gt;&gt; res;vector&lt;int&gt; temp;void dfs(int cur, int n, int k)&#123;    // 如果[cur, n]中元素的个数加上temo中元素的个数少于k，无法构成需要的组合    if (temp.size() + (n - cur + 1) &lt; k)    &#123;        return;    &#125;    // 如果temp的size == k，说明找到了组合，插入res    if (temp.size() == k)    &#123;        res.push_back(temp);        return;    &#125;    // 小于k的话继续往里添加元素    if (temp.size() &lt; k)    &#123;        // 考虑选择当前位置        temp.push_back(cur);        dfs(cur + 1, n, k);        temp.pop_back();        // 考虑不选择当前位置        dfs(cur + 1, n, k);    &#125;&#125;vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;    dfs(1, n, k);    return res;&#125;

39. 组合总和12345678910111213141516171819202122232425262728293031323334// 因为是数据可重复选择的情况，所以在回溯中，可选择跳过和不跳过当前数值，这样就会包括某一个值重复选择的情况，在不跳过当前值的选择中，需要确定当前数值没有超过所需值vector&lt;vector&lt;int&gt;&gt; res;vector&lt;int&gt; temp;void dfs(int cur, int n, vector&lt;int&gt;&amp; candidates, int remain)&#123;            if(cur == n)    &#123;        return;    &#125;    if(remain == 0)    &#123;        res.push_back(temp);        return;    &#125;    // 不选择当前位置，直接跳过    dfs(cur + 1, n, candidates, remain);    // 选择当前数，不跳过，不跳过的话需要判断当前数是否还能选择    if(candidates[cur] &lt;= remain)    &#123;        temp.push_back(candidates[cur]);        remain -= candidates[cur];         dfs(cur, n, candidates, remain);        temp.pop_back();    &#125;       &#125;vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;    int n = candidates.size();    dfs(0, n,candidates, target);    return res;&#125;

401. 二进制手表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748vector&lt;string&gt; res;unordered_map&lt;int, int&gt; hashdata = &#123;&#123;0,1&#125;,&#123;1,2&#125;,&#123;2,4&#125;,&#123;3,8&#125;,&#123;4,1&#125;,&#123;5,2&#125;,&#123;6,4&#125;,&#123;7,8&#125;,&#123;8,16&#125;,&#123;9,32&#125;&#125;;void backtrack(int num,int start,pair&lt;int,int&gt;&amp; time)&#123;    // 结束条件    if(num == 0)    &#123;        if(time.first &gt; 11 || time.second &gt; 59)        &#123;            return;        &#125;        string temp_hour = to_string(time.first);        string temp_minute = to_string(time.second);        if(temp_minute.size() == 1)        &#123;            temp_minute.insert(0, "0");        &#125;        res.push_back(temp_hour + ":" + temp_minute);        return;    &#125;    for(int i = start; i &lt; 10; i++)    &#123;        if(time.first &gt; 11 || time.second &gt; 59)        &#123;            continue;        &#125;        // 在本层中创建一个变量store用来存储当前的time值，回退时使用        pair&lt;int, int&gt; store = time;        if(i &lt; 4)        &#123;            time.first += hashdata[i];        &#125;        else        &#123;            time.second += hashdata[i];                &#125;        backtrack(num - 1, i + 1, time);        // 在同层回退时把前面存好的store再赋给time，时time恢复到原状态        time = store;            &#125;&#125;vector&lt;string&gt; readBinaryWatch(int num) &#123;    pair&lt;int, int&gt; time(0, 0);    backtrack(num, 0, time);    return res;&#125;

40. 组合总数212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 去重复结果组合使用pair计数，将给的数组里的相同数值的数放在一起去递归处理vector&lt;int&gt; temp;vector&lt;vector&lt;int&gt;&gt; res;vector&lt;pair&lt;int, int&gt;&gt; freq;void dfs(int pos, int rest)&#123;    if(rest == 0)    &#123;        res.push_back(temp);        return;    &#125;    if(pos == freq.size() || rest &lt; freq[pos].first)    &#123;        return;    &#125;        dfs(pos+1, rest);	// most用来判断处理相同数值的数时，进行几次递归，例如有五个2，但是target是7，那么只进行对2这个数值只进行三次递归    int most = min(rest / freq[pos].first, freq[pos].second);        for(int a = 1; a &lt;= most; a++)    &#123;        temp.push_back(freq[pos].first);        dfs(pos+1, rest - a * freq[pos].first);    &#125;    for(int b = 1; b &lt;= most; b++)    &#123;        temp.pop_back();    &#125;  &#125;vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;    // vector&lt;pair&lt;int, int&gt;&gt; freq;    sort(candidates.begin(), candidates.end());    for(int num : candidates)    &#123;        if(freq.empty() || num != freq.back().first)        &#123;            // 用push_back的话需要make_pair，用emplace_back则不需要            // freq.push_back(make_pair(num, 1));            freq.emplace_back(num, 1);        &#125;        else        &#123;            ++freq.back().second;        &#125;    &#125;    dfs(0, target);    return res;&#125;

216. 组合总数3123456789101112131415161718192021222324vector&lt;int&gt; temp;vector&lt;vector&lt;int&gt;&gt; res;void dfs(int cur, int remain, int k)&#123;    if(remain == 0 &amp;&amp; temp.size() == k)    &#123;        res.push_back(temp);        return;    &#125;    if(cur &gt; remain || temp.size() == k || cur &gt; 9)    &#123;        return;    &#125;    temp.push_back(cur);    dfs(cur+1, remain-cur, k);    temp.pop_back();    dfs(cur+1, remain, k);&#125;vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123;    dfs(1, n, k);    return res;&#125;

22. 括号生成回溯函数参数：要生成的括号对数n，存结果的vector rets，单个结果的string ret，当前左括号数open，当前右括号数close
用ret.size() == 2 * n判断是否将ret添加到结果rets
用open &lt; n判断是否继续添加左括号
用close &lt; open判断当前是否能添加右括号
46. 全排列什么情况适合使用回溯法：
通过探索所有可能的候选解来找出所有解
终止条件为：
1cur == len

回溯体结构为：
从已构造长度开始往后，逐个与当前位置进行数据交换
123456for(int i = cur; i &lt; len; i++)&#123;	swap(output[cur], output[i]);    backtrack(ret, output, cur+1, len);    swap(output[cur], output[i]); //回溯里一定要记得的撤销操作&#125;

78. 子集没啥说的，最基础的回溯….

                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="/categories/Algorithm/">Algorithm</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-link" href="/tags/Algorithm/">Algorithm</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/09/03/查找专题/">查找专题</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-09-03</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/09/03/查找专题/">
                    <p>
                        
                            4. 寻找两个正序数组的中位数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//二分查找//写一个查找第k大的函数，k值在运行过程中会慢慢减小int findKthElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k)&#123;    int m = nums1.size();    int n = nums2.size();    int index1 = 0;    int index2 = 0;    while (true)    &#123;        //nums1中的指针位置已经到了末尾，直接在num2中找剩下的第k大        if (index1 == m)        &#123;            return nums2[index2 + k - 1];        &#125;        if (index2 == n)        &#123;            return nums1[index1 + k - 1];        &#125;        if (k == 1)        &#123;            return min(nums1[index1], nums2[index2]);        &#125;		//边界检测，index如果加了k / 2 - 1越界了，就直接将新的index设置为数组的最后一位        int newIndex1 = min(index1 + k / 2 - 1, m - 1);        int newIndex2 = min(index2 + k / 2 - 1, n - 1);        int pivot1 = nums1[newIndex1];        int pivot2 = nums2[newIndex2];        if (pivot1 &lt;= pivot2)        &#123;            //更新k和index            k -= newIndex1 - index1 + 1;            index1 = newIndex1 + 1;        &#125;        else        &#123;            k -= newIndex2 - index2 + 1;            index2 = newIndex2 + 1;        &#125;    &#125;&#125;double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;    int totalLength = nums1.size() + nums2.size();    if (totalLength % 2 == 1)    &#123;	//奇数总数和偶数总数分开讨论        return findKthElement(nums1, nums2, (totalLength + 1) / 2);    &#125;    else    &#123;        return (findKthElement(nums1, nums2, totalLength / 2) + findKthElement(nums1, nums2, totalLength / 2 + 1)) / 2.0;    &#125;&#125;

34. 在排序数组中查找元素的第一个和最后一个位置排序数组直接联想二分查找
对二分查找做适合题目要求的改动，有多个连续的target值，寻找左边界时要找到最左面的target下标，则需要在findLeft函数中添加判断：
12if(nums[mid] == target)	right = mid;

使有边界逐渐向左逼近，以保证最后走出 while(left &lt; right) 循环时，left在多个相同的target中的最左面
在findRight函数中不仅需要添加判断：
12if(nums[mid] == target)	left = mid;

特别注意，还需要修改mid的计算：
1mid = (left + right + 1) / 2

这里如果不加1的话，当left == right-1时，计算mid永远等于left，无法退出循环
347. 前 K 个高频元素12345678910111213141516171819202122232425262728293031323334353637383940// 这里的static的添加是因为sory()第三个参数是个函数指针，然而cmp函数是一个非静态成员函数，非静态成员函数指针和普通函数指针是有区别的，为防止报错在类内的成员函数定义前添加static，或者把cmp函数定义写在类外static bool cmp(pair&lt;int,int&gt; a, pair&lt;int,int&gt; b)    &#123;        return a.second &gt; b.second;    &#125;    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;        map&lt;int,int&gt; countMap;        int n = nums.size();        map&lt;int, int&gt;::iterator it;        for(int i = 0; i &lt; n; i++)        &#123;            // 判断map中某个key是否存在，使用find()，（find()返回的是迭代器）            it = countMap.find(nums[i]);            if(it != countMap.end())            &#123;                countMap[nums[i]]++;            &#125;            else            &#123;                // map中插入新的&lt;key, value&gt;对                countMap.insert(pair&lt;int,int&gt;(nums[i], 1));            &#125;        &#125;        // map没有sort()函数，因为map不是线性结构，所以为了排序，将map中的pair形式的成员放到vector中再进行排序        vector&lt;pair&lt;int,int&gt;&gt; vec;        for(map&lt;int,int&gt;::iterator it = countMap.begin(); it != countMap.end(); it++)        &#123;            vec.push_back(pair&lt;int,int&gt;(it-&gt;first, it-&gt;second));        &#125;        sort(vec.begin(), vec.end(), cmp);        vector&lt;int&gt; res;        vector&lt;pair&lt;int,int&gt;&gt;::iterator iter = vec.begin();        while(k)        &#123;            res.push_back(iter-&gt;first);            iter++;            k--;        &#125;        return res;    &#125;


                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="/categories/Algorithm/">Algorithm</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-link" href="/tags/Algorithm/">Algorithm</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/09/03/滑动窗口专题/">滑动窗口专题</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-09-03</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/09/03/滑动窗口专题/">
                    <p>
                        
                            3.  无重复的最长字串1234567891011121314151617181920212223int lengthOfLongestSubstring(string s) &#123;    int res = 0;    //右指针    int rp = -1;    unordered_set&lt;char&gt; seri;    //i是左指针    for (int i = 0; i &lt; s.size(); i++)    &#123;        //每次循环开始的时候把上一次左指针指向的值删掉        if (i != 0)        &#123;            seri.erase(s[i - 1]);        &#125;        //例如abcdcefgh，到了第二个c会产生重复，rp会停在d这里，然后删掉a继续循环，发现仍不满足!seri.count(s[rp + 1])，因为c并没被删掉，所以跳过while继续循环，删掉b，知道删掉第一个c，while中才满足!seri.count(s[rp + 1])，这时才能进入while，rp继续向后走        while (rp + 1 &lt; s.size() &amp;&amp; !seri.count(s[rp + 1]))        &#123;            seri.insert(s[rp + 1]);            rp++;        &#125;        res = max(res, rp - i + 1);    &#125;    return res;&#125;

76. 最小覆盖字串用两个map分别记录所需包含的字母及其个数(ori)，以及当前窗口内所含所需字母及其个数(cnt)
每次检查时，检查ori中的每个key对应的value和cnt中对应的value，cnt中的值不能小于ori，不然意味着当前窗口未完全包含所需的所有字符
1234567891011bool check(unordered_map&lt;char, int&gt;&amp; ori, unordered_map&lt;char, int&gt;&amp; cnt)&#123;    for(const auto&amp; p : ori)    &#123;    	if(cnt[p.first] &lt; p.second)        &#123;        	return false;        &#125;    &#125;    return true;&#125;

当check满足条件，检查是否需要更新最小窗口长度len和结果起始点ansL，并且由于check满足条件需要将窗口左侧边界右移一位，所以此时如果最左侧的字母为ori中的一员，cnt对应的key的value减一
12345678910111213while(check(ori, cnt) &amp;&amp; l &lt;= r)&#123;	if(r - l &lt; minLength)	&#123;		minLength = r - l;		ansL = l;	&#125;    if(ori.find(s[l]) != ori.end())    &#123;    	--cnt[s[l]];    &#125;	l++;&#125;


                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="/categories/Algorithm/">Algorithm</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-link" href="/tags/Algorithm/">Algorithm</a>
                    
                </div>
            
        </article>
    



            </div>
            <div class="aside">
    
        <div class="box widget">
    <div class="introduction">
        <p><img src="/images/avatar.jpg" alt="head-sculpture"></p>
        <p class="name">
            CHAsencenge
        </p>
        <p class="slogan">解字</p>
    </div>
</div>
    
        
<div class="box widget">
    <div class="title">Recent</div>
    <ul class="item-box">
        
            
                <li><a href="/2020/11/30/手撸算法终版/">手撸算法终版</a></li>
            
        
            
                <li><a href="/2020/10/29/哈希专题/">哈希专题</a></li>
            
        
            
                <li><a href="/2020/10/29/特殊技巧专题/">特殊技巧专题</a></li>
            
        
            
                <li><a href="/2020/10/29/栈和队列专题/">栈和队列专题</a></li>
            
        
            
                <li><a href="/2020/10/28/树图专题/">树专题</a></li>
            
        
            
                <li><a href="/2020/10/28/空间换时间专题/">空间换时间专题</a></li>
            
        
            
                <li><a href="/2020/10/25/C-Lambda表达式/">C++ Lambda表达式</a></li>
            
        
            
                <li><a href="/2020/10/16/双指针专题/">双指针专题</a></li>
            
        
    </ul>
</div>

    
        
    <div class="box widget">
        <div class="title">Categories</div>
        <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GameDev/">GameDev</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Laya/">Laya</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Light-Frequency-Authenticate/">Light Frequency Authenticate</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/LoRa/">LoRa</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Unity/">Unity</a><span class="category-list-count">5</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Unity/Unreal/">Unreal</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Writing/">Writing</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cpp/">cpp</a><span class="category-list-count">3</span></li></ul>
    </div>

    
        
  <div class="box widget">
    <div class="title">Archives</div>
    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">2020-11</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">2020-10</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">2020-09</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">2020-08</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">2020-07</a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">2019-11</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">2019-09</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">2019-07</a><span class="archive-list-count">6</span></li></ul>
  </div>

    
        
    <div class="box widget">
        <div class="title">Tags</div>
        <div class="item-box cloud-label">
            <a href="/tags/Algorithm/" style="font-size: 20px;">Algorithm</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/GameDev/" style="font-size: 14px;">GameDev</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/Gradle/" style="font-size: 10px;">Gradle</a> <a href="/tags/Hexo/" style="font-size: 12px;">Hexo</a> <a href="/tags/Laya/" style="font-size: 16px;">Laya</a> <a href="/tags/LoRa/" style="font-size: 10px;">LoRa</a> <a href="/tags/Python/" style="font-size: 16px;">Python</a> <a href="/tags/Unity/" style="font-size: 18px;">Unity</a> <a href="/tags/Unreal/" style="font-size: 10px;">Unreal</a> <a href="/tags/Writing/" style="font-size: 12px;">Writing</a> <a href="/tags/cpp/" style="font-size: 14px;">cpp</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/lightFre/" style="font-size: 10px;">lightFre</a> <a href="/tags/writing/" style="font-size: 10px;">writing</a> <a href="/tags/远程登录/" style="font-size: 10px;">远程登录</a>
        </div>
    </div>

    
</div>
        </section>
        <footer class="footer">
    <div class="global-width footer-box">
        <div class="copyright">
            <span>Copyright &copy; 2019</span>
            <span class="dotted">|</span>
            <span>Powered by <a href="https://hexo.io/">Hexo</a></span>
            <span class="dotted">|</span>
            <span>Theme by <a href="javascript:">Loren</a></span>
            <span class="dotted">|</span>
            <span><a href="http://www.beian.miit.gov.cn">浙ICP备18016660号-1</a></span>
        </div>
    </div>
</footer>
    </div>

<script>
    hljs.initHighlightingOnLoad();
</script>
</body>
</html>