<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">




    <meta name="keywords" content>



    <meta name="description" content="解字无果">


<meta name="Robots" content="all">


    <title>解字</title>


<link rel="icon" href="/images/favicon.ico">
<link rel="stylesheet" href="/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/atom-one-dark.css">
<link rel="stylesheet" href="/css/style.css">
<script src="/js/highlight.min.js"></script>
</head>
<body>
    <div class="main-container">
        <header class="header">
    <div class="global-width">
        <nav class="nav-box">
            
                <a class="nav-item" href="/">Home</a>
            
                <a class="nav-item" href="/resume">Resume</a>
            
                <a class="nav-item" href="/mood" target="_blank">Mood</a>
            
                <a class="nav-item" href="/amusement/tetris" target="_blank">Amusement</a>
            
                <a class="nav-item" href="/about">About</a>
            
        </nav>
    </div>
</header>

        <section class="content global-width">
            <div class="main">
                
    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/09/25/腾讯游戏开发精粹笔记/">腾讯游戏开发精粹笔记</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-09-25</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/09/25/腾讯游戏开发精粹笔记/">
                    <p>
                        
                            一、游戏数学1.基于SDF的摇杆移动SDF：SDF全称Signed Distance Field（有号距离场），定义为空间中的点到形状表面的最小距离，并用正值表示点在形状外部，负值表示点在形状内部。
为什么要使用SDF？空间换时间，在O(1)时间复杂度计算出是否碰撞。
如何判断碰撞？基于已有SDF信息的栅格，使用其邻近四个角的SD信息进行插值，得到当前点的SD，若SD&lt;=0, 则判定该点和碰撞物发生了碰撞。
插值获得任意点的SD值：123456789101112//计算位置pos的SD值//每个栅格的实际尺寸为grid，横向栅格数量为widthpublic float Sample(Vector2 pos)&#123;    pos = pos / grid;    int fx = Mathf.FloorToInt(pos.x);    int fy = Mathf.FloorToInt(pos.y);    float rx = pos.x - fx;    float ry = pos.y - fy;    int i = fy * width + fx;    return (sdf[i]*(1-rx) + sdf[i+1]*rx)*(1-ry) + (sdf[i+width]*(1-rx) + sdf[i+width+1]*rx)*ry;&#125;

如何实现发生碰撞后绕障碍物滑行？
v表示摇杆方向，与障碍物发生碰撞后需要沿着v’方向滑行，n为碰撞法线，v’和v有以上关系。
如何获取碰撞法线n？利用SDF的梯度作为碰撞法线。
求梯度方向：12345678public Vector2 Gradient(Vector2 pos)&#123;    float delta = 1f;    return 0.5f * new Vector2(    Sample(new Vector2(pos.x+delta, pos.y)) - Sample(new Vector2(pos.x-delta, pos.y)),     Sample(new Vector2(pos.x, pos.y+delta)) - Sample(new Vector2(pos.x, pos.y-delta))    );&#125;

发生碰撞后实际移动方向代码：123456789101112131415161718192021222324252627282930//获取在移动过程使用SDF得到的最佳位置public Vector2 GetValidPositionBySDF(Vector2 pos, Vector2 dir, float speed)&#123;    Vector2 newPos = pos + dir * speed;    float SD = Sample(newPos);        //不可行走    if(SD &lt; playerRadius)    &#123;        Vector2 gradient = Gradient(newPos);        Vector2 adjustDir = dir - gradient * Vector2.Dot(gradient, dir);        newPos = pos + adjustDir.normalized * speed;    &#125;        //多次迭代    for(int i = 0; i &lt; 3; i++)    &#123;        SD = Sample(newPos);        if(SD &gt;= playerRadius)            break;        newPos += Gradient(newPos) * (playerRadius - SD);    &#125;        //避免往返    if(Vector2.Dot(newPos - pos, dir) &lt; 0)    &#123;        newPos = pos;    &#125;    return newPos;&#125;

角色不能越过障碍物的远距离移动用于当校色进行瞬时远距离移动但不能越过障碍物的情况。
使用连续碰撞检测规避穿越障碍物的情况，具体方法是圆盘投射（Disk Casting）。
使用圆盘投射计算位置：123456789101112131415//oriPos:原始位置，dir:冲刺方向，radius:角色半径，maxDist:最大冲刺距离public Vector2 DiskCast(Vector2 origin, Vector2 dir, float radius, float maxDist)&#123;    float t = 0f;    while(true)    &#123;        Vector2 p = origin + dir * t;        float sd = Sample(p);        if(sd &lt;= radius)            return p;        t += sd - radius;        if(t &gt;= maxDist)            return origin + dir * maxDist;    &#125;&#125;

动态地图在均匀网格地图上，当角色在一帧内的行走距离不会超过单个网格大小时，可以通过检测每一帧与玩家所在网格相邻的8个网格的碰撞来实现规避障碍物的功能。

红色为障碍物区域，虚线圆圈为角色。
实现规避障碍物：12345678910111213141516171819202122232425262728293031323334353637383940414243float EvalSDF(Vector2 p)&#123;    //坐标离散成网格    int x = posToGridX(p);    int y = posToGridY(p);    float dist = cellSize;    int center = grid[y * width + x];    //WALL格子不可行走    //检测与玩家最近的距离    if(center == WALL)    &#123;        dist = min(dist, sdBox(centerPos - vecTopLeft, cellExtents));    &#125;    int topleft = grid[(y - 1) * width + (x - 1)];    if(topleft == WALL)    &#123;        dist = min(dist, sdBox(centerPos - vecTop, cellExtents));    &#125;    //...    return dist;&#125;Vector2 EvalGradient(Vector2 p)&#123;    //...&#125;void Update()&#123;    //新目标位置    Vector2 nextPlayerPos = playerPos + moveDir * moveSpeed;    //目标位置的最近距离    float d = EvalSDF(nextPlayerPos);    //距离小于玩家半径，有穿插    if(d &lt; playerRadius)    &#123;        //计算最近表面的法线        Vector2 n = EvalGradient(nextPlayerPos);        //将玩家推出障碍区域        nextPlayerPos = nextPlayerPos + n * (playerRadius - d);    &#125;    playerPos = nextPlayerPos;&#125;

场景中的其他障碍物，如较大的汽车、其他玩家等，可通过矩形、圆形的SDF函数来表示，并将结果与网格地图取出的SDF做交集操作。
圆盘SDF:12345//x为任意点坐标，c为圆盘中心，r为圆盘半径float sdCircle(Vector2 x, Vector2 c, float r)&#123;    return (x - c).length() - r;&#125;

矩形SDF:d = (x - c)R(-θ) - b
Φx = min(max(dx, dy), 0) + ||max(d, 0)||

1234567//x为任意点坐标，c为矩形中心，rot为矩形旋转角度，b为矩形边长float sdBox(Vector2 x, Vector c, Vector2 rot, Vector2 b)&#123;    Vector2 p = Vector2.Dot(x - c, -rot);    Vector2 d = Vector2.Abs(p) - b;    return Mathf.Min(Mathf.Max(d.x, d.y), 0f) + Vector2.Max(d, Vector2.zero).Length(); &#125;

2. 高性能的定点数实现方案用途解决不同平台上的浮点数运算结果不同而导致的对帧同步的严重影响。
32位浮点数结构
S=0时为正数，S=1时为负数
基于整数的二进制表示的定点数原理设a为定点数，f(a)为这个定点数对应的整数值
a = 2^-n^f(a)
32和64位定点数表示原理
32位定点数表示的范围：[-2^21^, 2^21^ - 2^-10^]
64位定点数表示的范围：[-2^31^, 2^31^ - 2^-32^]
定点数四则运算a + b = 2^-n^ (f(a) + f(b))
a - b = 2^-n^ (f(a) - f(b))
ab = (2^-n^)^2^ f(a) f(b) = 2^-n^ (2^-n^ f(a) f(b))
a / b = 2^-n^ (2^n^ f(a) / f(b))
二、游戏物理1. 一种高效的弧长参数化路径系统需求在跑酷游戏中，人物的移动靠路径引导；想要实现“弧长参数化”的特性—即令曲线参数t与曲线长度为L为线性关系，从而将参数t的线性变化映射到长度的线性变化上，实现曲线上的匀线速度运动。
曲线路径系统需求：路径布置简单，最直观的就是布置路点。
修改具有局部性，修改一个路点只会影响上下游。
曲线至少具有C1连续性，满足基本的光滑需求。
两个路点之间的曲线可以是异面曲线，等同于可以自由控制邻接路点曲线的方向。
与曲线相关的计算尽量简单，尽量少地进行迭代计算。
端点间二次样条的构建为什么要拼接两条二次曲线？要求两个路点可以自由控制位置和朝向（切线方向），单一的一段二次曲线自由度不够。
二次样条曲线：
起点P0、起点切线T0、终点P1、终点切线T1。
f1(t) = a1t^2^ + b1t + c1
f2(t) = a2t^2^ + b2t + c2
为了将分段曲线当作一段曲线使用，需将两段曲线的参数t归一化到统一的[0, 1]范围内，fs(0) = P0，fs(1) = P1。

例如当L1长度为4，L2长度为6，归一化t = 0.3时，fs(t) = fs(0.3) = f1(0.3 x 10 / 4) = f1(3/4)，恰好对应L1的四分之三位置。
路径的构建路径为路点间曲线的拼接，切线的设置模仿Catmull-Rom这类Cardinal曲线的做法：路点i处的切线由路点i-1和路点i+1的位置决定：
Ti = τ(Pi+1 - Pi-1), τ为切线的缩放因子（张弛因子）

使用邻接路点的信息构建曲线时，将邻接路点转换到自己的局部坐标系下，在上图的构建中，Pi处于坐标原点且旋转为(0, 0, 0)，最后在使用路径时，每段曲线的计算结果要做一次从局部到世界坐标系的转换，好处是路径作为一个整体不受刚体变换的影响，适合游戏中场景动态拼接的需求。
弧长的重参数化（arc-length parametrization）为什么要做弧长的重参数化？可近似理解为在曲线上，每一点处的速度不同，相同的Δt内对应“走过”的弧长也不相同。
例如，对于曲线：

直接用t取点，具有明显不均匀现象：

arc-length:定义一个映射Δ: [a, b] -&gt; [0, L], 获取原弧线参数t的定义域到弧长区间上的一个满射：

其反函数设为Φ(s)，那么在给定s位置下，对应曲线参数为Φ(s)，对于上述曲线，先求Δ(t)，再求其反函数：

其反函数：

重参数化形式：

arc-length参数化后结果：

曲线上的简单运动法平面定义：过空间曲线的切点并且与切线垂直的平面。
相邻路径的切换路径切换的过程中，使用当前路径上的基准点的法平面与另一路径的交点（等位点），由于路径的切换不能瞬时完成，将当前基准点变换到相邻路径基准点的局部坐标系下，将变换后的值和(O, X, Y, Z)插值的结果转换到世界坐标系，作为当前基准点及其关联的局部坐标系输入给物理模块。

曲线上的旋转插值
2. 船的物理模拟及同步设计船的两种刚体移动碰撞体：用于计算浮力的动态刚体
射击碰撞体：用来做射击检测的动力学动态刚体
浮力计算中计算多面体入水体积分成三角面判断，一个三角面只有三种状态：完全入水、完全出水、部分出水。
三角面完全入水，则三角面可以和P形成四面体为入水体积（点P必须在水面上）。
三角面完全出水，丢弃。
三角面部分入水，分两种情况，两点入水和一点入水。两点入水，分成的三个三角形，将水面上部的丢弃；一点入水，分成的三个三角形将水面上的两个三角形丢弃。

于是，入水体积的求解收敛为两个问题：
求一个四面体的体积。
已知三角形的顶点A, B, C, 求与水面的交点问题。
浮力系统物理更新机制
三种第三方位置同步方法：
设置位置：会造成物体瞬移。
设置速度：通过计算位移差求出速度，在物理引擎进行物理模拟前应用到动态刚体上。
设置力：增加了一层间接性。
问题：第三方同步组件会每帧更新刚体的速度，浮力组件会每帧更新刚体受到的力，会造成位置的不一致（例如第三方刚体本来以速度v移动到位置X，但是浮力组件在速度方向上施加了阻力、浮力和升力，从而使物理系统算出的速度和v有偏差，导致最终物理模拟结束时物体的位置不是X）。
解决：浮力系统根据是否是第一方选择最终计算结果是力还是速度。
Component物理更新的过程：第一方通过引擎组件(EngineComponent)计算出驱动力，通过浮力组件(BuoyancyComponent)计算出浮力，将这些力在物理引擎进行物理模拟之前统一施加在刚体组件(PhyComponent)上；
第三方通过同步组件(SyncComponent)计算出下一帧的同步速度，通过浮力组件计算出的浮力推算出下一帧的浮力速度，将这两个速度糅合后，在物理引擎进行物理模拟之前设置在刚体组件上。

                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="/categories/GameDev/">GameDev</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-link" href="/tags/GameDev/">GameDev</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/09/15/容器/">容器</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-09-15</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/09/15/容器/">
                    <p>
                        
                            容器与镜像进程可见、可相互通信、共享一份文件系统
高级权限的进程可能破环低权限的进程
资源抢占
Linux通过 chroot 可将一个子目录变成根目录
namespace在资源视图上进行隔离
cgroup限制资源使用率
容器：容器是一个视图隔离、资源可限制、独立文件系统的进程集合
镜像：运行容器需要的所有文件集合
构建步骤所带来的文件系统的变化叫做changeset
镜像可进行分层复用
如何构建镜像？编写Dockerfile
// 表示以下的步骤是基于golang构建的
FROM golang:1.12-alpine 
// 类似于cd
WORKDIR /go/src/app
// 把数据拷入到容器内
COPY
//下载依赖
RUN go get -d -v ./...
//创建应用并安装
RUN go install -v ./...
//使用镜像默认程序的名字是什么
CMD [&quot;app&quot;]
有了这样一个Dockerfile之后就可以通过docker build构建镜像（存储到本地的）
docker registry进行镜像数据的存储和转发，通过 docker push可以将本地的镜像推送到镜像仓库中

                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="/categories/Docker/">Docker</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-link" href="/tags/Docker/">Docker</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/09/15/贪心专题/">贪心专题</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-09-15</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/09/15/贪心专题/">
                    <p>
                        
                            12. 整数转罗马数字12345678910111213141516// 处理上有优先级，对于当前的数，优先处理大于1000的部分，然后处理900，500，400.....（每一部分的处理方式也有固定的对应） --&gt; 贪心算法string intToRoman(int num) &#123;    string res;    vector&lt;int&gt; store&#123; 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 &#125;;    vector&lt;string&gt; strs&#123; "M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I" &#125;;    int n = store.size();    for (int i = 0; i &lt; n; i++)    &#123;        while (num &gt;= store[i])        &#123;            res.append(strs[i]);            num -= store[i];        &#125;    &#125;    return res;&#125;

13. 罗马数字转整数123456789101112131415int romanToInt(string s) &#123;    int res = 0;    map&lt;char, int&gt; hash&#123; &#123;'M', 1000&#125;, &#123;'D', 500&#125;, &#123;'C', 100&#125;, &#123;'L', 50&#125;, &#123;'X', 10&#125;, &#123;'V', 5&#125;, &#123;'I', 1&#125; &#125;;    for (int i = 0; i &lt; s.size(); i++)    &#123;        // s.size()为'\0',将'\0'赋给int型变量时，变量值为0；        if (hash[s[i]] &lt; hash[s[i + 1]])            res -= hash[s[i]];        else            res += hash[s[i]];    &#125;    cout &lt;&lt; s[s.size()];    return res;&#125;

55. 跳跃游戏在每个能到达的点检查从该点出发能到达的最远距离，最远距离超过nums.size() - 1则能到达终点
如何判断中间的某一点是否能到达？
因为是顺序遍历所有位置，每次遍历当前位置时都用maxPos检查是否能达到下一点，如果无法达到说明已经中断，此时使用break跳出循环

                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="/categories/Algorithm/">Algorithm</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-link" href="/tags/Algorithm/">Algorithm</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/09/08/回溯专题/">递归专题</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-09-08</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/09/08/回溯专题/">
                    <p>
                        
                            回溯算法的写法：画出递归树，找到状态变量（回溯函数的参数）根据题意确立结束条件找准选择列表判断是否需要剪枝（去掉重复的集合，即去掉递归树上的某些分支）做出选择，递归调用，进入下一层撤销选择77. 组合12345678910111213141516171819202122232425262728293031323334//给出n，k返回可能的组合vector&lt;vector&lt;int&gt;&gt; res;vector&lt;int&gt; temp;void dfs(int cur, int n, int k)&#123;    // 如果[cur, n]中元素的个数加上temo中元素的个数少于k，无法构成需要的组合    if (temp.size() + (n - cur + 1) &lt; k)    &#123;        return;    &#125;    // 如果temp的size == k，说明找到了组合，插入res    if (temp.size() == k)    &#123;        res.push_back(temp);        return;    &#125;    // 小于k的话继续往里添加元素    if (temp.size() &lt; k)    &#123;        // 考虑选择当前位置        temp.push_back(cur);        dfs(cur + 1, n, k);        temp.pop_back();        // 考虑不选择当前位置        dfs(cur + 1, n, k);    &#125;&#125;vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;    dfs(1, n, k);    return res;&#125;

39. 组合总和12345678910111213141516171819202122232425262728293031323334// 因为是数据可重复选择的情况，所以在回溯中，可选择跳过和不跳过当前数值，这样就会包括某一个值重复选择的情况，在不跳过当前值的选择中，需要确定当前数值没有超过所需值vector&lt;vector&lt;int&gt;&gt; res;vector&lt;int&gt; temp;void dfs(int cur, int n, vector&lt;int&gt;&amp; candidates, int remain)&#123;            if(cur == n)    &#123;        return;    &#125;    if(remain == 0)    &#123;        res.push_back(temp);        return;    &#125;    // 不选择当前位置，直接跳过    dfs(cur + 1, n, candidates, remain);    // 选择当前数，不跳过，不跳过的话需要判断当前数是否还能选择    if(candidates[cur] &lt;= remain)    &#123;        temp.push_back(candidates[cur]);        remain -= candidates[cur];         dfs(cur, n, candidates, remain);        temp.pop_back();    &#125;       &#125;vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;    int n = candidates.size();    dfs(0, n,candidates, target);    return res;&#125;

401. 二进制手表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748vector&lt;string&gt; res;unordered_map&lt;int, int&gt; hashdata = &#123;&#123;0,1&#125;,&#123;1,2&#125;,&#123;2,4&#125;,&#123;3,8&#125;,&#123;4,1&#125;,&#123;5,2&#125;,&#123;6,4&#125;,&#123;7,8&#125;,&#123;8,16&#125;,&#123;9,32&#125;&#125;;void backtrack(int num,int start,pair&lt;int,int&gt;&amp; time)&#123;    // 结束条件    if(num == 0)    &#123;        if(time.first &gt; 11 || time.second &gt; 59)        &#123;            return;        &#125;        string temp_hour = to_string(time.first);        string temp_minute = to_string(time.second);        if(temp_minute.size() == 1)        &#123;            temp_minute.insert(0, "0");        &#125;        res.push_back(temp_hour + ":" + temp_minute);        return;    &#125;    for(int i = start; i &lt; 10; i++)    &#123;        if(time.first &gt; 11 || time.second &gt; 59)        &#123;            continue;        &#125;        // 在本层中创建一个变量store用来存储当前的time值，回退时使用        pair&lt;int, int&gt; store = time;        if(i &lt; 4)        &#123;            time.first += hashdata[i];        &#125;        else        &#123;            time.second += hashdata[i];                &#125;        backtrack(num - 1, i + 1, time);        // 在同层回退时把前面存好的store再赋给time，时time恢复到原状态        time = store;            &#125;&#125;vector&lt;string&gt; readBinaryWatch(int num) &#123;    pair&lt;int, int&gt; time(0, 0);    backtrack(num, 0, time);    return res;&#125;

40. 组合总数212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 去重复结果组合使用pair计数，将给的数组里的相同数值的数放在一起去递归处理vector&lt;int&gt; temp;vector&lt;vector&lt;int&gt;&gt; res;vector&lt;pair&lt;int, int&gt;&gt; freq;void dfs(int pos, int rest)&#123;    if(rest == 0)    &#123;        res.push_back(temp);        return;    &#125;    if(pos == freq.size() || rest &lt; freq[pos].first)    &#123;        return;    &#125;        dfs(pos+1, rest);	// most用来判断处理相同数值的数时，进行几次递归，例如有五个2，但是target是7，那么只进行对2这个数值只进行三次递归    int most = min(rest / freq[pos].first, freq[pos].second);        for(int a = 1; a &lt;= most; a++)    &#123;        temp.push_back(freq[pos].first);        dfs(pos+1, rest - a * freq[pos].first);    &#125;    for(int b = 1; b &lt;= most; b++)    &#123;        temp.pop_back();    &#125;  &#125;vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;    // vector&lt;pair&lt;int, int&gt;&gt; freq;    sort(candidates.begin(), candidates.end());    for(int num : candidates)    &#123;        if(freq.empty() || num != freq.back().first)        &#123;            // 用push_back的话需要make_pair，用emplace_back则不需要            // freq.push_back(make_pair(num, 1));            freq.emplace_back(num, 1);        &#125;        else        &#123;            ++freq.back().second;        &#125;    &#125;    dfs(0, target);    return res;&#125;

216. 组合总数3123456789101112131415161718192021222324vector&lt;int&gt; temp;vector&lt;vector&lt;int&gt;&gt; res;void dfs(int cur, int remain, int k)&#123;    if(remain == 0 &amp;&amp; temp.size() == k)    &#123;        res.push_back(temp);        return;    &#125;    if(cur &gt; remain || temp.size() == k || cur &gt; 9)    &#123;        return;    &#125;    temp.push_back(cur);    dfs(cur+1, remain-cur, k);    temp.pop_back();    dfs(cur+1, remain, k);&#125;vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123;    dfs(1, n, k);    return res;&#125;

22. 括号生成回溯函数参数：要生成的括号对数n，存结果的vector rets，单个结果的string ret，当前左括号数open，当前右括号数close
用ret.size() == 2 * n判断是否将ret添加到结果rets
用open &lt; n判断是否继续添加左括号
用close &lt; open判断当前是否能添加右括号
46. 全排列什么情况适合使用回溯法：
通过探索所有可能的候选解来找出所有解
终止条件为：
1cur == len

回溯体结构为：
从已构造长度开始往后，逐个与当前位置进行数据交换
123456for(int i = cur; i &lt; len; i++)&#123;	swap(output[cur], output[i]);    backtrack(ret, output, cur+1, len);    swap(output[cur], output[i]); //回溯里一定要记得的撤销操作&#125;

78. 子集没啥说的，最基础的回溯….

                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="/categories/Algorithm/">Algorithm</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-link" href="/tags/Algorithm/">Algorithm</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/09/03/查找专题/">查找专题</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-09-03</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/09/03/查找专题/">
                    <p>
                        
                            4. 寻找两个正序数组的中位数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//二分查找//写一个查找第k大的函数，k值在运行过程中会慢慢减小int findKthElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k)&#123;    int m = nums1.size();    int n = nums2.size();    int index1 = 0;    int index2 = 0;    while (true)    &#123;        //nums1中的指针位置已经到了末尾，直接在num2中找剩下的第k大        if (index1 == m)        &#123;            return nums2[index2 + k - 1];        &#125;        if (index2 == n)        &#123;            return nums1[index1 + k - 1];        &#125;        if (k == 1)        &#123;            return min(nums1[index1], nums2[index2]);        &#125;		//边界检测，index如果加了k / 2 - 1越界了，就直接将新的index设置为数组的最后一位        int newIndex1 = min(index1 + k / 2 - 1, m - 1);        int newIndex2 = min(index2 + k / 2 - 1, n - 1);        int pivot1 = nums1[newIndex1];        int pivot2 = nums2[newIndex2];        if (pivot1 &lt;= pivot2)        &#123;            //更新k和index            k -= newIndex1 - index1 + 1;            index1 = newIndex1 + 1;        &#125;        else        &#123;            k -= newIndex2 - index2 + 1;            index2 = newIndex2 + 1;        &#125;    &#125;&#125;double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;    int totalLength = nums1.size() + nums2.size();    if (totalLength % 2 == 1)    &#123;	//奇数总数和偶数总数分开讨论        return findKthElement(nums1, nums2, (totalLength + 1) / 2);    &#125;    else    &#123;        return (findKthElement(nums1, nums2, totalLength / 2) + findKthElement(nums1, nums2, totalLength / 2 + 1)) / 2.0;    &#125;&#125;

34. 在排序数组中查找元素的第一个和最后一个位置排序数组直接联想二分查找
对二分查找做适合题目要求的改动，有多个连续的target值，寻找左边界时要找到最左面的target下标，则需要在findLeft函数中添加判断：
12if(nums[mid] == target)	right = mid;

使有边界逐渐向左逼近，以保证最后走出 while(left &lt; right) 循环时，left在多个相同的target中的最左面
在findRight函数中不仅需要添加判断：
12if(nums[mid] == target)	left = mid;

特别注意，还需要修改mid的计算：
1mid = (left + right + 1) / 2

这里如果不加1的话，当left == right-1时，计算mid永远等于left，无法退出循环
347. 前 K 个高频元素12345678910111213141516171819202122232425262728293031323334353637383940// 这里的static的添加是因为sory()第三个参数是个函数指针，然而cmp函数是一个非静态成员函数，非静态成员函数指针和普通函数指针是有区别的，为防止报错在类内的成员函数定义前添加static，或者把cmp函数定义写在类外static bool cmp(pair&lt;int,int&gt; a, pair&lt;int,int&gt; b)    &#123;        return a.second &gt; b.second;    &#125;    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;        map&lt;int,int&gt; countMap;        int n = nums.size();        map&lt;int, int&gt;::iterator it;        for(int i = 0; i &lt; n; i++)        &#123;            // 判断map中某个key是否存在，使用find()，（find()返回的是迭代器）            it = countMap.find(nums[i]);            if(it != countMap.end())            &#123;                countMap[nums[i]]++;            &#125;            else            &#123;                // map中插入新的&lt;key, value&gt;对                countMap.insert(pair&lt;int,int&gt;(nums[i], 1));            &#125;        &#125;        // map没有sort()函数，因为map不是线性结构，所以为了排序，将map中的pair形式的成员放到vector中再进行排序        vector&lt;pair&lt;int,int&gt;&gt; vec;        for(map&lt;int,int&gt;::iterator it = countMap.begin(); it != countMap.end(); it++)        &#123;            vec.push_back(pair&lt;int,int&gt;(it-&gt;first, it-&gt;second));        &#125;        sort(vec.begin(), vec.end(), cmp);        vector&lt;int&gt; res;        vector&lt;pair&lt;int,int&gt;&gt;::iterator iter = vec.begin();        while(k)        &#123;            res.push_back(iter-&gt;first);            iter++;            k--;        &#125;        return res;    &#125;


                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="/categories/Algorithm/">Algorithm</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-link" href="/tags/Algorithm/">Algorithm</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/09/03/滑动窗口专题/">滑动窗口专题</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-09-03</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/09/03/滑动窗口专题/">
                    <p>
                        
                            3.  无重复的最长字串1234567891011121314151617181920212223int lengthOfLongestSubstring(string s) &#123;    int res = 0;    //右指针    int rp = -1;    unordered_set&lt;char&gt; seri;    //i是左指针    for (int i = 0; i &lt; s.size(); i++)    &#123;        //每次循环开始的时候把上一次左指针指向的值删掉        if (i != 0)        &#123;            seri.erase(s[i - 1]);        &#125;        //例如abcdcefgh，到了第二个c会产生重复，rp会停在d这里，然后删掉a继续循环，发现仍不满足!seri.count(s[rp + 1])，因为c并没被删掉，所以跳过while继续循环，删掉b，知道删掉第一个c，while中才满足!seri.count(s[rp + 1])，这时才能进入while，rp继续向后走        while (rp + 1 &lt; s.size() &amp;&amp; !seri.count(s[rp + 1]))        &#123;            seri.insert(s[rp + 1]);            rp++;        &#125;        res = max(res, rp - i + 1);    &#125;    return res;&#125;

76. 最小覆盖字串用两个map分别记录所需包含的字母及其个数(ori)，以及当前窗口内所含所需字母及其个数(cnt)
每次检查时，检查ori中的每个key对应的value和cnt中对应的value，cnt中的值不能小于ori，不然意味着当前窗口未完全包含所需的所有字符
1234567891011bool check(unordered_map&lt;char, int&gt;&amp; ori, unordered_map&lt;char, int&gt;&amp; cnt)&#123;    for(const auto&amp; p : ori)    &#123;    	if(cnt[p.first] &lt; p.second)        &#123;        	return false;        &#125;    &#125;    return true;&#125;

当check满足条件，检查是否需要更新最小窗口长度len和结果起始点ansL，并且由于check满足条件需要将窗口左侧边界右移一位，所以此时如果最左侧的字母为ori中的一员，cnt对应的key的value减一
12345678910111213while(check(ori, cnt) &amp;&amp; l &lt;= r)&#123;	if(r - l &lt; minLength)	&#123;		minLength = r - l;		ansL = l;	&#125;    if(ori.find(s[l]) != ori.end())    &#123;    	--cnt[s[l]];    &#125;	l++;&#125;


                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="/categories/Algorithm/">Algorithm</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-link" href="/tags/Algorithm/">Algorithm</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/08/24/剑指offer/"></a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-08-24</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/08/24/剑指offer/">
                    <p>
                        
                            29. 顺时针打印矩阵123456处理移动四个移动方向用：vector&lt;vector&lt;int&gt;&gt; move&#123; &#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125; &#125;;或者：static constexpr int directions[4][2] = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;标记矩阵的已访问元素和未访问元素用一个相同大小的bool矩阵visit输入一个空matrix时，如果对其求matrix[0].size()会报错，因为没有matrix[0]

12345678910111213141516171819202122232425262728293031vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;    vector&lt;int&gt; order;    if (matrix.size() == 0 || matrix[0].size() == 0) &#123;        return &#123;&#125;;    &#125;    int rowRange = matrix.size();    int colRange = matrix[0].size();    vector&lt;vector&lt;bool&gt;&gt; visit(rowRange, vector&lt;bool&gt;(colRange));    int total = rowRange * colRange;    vector&lt;vector&lt;int&gt;&gt; move&#123; &#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125; &#125;;    int row = 0;    int col = 0;    int moveIndex = 0;    int nextRow, nextCol;    for (int i = 0; i &lt; total; i++)    &#123;        order.push_back(matrix[row][col]);        visit[row][col] = true;        nextRow = row + move[moveIndex][0];        nextCol = col + move[moveIndex][1];        if (nextRow &gt;= rowRange || nextRow &lt; 0 || nextCol &gt;= colRange || nextCol &lt; 0 || visit[nextRow][nextCol])        &#123;            moveIndex = (moveIndex + 1) % 4;        &#125;        row += move[moveIndex][0];        col += move[moveIndex][1];    &#125;    return order;&#125;


                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="/categories/Algorithm/">Algorithm</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-link" href="/tags/Algorithm/">Algorithm</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/08/18/dp专题/">dp专题</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-08-18</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/08/18/dp专题/">
                    <p>
                        
                            5.最长回文子串单独处理长度为1和2的字符串
状态转移：字串加上相同的首尾
1dp[i][j] = (s[i] == s[j] &amp;&amp; dp[i+1][j-1]);

12345678910111213141516171819202122232425262728293031323334string longestPalindrome(string s) &#123;    string ans;    int n = s.size();    //初始化二维vector，初始值为0    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n));    //外层循环用的是字串的长度，dp矩阵对角线（i==j）代表字串长度为1，对角线两侧的斜线代表字串长度为2，依次往外扩展更新    for (int len = 0; len &lt; n; len++)    &#123;c        //对于dbabcad，首轮更新d, b, a, b, c, a, d对应的dp; 第二轮更新db, ba, ab, bc, ca, ad对应的dp; 然后是dba, bab, abc......（它根据首轮的更新的dp做s[i] == s[j] &amp;&amp; dp[i + 1][j - 1]判断）        for (int i = 0; i &lt; n - len; i++)        &#123;            int j = i + len;            if (len == 0)            &#123;                dp[i][j] = 1;            &#125;            else if (len == 1)            &#123;                dp[i][j] = s[i] == s[j];            &#125;            else            &#123;                dp[i][j] = (s[i] == s[j] &amp;&amp; dp[i + 1][j - 1]);            &#125;            //如果找到了更长的字串，更新新的字串            if (dp[i][j] &amp;&amp; len + 1 &gt; ans.size())            &#123;                //substr(i, j): 从下标i开始截取j位                ans = s.substr(i, len + 1);            &#125;        &#125;    &#125;    return ans;&#125;

53. 最大子序和状态转移：nums[i]为当前遍历到的数，比较在已有数组上加上当前数值（数组里加当前数值）和当前数值的大小（开一个新数组）
1max(f[i-1]+nums[i], nums[i])

12345678910111213141516int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;int&gt; f;        if(nums.empty())        &#123;return 0;&#125;        f.push_back(nums[0]);        for(int i = 1; i &lt; nums.size(); i++)        &#123;            f.push_back(max(f[i-1]+nums[i], nums[i]));        &#125;        int compare = f[0];        for(auto x:f)        &#123;            compare = max(x, compare);        &#125;        return compare;    &#125;

超级码力复赛 3.秋叶收藏集123456要将叶子调整为“红黄红”排列，r为红，y为黄，每次可将r调整为y，也可将y调整为r，求调整所需最小次数示例：输入：leaves = &quot;rrryyyrryyyrr&quot;输出：2解释：调整两次，将中间的两片红叶替换成黄叶，得到 &quot;rrryyyyyyyyrr&quot;

12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970int minimumOperations(string leaves) &#123;    int n = leaves.size();    //cout &lt;&lt; "n" &lt;&lt;n &lt;&lt; endl;    int start = 0;    int end = leaves.size() - 1;    vector&lt;vector&lt;int&gt;&gt; dp(n - 2, vector&lt;int&gt;(n - 2, 100000));    int temp = 0;    if (leaves[0] == 'y')    &#123;        temp++;    &#125;    if (leaves[1] == 'r')    &#123;        temp++;    &#125;    for (int i = 2; i &lt; n; i++)    &#123;        if (leaves[i] == 'y')        &#123;            temp++;        &#125;    &#125;    dp[0][1] = temp;    int x = 0;    int y = 2;    while (x != n - 3)    &#123;        while (y != n - 2)        &#123;            if (leaves[y] == 'y')                dp[x][y] = dp[x][y - 1] - 1;            else                dp[x][y] = dp[x][y - 1] + 1;            y++;        &#125;        if (x + 2 == n - 2)            break;        //cout &lt;&lt; "test" &lt;&lt; endl;        if (leaves[x+1] == 'y')            dp[x + 1][x + 2] = dp[x][x + 2] + 1;        else            dp[x + 1][x + 2] = dp[x][x + 2] - 1;        //cout &lt;&lt; "test2" &lt;&lt; endl;        x++;        y = x + 2;        //cout &lt;&lt; "x y " &lt;&lt; x &lt;&lt; y &lt;&lt; endl;        /*for (int a = 0; a &lt; dp.size(); a++)        &#123;            for (int b = 0; b &lt; dp[0].size(); b++)            &#123;                cout &lt;&lt; dp[a][b] &lt;&lt; " ";            &#125;            cout &lt;&lt; endl;        &#125;*/    &#125;    int res = dp[0][0];    for (int a = 0; a &lt; dp.size(); a++)    &#123;        for (int b = 0; b &lt; dp[0].size(); b++)        &#123;            if (dp[a][b] &lt; res)            &#123;                res = dp[a][b];            &#125;        &#125;    &#125;    // cout &lt;&lt; res;    return res;&#125;

32. 最长有效括号寻找转移方程：
每个dp元素代表以该位置为结尾的最长有效括号数，也就是说当以’)’为结尾才可能不为0
当发现s[i]位置以’)’结尾，检查s[i-1]
如果s[i-1] == &#39;(&#39;，dp[i] = dp[i-2] + 2
如果s[i-1] == &#39;)&#39;并且 s[i - dp[i-1] - 1] == &#39;(&#39; ，dp[i] = dp[i-1] + dp[i - dp[i-1] - 2] + 2 
对第二种情况举例：( ) ( ( ) ( ) )，检测到最后一位为’)’并且倒数第二位也为’)’，这时dp[6] = 4, dp[7] = dp[6]（dp[i-1]） + dp[1]（dp[7 - dp[6] -2]） + 2 = 4 + 2 + 2，分别代表第四个到第七个括号组成的dp[i-1]、第一个和第二个括号组成的dp[i - dp[i-1] - 1]，（加上这个是因为除去dp[i-1]和第三个和第八个配对的括号以外，第一个和第二个括号也因为原本没有配对的第三个括号成功配对而连接起来）、第三个和第八个括号组成的新配对的括号组
47. 礼物的最大价值构造“矩阵最优路径的寻径问题”的dp矩阵，dp矩阵每个元素的含义是到当前点的最大收益
转移方程：
1dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j];

这样的话就需要填充边界：使dp矩阵的维度加一，填充0
本题的优化：可将dp矩阵维度降为一维，在每一个外层循环中覆盖更新dp
62. 不同路径转移方程:
1dp[i][j] = dp[i-1][j]+dp[i][j-1];

动态规划中要下意识地思考是否能够降低空间复杂度
本题中每一行的计算都只需要当前行和上一行的信息，所以将空间复杂度O(n^2^)降至O(2n):
只构造两个一维数组pre和cur，分别保存上一行和当前行的值
每次修改完当前行的值以后，将当前行cur复制给pre
进一步优化空间复杂度至O(n):
只构造一个一维数组cur，对应上面的转移方程：
1cur[j] += cur[j-1];

因为在更新cur[j]时，更新前的cur[j]即为上一行的j列值，只需在此之上加上cur[j-1]即可
64. 最小路径和转移方程：
12345678if(i == 1 || j == 1)&#123;	dp[i][j] = i == 1 ? dp[i][j-1] + grid[i-1][j-1] : dp[i-1][j] + grid[i-1][j-1];&#125;else&#123;	dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i-1][j-1];&#125;

为了防止下标左溢出，dp矩阵是(m+1) * (n+1)的，第一行和第一列填充0
第一行和第一列做单独处理，因为当前点的值应为左侧和上侧的较小值加上当前点的值，而第一行的点的值只能为左侧的值加上当前点的值，第一列的点的值只能为上侧的点的值加上当前点的值
70. 爬楼梯转移方程：
123456dp[1] = 1;dp[2] = 2;for(int i = 3; i &lt;= n; i++)&#123;	dp[i] = dp[i-2] + dp[i-1];&#125;

防止左溢出，提前设定dp[1]和dp[2]，并设置n=1和n=2时的返回值
72. 编辑距离问题本质等同于有三种操作：
在单词 A 中插入一个字符，如果horse到ro的编辑距离为a，那么到ros的编辑距离不会超过a+1
在单词 B 中插入一个字符，如果hors到ros的编辑距离为b，那么horse到ros的编辑距离不会超过b+1
修改单词 A 的一个字符，如果hors到ro的编辑距离为c，那么horse到ros的编辑距离不会超过c+1
因此产生状态转移方程：
12int label = word1[i-1] == word2[j-1] ? 0 : 1; //先判断A和B最后一个字母是否相同dp[i][j] = min(min(dp[i-1][j] + 1, dp[i][j-1] + 1), dp[i-1][j-1] + label);


                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="/categories/Algorithm/">Algorithm</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-link" href="/tags/Algorithm/">Algorithm</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/08/03/LeetCode-top&hot刷题/">LeetCode top100刷题</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-08-03</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/08/03/LeetCode-top&hot刷题/">
                    <p>
                        
                            

1. 两数之和12345678910111213vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target)&#123;    // map    umordered_map&lt;int, int&gt; hashtable;    for(int i = 0; i &lt; nums.size(); i++)    &#123;        auto it = hashtable.find(target - nums[i]);        if(it != hashtable.end())            return &#123;it-&gt;second, i&#125;;        hashtable[nums[i]] = i;    &#125;    return &#123;&#125;;&#125;

1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//先排序，再利用双指针遍历，初始i放首部，j放尾部，两数之和大于target的话j--，小于target的话i++，找到对应的i和jvector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;    vector&lt;int&gt; resV&#123; 0, 0 &#125;;    vector&lt;int&gt; copyV = nums;    int find;    int hasFound = 0;    sort(nums.begin(), nums.end());    // for(int k = 0; k &lt; nums.size(); k++)    // &#123;cout &lt;&lt; nums[k] &lt;&lt; " ";&#125;    int i = 0;    int j = nums.size() - 1;    while (i != j &amp;&amp; hasFound == 0)    &#123;        if (target &gt; nums[i] + nums[j])        &#123;            i++;        &#125;        else if (target &lt; nums[i] + nums[j])        &#123;            j--;        &#125;        else        &#123;            //找到i和j还没结束，要根据nums[i], nums[j]找到排序前的数组中对应的原始下标            //found1防止数组中有相同的值k使得k + k = target导致只能（进入下面的if）更新resV[0]的值            //这样，如果在原数组中找到第一个k值时进入if，之后继续找到第二个k值的时候便不会再进入if重复更新resV[0]而导致resV[j]不被更新            int flag = 0, found1 = 0, label = 0;            while (label != 2)            &#123;                if (copyV[flag] == nums[i] &amp;&amp; found1 == 0)                &#123;                    label++;                    resV[0] = flag;                    found1 = 1;                    flag++;                &#125;                else if (copyV[flag] == nums[j])                &#123;                    label++;                    resV[1] = flag;                    flag++;                &#125;                else                &#123;                    flag++;                &#125;            &#125;            hasFound = 1;        &#125;    &#125;    return resV;&#125;

2.两数相加123456789101112131415161718192021222324252627ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;    ListNode *head = nullptr, *tail = nullptr;    int carry = 0;    while (l1 || l2) &#123;        int n1 = l1 ? l1-&gt;val: 0;        int n2 = l2 ? l2-&gt;val: 0;        int sum = n1 + n2 + carry;        if (!head) &#123;            head = tail = new ListNode(sum % 10);        &#125; else &#123;            tail-&gt;next = new ListNode(sum % 10);            tail = tail-&gt;next;        &#125;        carry = sum / 10;        if (l1) &#123;            l1 = l1-&gt;next;        &#125;        if (l2) &#123;            l2 = l2-&gt;next;        &#125;    &#125;    if (carry &gt; 0) &#123;        tail-&gt;next = new ListNode(carry);    &#125;    return head;&#125;

3. 无重复字符的最长字串1234567891011121314151617181920212223int lengthOfLongestSubstring(string s)&#123;    // 滑动窗口 + set	unordered_set&lt;char&gt; st;    int n = s.size();    int right = 0, ret = 0;    for(int left = 0; left &lt; n; left++)    &#123;        if(left != 0)        &#123;            // 每一轮循环首先舍弃窗口左端            st.erase(s[left - 1]);        &#125;        while(right &lt; n &amp;&amp; !st.count(s[right]))        &#123;            st.insert(s[right]);            right++;        &#125;        // 这里right - left 不用再加一，因为right从0而不是从-1开始，理解right的意义        ret = max(ret, right - left);    &#125;    return ret;&#125;

15. 三数之和123456789101112131415161718192021222324252627282930// 排序然后双指针vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums)&#123;    sort(nums.begin(), nums.end());    vector&lt;vector&lt;int&gt;&gt; ret;    int n = nums.size();    if(n &gt;= 3 &amp;&amp; nums[n - 1] + nums[n - 2] + nums[n - 3] &lt; 0) // 剪枝        return ret;    for(int first = 0; first &lt; n - 2; first++)    &#123;        if(nums[first] + nums[first + 1] + nums[first + 2] &gt; 0) // 剪枝            break;        if(first &gt; 0 &amp;&amp; nums[first] == nums[first - 1])            continue;        int target = -nums[first];        int third = n - 1;        for(int second = first + 1; second &lt; n - 1; second++)        &#123;            if(second &gt; first + 1 &amp;&amp; nums[second] == nums[second - 1])                continue;            while(second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target)                --third;            if(second == third)                break;            if(nums[second] + nums[third] == target)                ret.push_back(&#123;nums[first], nums[second], nums[third]&#125;);        &#125;    &#125;    return ret;&#125;

84. 柱状图中的最大矩形12345678910111213141516171819202122int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;    int ret = 0;    int n = heights.size();    vector&lt;int&gt; left(n), right(n, n);    stack&lt;int&gt; monoStack;    for(int i = 0; i &lt; n; i++)    &#123;        while(!monoStack.empty() &amp;&amp; heights[monoStack.top()] &gt;= heights[i])        &#123;            right[monoStack.top()] = i; // 终于遇到比stack中的top对应的柱低的柱了（之前可能是连续的比它高，所以无法确定矩形的宽，遇到比它低的时，就可以确定以它为高的矩形的右边界了）            monoStack.pop();        &#125;        left[i] = monoStack.empty() ? -1 : monoStack.top(); // 检索到某下标时就可以确定以它为高的矩形的左边界        monoStack.push(i);    &#125;    for(int i = 0; i &lt; n; i++)    &#123;        ret = max(ret, (right[i] - left[i] -1) * heights[i]);    &#125;    return ret;&#125;

85. 最大矩形12345678910111213141516171819202122232425262728293031323334353637383940int largestRectangleArea(vector&lt;int&gt;&amp; heights)&#123;    int ret = 0;    int n = heights.size();    vector&lt;int&gt; left(n), right(n, n);    stack&lt;int&gt; monoStack;    for(int i = 0; i &lt; n; i++)    &#123;        while(!monoStack.empty() &amp;&amp; heights[monoStack.top()] &gt;= heights[i])        &#123;            right[monoStack.top()] = i;            monoStack.pop();        &#125;        left[i] = monoStack.empty() ? -1 : monoStack.top();        monoStack.push(i);    &#125;    for(int i = 0; i &lt; n; i++)    &#123;        ret = max(ret, (right[i] - left[i] - 1) * heights[i]);    &#125;    return ret;&#125;int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;    int ret = 0;    int m = matrix.size();    if(m == 0) //要写在n的定义之前，因为matrix[0]不一定存在        return 0;    int n = matrix[0].size();    vector&lt;int&gt; dp (n, 0);    for(int i = 0; i &lt; m; i++)    &#123;        for(int j = 0; j &lt; n; j++)        &#123;            dp[j] = matrix[i][j] == '0' ? 0 : dp[j] + 1; // 这个叠加是根据上一行的dp进行的，比如上方是2，下一行如果为‘1’，相应的柱状图加1的长度变为3（即在原dp数组基础上进行修改）        &#125;        ret = max(ret, largestRectangleArea(dp));    &#125;    return ret;&#125;

114. 二叉树（原地）展开为链表（顺着右子节点连）123456789101112131415161718192021// 还可以用前序遍历存到数组，再改节点结构；或者（只能用迭代法）同时存到数组并改节点结构，以上两种方法空间复杂度O(n)，下面是第三种方法不用前序遍历，直接改结构，空间复杂度为O(1)void flatten(TreeNode* root)&#123;    TreeNode* cur = root;    while(cur)    &#123;        if(cur-&gt;left)        &#123;            auto next = cur-&gt;left;            auto predecessor = next;            while(predecessor-&gt;right)                predecessor = predecessor-&gt;right;            // predecessor为当前节点的左子树的最右节点，连到当前节点cur的右子节点            predecessor-&gt;right = cur-&gt;right;            // 更新当前节点的左右子节点            cur-&gt;left = nullptr;            cur-&gt;right = next;		&#125;        cur = cur-&gt;right;    &#125;&#125;

124. 二叉树中的最大路径和12345678910111213141516171819int maxGain(TreeNode* root, int&amp; maxSum)&#123;    if(root)        // 空节点的最大贡献值等于0    	return 0;    int left = max(maxGain(root-&gt;left), 0);    int right = max(maxGain(root-&gt;right), 0);    // 当前子树中的最大路径和为当前节点值加上两个子节点的最大贡献值    int curMaxSum = root-&gt;val + left + right;    maxSum = max(maxSum, curMaxSum);    // 非空节点的最大贡献值等于节点值与其子节点中的最大贡献值之和    return root-&gt;val + max(left, right);&#125;int maxPathSum(TreeNode* root)&#123;    int maxSum = INT_MIN;    maxGain(root, maxSum);    return maxSum;&#125;

128. （无序数组中能找出的）最长连续序列（需要O(n)时间复杂度）123456789101112131415161718192021222324int longestConsecutive(vector&lt;int&gt;&amp; nums)&#123;    // 怎么也该想到用哈希表存来减少时间复杂度    unordered_set&lt;int&gt; st;    int longestSeq = 0;    for(int num : nums)        st.insert(num);    for(int s : st)    &#123;        // 灵魂的一步剪枝，怎么确定是否检查从某一个数字开始的序列？看set中是否存在num-1，如果存在，则跳过，以此避免查询序列中间的数字        if(!st.count(s - 1))        &#123;            int curSeq = 1;            int curNum = s;            while(st.count(curNum + 1))            &#123;                curSeq++;                curNum++;            &#125;            longestSeq = max(longestSeq, curSeq);        &#125;	&#125;    return longestSeq;&#125;

139. 单词（是否可以）拆分（成字符串数组中的元素）  4min1234567891011121314151617181920bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict)&#123;    unordered_set&lt;string&gt; st;    for(string word : wordDict)        st.insert(word);    vector&lt;bool&gt; dp(s.size() + 1);    dp[0] = true;    // 这里的i可以理解为字符串s的前i个字符    for(int i = 1; i &lt;= s.size();i++)    &#123;        for(int j = 0; j &lt; i; j++)            // 字符串的匹配使用的是s的子串和集合中存的string元素比较            if(dp[j] &amp;&amp; st.find(s.substr(j, i - j)) != st.end())            &#123;                dp[i] = true;                break;            &#125;    &#125;    return dp[s.size()];&#125;

160. 相交链表1234567891011121314// 你走过我走的路，我走过你走的路，我们殊途同归ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;    if(!headA || !headB) return NULL;    ListNode *p, *q, *pp, *qq;    p = headA; q = headB;    while(p != q)    &#123;        pp = p; qq = q;        p = (!p -&gt; next &amp;&amp; qq -&gt; next) ? headB : p -&gt; next;        // 用pp的作用体现出来了，经过上面的步骤，p可能已经变为p-&gt;next        q = (!q -&gt; next &amp;&amp; pp -&gt; next) ? headA : q -&gt; next;    &#125;    return p;&#125;

739. 每日温度（每天找下一个比今天更高的温度）123456789101112131415161718// 又是单调栈，相关题目还有84，85vector&lt;int&gt; dailyTemperature(vector&lt;int&gt;&amp; T)&#123;    int n = T.size();    vector&lt;int&gt; ret(n);    stack&lt;int&gt; stk;    for(int i = 0; i &lt; n; i++)    &#123;        while(!stk.empty() &amp;&amp; T[i] &gt; T[stk.top()])        &#123;            int prevIndex = stk.top();            ret[prevIndex] = i - prevIndex;            stk.pop();        &#125;        stk.push(i);    &#125;	return ret;&#125;


                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="/categories/Algorithm/">Algorithm</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-link" href="/tags/Algorithm/">Algorithm</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2020/08/02/LeetCode周赛/">LeetCode200周赛</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-08-02</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2020/08/02/LeetCode周赛/">
                    <p>
                        
                            给你一个整数数组 arr ，以及 a、b 、c 三个整数。请你统计其中好三元组的数量
如果三元组 (arr[i], arr[j], arr[k]) 满足下列全部条件，则认为它是一个 好三元组 
0 &lt;= i &lt; j &lt; k &lt; arr.length
|arr[i] - arr[j]| &lt;= a
|arr[j] - arr[k]| &lt;= b
|arr[i] - arr[k]| &lt;= c
其中 |x| 表示 x 的绝对值
返回 好三元组的数量 
1234567输入：arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3输出：4解释：一共有 4 个好三元组：[(3,0,1), (3,0,1), (3,1,1), (0,1,1)]输入：arr = [1,1,2,2,3], a = 0, b = 0, c = 1输出：0解释：不存在满足所有条件的三元组

123456789101112131415161718int countGoodTriplets(vector&lt;int&gt;&amp; arr, int a, int b, int c) &#123;	int res = 0;	for (int i = 0; i &lt; arr.size() - 2; i++)	&#123;		for (int j = i + 1; j &lt; arr.size() - 1; j++)		&#123;			for (int k = j + 1; k &lt; arr.size(); k++)			&#123;                //使用abs()需引用cmath头文件				if (abs(arr[i] - arr[j]) &lt;= a &amp;&amp; abs(arr[j] - arr[k]) &lt;= b &amp;&amp; abs(arr[i] - arr[k]) &lt;= c)				&#123;					res++;				&#125;			&#125;		&#125;	&#125;	return res;&#125;

给你一个由 不同 整数组成的整数数组 arr 和一个整数 k 
每回合游戏都在数组的前两个元素（即 arr[0] 和 arr[1] ）之间进行。比较 arr[0] 与 arr[1] 的大小，较大的整数将会取得这一回合的胜利并保留在位置 0 ，较小的整数移至数组的末尾。当一个整数赢得 k 个连续回合时，游戏结束，该整数就是比赛的 赢家 
返回赢得比赛的整数
题目数据 保证 游戏存在赢家
123456789输入：arr = [3,2,1], k = 10输出：3解释：3 将会在前 10 个回合中连续获胜    输入：arr = [1,9,8,2,3,7,6,4,5], k = 7输出：9    输入：arr = [1,11,22,33,44,55,66,77,88,99], k = 1000000000输出：99

123456//vector操作a.erase(a.begin()+1,a.begin()+3); //包前不包后，删除第1、2个元素a.insert(a.begin()+1,5); //在a的第1个元素（从第0个算起）的位置插入数值5a.insert(a.begin()+1,3,5); //在a的第1个元素（从第0个算起）的位置插入3个数，其值都为5a.back(); //返回a的最后一个元素a.front(); //返回a的第一个元素

123456789101112131415161718192021222324252627282930//按命题逻辑操作vector，遇到超长数组同时超大K值时会超时int getWinner(vector&lt;int&gt;&amp; arr, int k) &#123;	int num = 0;	int res = arr[0];	if (k &gt; arr.size())	&#123;		k = arr.size();	&#125;		while (num &lt; k)	&#123;		if (arr[0] &gt; arr[1])		&#123;			num++;			int temp = arr[1];			arr.erase(arr.begin() + 1, arr.begin() + 2);			arr.push_back(temp);		&#125;		else		&#123;			num = 1;			int temp = arr[0];			res = arr[1];			arr.erase(arr.begin(), arr.begin() + 1);			arr.push_back(temp);		&#125;	&#125;	return res;&#125;

123456789101112131415161718192021222324252627282930//trick，不用按题述方式操作vector，从前向后遍历即可int getWinner(vector&lt;int&gt;&amp; arr, int k) &#123;        int num = 0;	    int res = arr[0];	    if (k &gt; arr.size())	    &#123;	    	k = arr.size();	    &#125;	    for(int i = 0; i &lt; arr.size(); i++)        &#123;            if(arr[i]&gt;arr[i+1])            &#123;                //直接修改arr[i+1]的值为arr[i]，这样继续和后面比较时仍是类似命题中的：上一组的较大者和新数值比较                arr[i+1] = arr[i];                num++;            &#125;            else            &#123;                //当遇到前者小于后者的情况，看此时的num值是否满足大于等于k的要求，符合即作为结果返回                if(num &gt;= k)                &#123;                    return arr[i];                &#125;                //不符合则设置num为1，不设置为0的原因是因为已经淘汰掉上一个值，已经赢了一回合                res = arr[i+1];                num = 1;             &#125;        &#125;	    return res;    &#125;

给你一个 n x n 的二进制网格 grid，每一次操作中，你可以选择网格的 相邻两行 进行交换
一个符合要求的网格需要满足主对角线以上的格子全部都是 0 
请你返回使网格满足要求的最少操作次数，如果无法使网格符合要求，请你返回 -1 
主对角线指的是从 (1, 1) 到 (n, n) 的这些格子
123456789输入：grid = [[0,0,1],[1,1,0],[1,0,0]]输出：3输入：grid = [[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,1,1,0]]输出：-1解释：所有行都是一样的，交换相邻行无法使网格符合要求输入：grid = [[1,0,0],[1,1,0],[1,1,1]]输出：0

12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//贪心//从第一行开始，如果该行的后缀0满足条件，那么直接跳过进入下一行（因为需要的后缀0个数是从大到小的顺序（理解这一点非常重要），所以不必担心前面的会抢后面的，自己不够用的时候放心的去抢后面的，因为当前行的需求（优先级）比后面都高）//如果该行后缀0个数不满足条件，那么就往下遍历找到最先（贪心，这是最小次数）满足条件的行，一行一行换上来，记录交换的次数int minSwaps(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;    vector&lt;int&gt; resV;	int res = 0;    int n = grid.size();    //统计每行后缀0个数，存到resV中	for (int i = 0; i &lt; n; i++)	&#123;		int num = 0;		for (int j = 0; j &lt; grid[i].size(); j++)		&#123;			if (grid[i][j] == 0)			&#123;			    num++;			&#125;			else 			&#123;			    num = 0;			&#125;		&#125;		resV.push_back(num);	&#125;    for(int i = 0; i &lt; n - 1; i++)    &#123;        //如果当前行的后缀0个数够用，直接往下遍历，不用担心抢了后面的，因为当前行的需求量比后面的都高        if(resV[i] &gt;= n - i - 1)        continue;        else        &#123;            int j = i + 1;            while(resV[j] &lt; n - i - 1 )            &#123;                j++;                //找到最后都没有找到满足个数的后缀0，就直接退出                if(j == n)                    return -1;            &#125;            //while之后到这里说明找到了一行满足当前行的后缀0的个数需求，把找到的行一行一行的往上换，换到当前行，每次swap的同时更新交换次数            for(int m = j; m &gt; i; m--)            &#123;                swap(resV[m], resV[m - 1]);                res++;            &#125;            &#125;    &#125;    return res;&#125;

5484. 找出第 N 个二进制字符串中的第 K 位12345678910输入：n = 3, k = 1输出：&quot;0&quot;解释：S3 为 &quot;0111001&quot;，其第 1 位为 &quot;0&quot; 输入：n = 4, k = 11输出：&quot;1&quot;解释：S4 为 &quot;011100110110001&quot;，其第 11 位为 &quot;1&quot;输入：n = 1, k = 1输出：&quot;0&quot;

12345678910111213141516private:// invert处理    char ch_not(char ch) &#123;        if(ch == '0') &#123; return '1'; &#125;        else          &#123; return '0'; &#125;    &#125;public:    char findKthBit(int n, int k) &#123;        if(n == 1) &#123; return '0'; &#125;        // 1左移n-1位，pow(2, n-1)        int mid = (1&lt;&lt;(n-1));        if(k == mid) &#123; return '1'; &#125;        if(k &lt; mid) &#123; return findKthBit(n-1, k); &#125;        // k &gt; mid的情况需要把k挪到对称位置：(1&lt;&lt;n) - k，并进行invert        return ch_not(findKthBit(n-1, (1&lt;&lt;n) - k));     &#125;

5483. 整理字符串123456789101112输入：s = &quot;leEeetcode&quot;输出：&quot;leetcode&quot;解释：无论你第一次选的是 i = 1 还是 i = 2，都会使 &quot;leEeetcode&quot; 缩减为 &quot;leetcode&quot;输入：s = &quot;abBAcC&quot;输出：&quot;&quot;解释：存在多种不同情况，但所有的情况都会导致相同的结果。例如：&quot;abBAcC&quot; --&gt; &quot;aAcC&quot; --&gt; &quot;cC&quot; --&gt; &quot;&quot;&quot;abBAcC&quot; --&gt; &quot;abBA&quot; --&gt; &quot;aA&quot; --&gt; &quot;&quot;输入：s = &quot;s&quot;输出：&quot;s&quot;

1234567891011121314151617181920string makeGood(string s) &#123;int i = 0;while (i != s.length() - 1)&#123;    for (i = 0; i &lt; s.length() - 1; i++)    &#123;        if (abs(s[i] - s[i + 1]) == 32)        &#123;            s.erase(i, 2);            i = 0;            break;        &#125;    &#125;    if(s.empty())    &#123;        return "";    &#125;&#125;return s;&#125;

1234567891011121314151617181920212223//William Lin版string makeGood(string s)&#123;    bool ch = 1;    while(ch)    &#123;        ch = 0;        string t = s;        //size()返回类型是size_t, (unsigned) 和后面的int相减可能会溢出        for(int i = 0; i &lt; (int)s.size() - 1; i++)        &#123;            if(s[i] + 32 == s[i + 1] || s[i + 1] + 32 == s[i])            &#123;                //string的substr()使用，带首不带尾，单个参数默认从参数位置取到末尾                t = s.substr(0, i) + s.substr(i + 2);            	ch = 1;                break;            &#125;        &#125;        s = t;    &#125;    return s;&#125;

5468. 第 k 个缺失的正整数1234567输入：arr = [2,3,4,7,11], k = 5输出：9解释：缺失的正整数包括 [1,5,6,8,9,10,12,13,...]输入：arr = [1,2,3,4], k = 2输出：6解释：缺失的正整数包括 [5,6,7,...]

1234567891011121314151617181920212223242526272829int findKthPositive(vector&lt;int&gt;&amp; arr, int k) &#123;    int init = 0;    int res = 0;    int resNum = 0;    res = arr[0] - init -1;    if(res &gt;= k)    &#123;        return k;    &#125;    int i = 1;    while(i &lt; arr.size() &amp;&amp; res &lt; k)    &#123;        if(res + arr[i] - arr[i-1] - 1 &lt; k)        &#123;            res += arr[i] - arr[i-1] - 1;        &#125;        else        &#123;            resNum = arr[i-1] + (k - res);             res = k;        &#125;        i++;    &#125;    if(i == arr.size() &amp;&amp; res &lt; k)    &#123;        resNum = arr.back() + (k - res);    &#125;    return resNum;&#125;

5469. K 次操作转变字符串1234567891011输入：s = &quot;input&quot;, t = &quot;ouput&quot;, k = 9输出：true解释：第 6 次操作时，我们将 &apos;i&apos; 切换 6 次得到 &apos;o&apos; 。第 7 次操作时，我们将 &apos;n&apos; 切换 7 次得到 &apos;u&apos;输入：s = &quot;abc&quot;, t = &quot;bcd&quot;, k = 10输出：false解释：我们需要将每个字符切换 1 次才能得到 t 。我们可以在第 1 次操作时将 &apos;a&apos; 切换成 &apos;b&apos; ，但另外 2 个字母在剩余操作中无法再转变为 t 中对应字母输入：s = &quot;aab&quot;, t = &quot;bbb&quot;, k = 27输出：true解释：第 1 次操作时，我们将第一个 &apos;a&apos; 切换 1 次得到 &apos;b&apos; 。在第 27 次操作时，我们将第二个字母 &apos;a&apos; 切换 27 次得到 &apos;b&apos;

12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//结果出现的位置有数组首之前，数组中间，数组末尾之后，分别处理//创建一个数组存储每一位需要的操作数，将操作数按大小排好，一次遍历去对应k值看是否满足要求//addNum记录某个操作数出现的次数，比如6在某一位上出现一次，某另一位的操作数也是6，那么操作数只能选择6 + 26，第三次出现时操作数为6 + 26 * 2bool canConvertString(string s, string t, int k) &#123;        if (s.length() != t.length())        &#123;            return false;        &#125;        vector&lt;int&gt; resV;        int temp = 0;        vector&lt;int&gt; addNum(26, 0);        for (int i = 0; i &lt; s.length(); i++)        &#123;            if (t[i] - s[i] &gt;= 0)            &#123;                temp = t[i] - s[i];                addNum[temp] += 1;            &#125;            else            &#123;                temp = t[i] - 'a' + 'z' - s[i] + 1;                addNum[temp] += 1;            &#125;            //操作数为0是可以重复的，不需要加重叠次数*26            if (temp != 0)            &#123;                int pushNum = temp + 26 * (addNum[temp] - 1);                resV.push_back(pushNum);            &#125;            else            &#123;                resV.push_back(temp);            &#125;        &#125;        sort(resV.begin(), resV.end());        while (!resV.empty() &amp;&amp; resV.back() != 0)        &#123;            if (k &gt; resV.back())            &#123;                k = resV.back() - 1;                resV.pop_back();            &#125;            else if (k == resV.back())            &#123;                resV.pop_back();                k--;            &#125;            else            &#123;                return false;            &#125;        &#125;        return true;    &#125;

1546. 和为目标值的最大数目不重叠非空子数组数目1234567891011121314输入：nums = [1,1,1,1,1], target = 2输出：2解释：总共有 2 个不重叠子数组（加粗数字表示） [1,1,1,1,1] ，它们的和为目标值 2 输入：nums = [-1,3,5,1,4,2,-9], target = 6输出：2解释：总共有 3 个子数组和为 6 。([5,1], [4,2], [3,5,1,4,2,-9]) 但只有前 2 个是不重叠的输入：nums = [-2,6,6,3,5,4,1,2,8], target = 10输出：3输入：nums = [0,0,0], target = 0输出：3

12345678910111213141516171819202122// 贪心int maxNonOverlapping(vector&lt;int&gt;&amp; nums, int target)&#123;    set&lt;int&gt; s;    //初始时累计值为0，保证在&#123;-1, 3, 5, 1&#125;中找target=6时能找去掉-1, 3，找到&#123;5, 1&#125;    s.insert(0);    int ps = 0, ans = 0;    //一个替代遍历vector中每个值的方法（不关注下标时可使用）    for(int a : nums)    &#123;        //记录到每个当前值的累计值，其中的两个值相减就是两者之间的子数组中的各个值和        ps += a;        //注意理解ps - target的含义，是在当前位置根据target找前面是否有能截断而得到要的子数组的位置        if(s.find(ps - target != s.end()))        &#123;            ++ans;            s.clear();        &#125;        s.insert(ps);    &#125;    return ans;&#125;


                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="/categories/Algorithm/">Algorithm</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-link" href="/tags/Algorithm/">Algorithm</a>
                    
                </div>
            
        </article>
    



    <nav class="page-nav">
        <a class="extend prev" rel="prev" href="/archives/2020/">Prev</a><a class="page-number" href="/archives/2020/">1</a><span class="page-number current">2</span><a class="page-number" href="/archives/2020/page/3/">3</a><a class="page-number" href="/archives/2020/page/4/">4</a><a class="page-number" href="/archives/2020/page/5/">5</a><a class="extend next" rel="next" href="/archives/2020/page/3/">Next</a>
    </nav>

            </div>
            <div class="aside">
    
        <div class="box widget">
    <div class="introduction">
        <p><img src="/images/avatar.jpg" alt="head-sculpture"></p>
        <p class="name">
            CHAsencenge
        </p>
        <p class="slogan">解字</p>
    </div>
</div>
    
        
<div class="box widget">
    <div class="title">Recent</div>
    <ul class="item-box">
        
            
                <li><a href="/2020/11/30/手撸算法终版/">手撸算法终版</a></li>
            
        
            
                <li><a href="/2020/10/29/哈希专题/">哈希专题</a></li>
            
        
            
                <li><a href="/2020/10/29/特殊技巧专题/">特殊技巧专题</a></li>
            
        
            
                <li><a href="/2020/10/29/栈和队列专题/">栈和队列专题</a></li>
            
        
            
                <li><a href="/2020/10/28/树图专题/">树专题</a></li>
            
        
            
                <li><a href="/2020/10/28/空间换时间专题/">空间换时间专题</a></li>
            
        
            
                <li><a href="/2020/10/25/C-Lambda表达式/">C++ Lambda表达式</a></li>
            
        
            
                <li><a href="/2020/10/16/双指针专题/">双指针专题</a></li>
            
        
    </ul>
</div>

    
        
    <div class="box widget">
        <div class="title">Categories</div>
        <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GameDev/">GameDev</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Laya/">Laya</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Light-Frequency-Authenticate/">Light Frequency Authenticate</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/LoRa/">LoRa</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Unity/">Unity</a><span class="category-list-count">5</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Unity/Unreal/">Unreal</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Writing/">Writing</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cpp/">cpp</a><span class="category-list-count">3</span></li></ul>
    </div>

    
        
  <div class="box widget">
    <div class="title">Archives</div>
    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">2020-11</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">2020-10</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">2020-09</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">2020-08</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">2020-07</a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">2019-11</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">2019-09</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">2019-07</a><span class="archive-list-count">6</span></li></ul>
  </div>

    
        
    <div class="box widget">
        <div class="title">Tags</div>
        <div class="item-box cloud-label">
            <a href="/tags/Algorithm/" style="font-size: 20px;">Algorithm</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/GameDev/" style="font-size: 14px;">GameDev</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/Gradle/" style="font-size: 10px;">Gradle</a> <a href="/tags/Hexo/" style="font-size: 12px;">Hexo</a> <a href="/tags/Laya/" style="font-size: 16px;">Laya</a> <a href="/tags/LoRa/" style="font-size: 10px;">LoRa</a> <a href="/tags/Python/" style="font-size: 16px;">Python</a> <a href="/tags/Unity/" style="font-size: 18px;">Unity</a> <a href="/tags/Unreal/" style="font-size: 10px;">Unreal</a> <a href="/tags/Writing/" style="font-size: 12px;">Writing</a> <a href="/tags/cpp/" style="font-size: 14px;">cpp</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/lightFre/" style="font-size: 10px;">lightFre</a> <a href="/tags/writing/" style="font-size: 10px;">writing</a> <a href="/tags/远程登录/" style="font-size: 10px;">远程登录</a>
        </div>
    </div>

    
</div>
        </section>
        <footer class="footer">
    <div class="global-width footer-box">
        <div class="copyright">
            <span>Copyright &copy; 2019</span>
            <span class="dotted">|</span>
            <span>Powered by <a href="https://hexo.io/">Hexo</a></span>
            <span class="dotted">|</span>
            <span>Theme by <a href="javascript:">Loren</a></span>
            <span class="dotted">|</span>
            <span><a href="http://www.beian.miit.gov.cn">浙ICP备18016660号-1</a></span>
        </div>
    </div>
</footer>
    </div>

<script>
    hljs.initHighlightingOnLoad();
</script>
</body>
</html>