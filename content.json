{"meta":{"title":"解字","subtitle":null,"description":"解字无果","author":"CHAsencenge","url":"https://chasencenge.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-07-07T02:56:17.000Z","updated":"2020-07-17T09:52:44.213Z","comments":true,"path":"categories/index.html","permalink":"https://chasencenge.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-07-17T03:53:18.000Z","updated":"2020-07-17T09:52:44.212Z","comments":true,"path":"about/index.html","permalink":"https://chasencenge.github.io/about/index.html","excerpt":"","text":""},{"title":"友链","date":"2020-07-17T03:52:56.000Z","updated":"2020-07-17T09:52:44.250Z","comments":true,"path":"links/index.html","permalink":"https://chasencenge.github.io/links/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-07-07T02:57:07.000Z","updated":"2020-07-17T09:52:44.250Z","comments":true,"path":"tags/index.html","permalink":"https://chasencenge.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"手撸算法终版","slug":"手撸算法终版","date":"2020-11-30T12:43:44.000Z","updated":"2020-12-28T08:55:21.493Z","comments":true,"path":"2020/11/30/手撸算法终版/","link":"","permalink":"https://chasencenge.github.io/2020/11/30/手撸算法终版/","excerpt":"1. 两数之和（为目标值） 3min1234567891011121314vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target)&#123; umordered_map&lt;int, int&gt; hashtable; /* xiaoguo */ for(int i = 0; i &lt; nums.size(); i++) &#123; auto it = hashtable.find(target - nums[i]); if(it != hashtable.end()) return &#123;it-&gt;second, i&#125;; hashtable[nums[i]] = i; &#125; return &#123;&#125;;&#125;","text":"1. 两数之和（为目标值） 3min1234567891011121314vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target)&#123; umordered_map&lt;int, int&gt; hashtable; /* xiaoguo */ for(int i = 0; i &lt; nums.size(); i++) &#123; auto it = hashtable.find(target - nums[i]); if(it != hashtable.end()) return &#123;it-&gt;second, i&#125;; hashtable[nums[i]] = i; &#125; return &#123;&#125;;&#125; 2. 两数相加（链表形式给出，返回同样格式的链表） 4min12345678910111213141516171819202122232425262728293031ListNode* addTwoNumbers(ListNode* l1, ListNode* l2)&#123; ListNode* head = nullptr; ListNode* tail = nullptr; int carry = 0; while(l1 || l2) &#123; int n1 = l1 ? l1-&gt;val : 0; int n2 = l2 ? l2-&gt;val : 0; int sum = n1 + n2 + carry; if(!head) &#123; head = tail = new ListNode(sum % 10); &#125; else &#123; tail-&gt;next = new ListNode(sum % 10); tail = tail-&gt;next; &#125; carry = sum / 10; if(l1) l1 = l1-&gt;next; if(l2) l2 = l2-&gt;next; &#125; if(carry) &#123; tail-&gt;next = new ListNode(carry); &#125; return head;&#125; 3. 无重复字符的最长字串 2min1234567891011121314151617181920int lengthOfLongestSubstring(string s)&#123; unordered_set&lt;char&gt; st; int n = s.size(); int right = 0, ret = 0; for(int left = 0; left &lt; n; left++) &#123; if(left != 0) &#123; st.erase(s[left - 1]); &#125; while(right &lt; n &amp;&amp; !st.count(s[right])) &#123; st.insert(s[right]); right++; &#125; ret = max(ret, right - left); &#125; return ret;&#125; 15. 三数之和（等于0） 9min1234567891011121314151617181920212223242526272829vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums)&#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; ret; int n = nums.size(); if(n &gt;= 3 &amp;&amp; nums[n - 1] + nums[n - 2] + nums[n - 3] &lt; 0) return ret; for(int first = 0; first &lt; n - 2; first++) &#123; if(nums[first] + nums[first + 1] + nums[first + 2] &gt; 0) break; if(first &gt; 0 &amp;&amp; nums[first] == nums[first - 1]) continue; int target = -nums[first]; int third = n - 1; for(int second = first + 1; second &lt; n - 1; second++) &#123; if(second &gt; first + 1 &amp;&amp; nums[second] == nums[second - 1]) continue; while(second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target) --third; if(second == third) break; if(nums[second] + nums[third] == target) ret.push_back(&#123;nums[first], nums[second], nums[third]&#125;); &#125; &#125; return ret;&#125; 84. 柱状图中的最大矩形 8min12345678910111213141516171819202122int largestRectangleArea(vector&lt;int&gt;&amp; heights)&#123; int ret = 0; int n = heights.size(); vector&lt;int&gt; left(n), right(n, n); stack&lt;int&gt; monoStack; for(int i = 0; i &lt; n; i++) &#123; while(!monoStack.empty() &amp;&amp; heights[monoStack.top()] &gt;= heights[i]) &#123; right[monoStack.top()] = i; monoStack.pop(); &#125; left[i] = monoStack.empty() ? -1 : monoStack.top(); monoStack.push(i); &#125; for(int i = 0; i &lt; n; i++) &#123; ret = max(ret, (right[i] - left[i] - 1) * heights[i]); &#125; return ret;&#125; 85. 最大矩形 15min12345678910111213141516171819202122232425262728293031323334353637383940int lagestRectangleArea(vector&lt;int&gt;&amp; heights)&#123; int ret = 0; int n = heights.size(); vector&lt;int&gt; left(n), right(n, n); stack&lt;int&gt; monoStack; for(int i = 0; i &lt; n; i++) &#123; while(!monoStack.empty() &amp;&amp; heights[monoStack.top()] &gt;= heights[i]) &#123; right[monoStack.top()] = i; monoStack.pop(); &#125; left[i] = monoStack.empty() ? -1 : monoStack.top(); monoStack.push(i); &#125; for(int i = 0; i &lt; n; i++) &#123; ret = max(ret, (right[i] - left[i] - ) * heights[i]); &#125; return ret;&#125;int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix)&#123; int ret = 0; int m = matrix.size(); if(m == 0) return 0; int n = matrix[0].size(); vector&lt;int&gt; dp (n, 0); for(int i = 0; i &lt; m; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; dp[j] = matrix[i][j] == '0' ? 0 : dp[j] + 1; &#125; ret = max(ret, largestRectangleArea(dp)); &#125; return ret;&#125; 94. 二叉树的中序遍历递归1234567891011121314void inorder(TreeNode* root, vector&lt;int&gt;&amp; ret)&#123; if(!root) return; inorder(root-&gt;left, ret); ret.push_back(root-&gt;val); inorder(root-&gt;right, ret);&#125;vector&lt;int&gt; inorderTraversal(TreeNode* root)&#123; vector&lt;int&gt; ret; inorder(root, ret); return ret;&#125; 非递归(栈)123456789101112131415161718vector&lt;int&gt; inorderTraversal(TreeNode* root)&#123; vector&lt;int&gt; ret; stack&lt;TreeNode*&gt; stk; while(root || !stk.empty()) &#123; while(root) &#123; stk.push(root); root = root-&gt;left; &#125; root = stk.top(); stk.pop(); ret.push_back(root-&gt;val); root = root-&gt;right; &#125; return ret;&#125; Morris123456789101112131415161718192021222324252627282930313233vector&lt;int&gt; inorderTraversal(TreeNode* root)&#123; vector&lt;int&gt; ret; TreeNode* predecessor = nullptr; while(root) &#123; if(root-&gt;left != nullptr) &#123; predecessor = root-&gt;left; while(predecessor-&gt;right != nullptr &amp;&amp; predecessor-&gt;right != root) &#123; predecessor = predecessor-&gt;right; &#125; if(predecessor-&gt;right == nullptr) &#123; predecessor-&gt;right = root; root = root-&gt;left; &#125; else &#123; ret.push_back(root-&gt;val); predecessor-&gt;right = nullptr; root = root-&gt;right; &#125; &#125; else &#123; ret.push_back(root-&gt;val); root = root-&gt;right; &#125; &#125; return res;&#125; 96. （n个点能组成的）不同的二叉搜索树 1min1234567891011121314int numTrees(int n)&#123; vector&lt;int&gt; dp(n + 1, 0); dp[0] = 1; dp[1] = 1; for(int m = 2; m &lt;= n; m++) &#123; for(int i = 1; i &lt;= m; i++) &#123; dp[m] += dp[i - 1] * dp[m - i]; &#125; &#125; return dp[n];&#125; 98. 验证（一棵树是否为）二叉搜索树 3min12345678910111213141516171819202122bool isValidBST(TreeNode* root)&#123; long long inorder = (long long)INT_MIN - 1; stack&lt;TreeNode*&gt; stk; while(root || !stk.empty()) &#123; while(root) &#123; stk.push(root); root = root-&gt;left; &#125; root = stk.top(); stk.pop(); if(root-&gt;val &lt;= inorder) &#123; return false; &#125; inorder = root-&gt;val; root = root-&gt;right; &#125; return true;&#125; 102. 二叉树的层序遍历(按层次打印到二维数组中） 6min123456789101112131415161718192021222324252627vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root)&#123; vector&lt;vector&lt;int&gt;&gt; ret; if(!root) &#123; return ret; &#125; queue&lt;TreeNode*&gt; que; que.push(root); while(!que.empty()) &#123; int n = que.size(); vector&lt;int&gt; temp; for(int i = 0; i &lt; n; i++) &#123; auto node = que.front(); que.pop(); temp.push_back(node-&gt;val); if(node-&gt;left) que.push(node-&gt;left); if(node-&gt;right) que.push(node-&gt;right); &#125; ret.push_back(temp); &#125; return ret;&#125; 114. 二叉树（原地）展开为链表（顺着右子节点连） 3min123456789101112131415161718void flatten(TreeNode* root)&#123; TreeNode* cur = root; while(cur) &#123; if(cur-&gt;left) &#123; auto next = cur-&gt;left; auto predecessor = next; while(predecessor-&gt;right) predecessor = predecessor-&gt;right; predecessor-&gt;right = cur-&gt;right; cur-&gt;left = nullptr; cur-&gt;right = next; &#125; cur = cur-&gt;right; &#125;&#125; 121. 买卖股票的最佳时机 1min12345678910int maxProfit(vector&lt;int&gt;&amp; prices)&#123; int minprice = 1e9, maxprofit = 0; for(int price : prices) &#123; minprice = min(price, minprice); maxprofit = max(maxprofit, price - minprice); &#125; return maxprofit;&#125; 124. （从任意点起的）二叉树中的最大路径和12345678910111213141516int maxGain(TreeNode* root, int&amp; maxSum)&#123; if(root) return 0; int left = max(maxGain(root-&gt;left), 0); int right = max(maxGain(root-&gt;right), 0); int curMaxSum = root-&gt;val + left + right; maxSum = max(maxSum, curMaxSum); return root-&gt;val + max(left, right);&#125;int maxPathSum(TreeNode* root)&#123; int maxSum = INT_MIN; maxGain(root, maxSum); return maxSum;&#125; 128. （无序数组中能找出的）最长连续序列（需要O(n)时间复杂度）12345678910111213141516171819202122int longestConsecutive(vector&lt;int&gt;&amp; nums)&#123; unordered_set&lt;int&gt; st; int longestSeq = 0; for(int num : nums) st.insert(num); for(int s : st) &#123; if(!st.count(s - 1)) &#123; int curSeq = 1; int curNum = s; while(st.count(curNum + 1)) &#123; curSeq++; curNum++; &#125; longestSeq = max(longestSeq, curSeq); &#125; &#125; return longestSeq;&#125; 136. （在其余数字都出现两次的数组中找）只出现一次的数字（要求线性时间，不使用额外空间）1234567int singleNum(vector&lt;int&gt;&amp; nums)&#123; int ret = 0; for(int num : nums) ret ^= num; return ret;&#125; 139. 单词（是否可以）拆分（成字符串数组中的元素） 4min123456789101112131415161718bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict)&#123; unordered_set&lt;string&gt; st; for(string word : wordDict) st.insert(word); vector&lt;bool&gt; dp(s.size() + 1); dp[0] = true; for(int i = 1; i &lt;= s.size();i++) &#123; for(int j = 0; j &lt; i; j++) if(dp[j] &amp;&amp; st.find(s.substr(j, i - j)) != st.end()) &#123; dp[i] = true; break; &#125; &#125; return dp[s.size()];&#125; 146. LRU缓存机制123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081struct DLinkedNode&#123; int key, value; DLinkedNode* prev; DLinkedNode* next; DLinkedNode() : key(0), value(0), prev(nullptr), next(nullptr)&#123;&#125;; DLinkedNode(int _key, int _value) : key(_key), value(_value), prev(nullptr), next(nullptr)&#123;&#125;;&#125;;class LRUCache&#123;private: unordered_map&lt;int, DLinkedNode*&gt; cache; int size, capacity; DLinkedNode* head; DLinkedNode* tail;public: LRUCache(int _capacity) : size(0), capacity(_capacity) &#123; head = new DLinkedNode(); tail = new DLinkedNode(); head-&gt;next = tail; tail-&gt;prev = head; &#125; int get(int key) &#123; if(!cache.count(key)) &#123; return -1; &#125; DLinkedNode* node = cache[key]; moveToHead(node); return node-&gt;value; &#125; void put(int key, int value) &#123; if(!cache.count(key)) &#123; DLinkedNode* node = new DLinkedNode(key, value); cache[key] = node; addToHead(node); size++; if(size &gt; capacity) &#123; DLinkedNode* remove = tail-&gt;prev; cache.erase(remove-&gt;key); removeTail(); size--; delete remove; &#125; &#125; else &#123; DLinkedNode* node = cache[key]; node-&gt;value = value; moveToHead(node); &#125; &#125; void addToHead(DLinkedNode* node) &#123; node-&gt;prev = head; node-&gt;next = head-&gt;next; head-&gt;next-&gt;prev = node; head-&gt;next = node; &#125; void removeNode(DLinkedNode* node) &#123; node-&gt;next-&gt;prev = node-&gt;prev; node-&gt;prev-&gt;next = node-&gt;next; &#125; void moveToHead(DLinkedNode* node) &#123; removeNode(node); addToHead(node); &#125; DLinkedNode* removeTail() &#123; DLinkedNode* node = tail-&gt;prev; removeNode(node); return node; &#125;&#125;; 148. 排序链表（要求时间复杂度O(nlogn)，空间复杂度O(1)）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980ListNode* sortList(ListNode* head)&#123; if(head == nullptr) &#123; return head; &#125; ListNode* node = head; int length = 0; while(node != nullptr) &#123; length++; node = node-&gt;next; &#125; ListNode* dummyHead = new ListNode(0, head); for(int subLength = 1; subLength &lt; length; subLength &lt;&lt;= 1) &#123; ListNode* prev = dummyHead; ListNode* curr = dummyHead-&gt;next; while(curr != nullptr) &#123; ListNode* head1 = curr; for(int i = 1; i &lt; subLength &amp;&amp; curr-&gt;next != nullptr; i++) &#123; curr = curr-&gt;next; &#125; ListNode* head2 = curr-&gt;next; curr-&gt;next = nullptr; curr = head2; for(int i = 1; i &lt; subLength &amp;&amp; curr != nullptr &amp;&amp; curr-&gt;next != nullptr; i++) &#123; curr = curr-&gt;next; &#125; ListNode* next = nullptr; if(curr != nullptr) &#123; next = curr-&gt;next; curr-&gt;next = nullptr; &#125; //curr = next; ListNode* merged = merge(head1, head2); prev-&gt;next = merged; while(prev-&gt;next != nullptr) &#123; prev = prev-&gt;next; &#125; curr = next; &#125; &#125; return dummyHead-&gt;next;&#125;ListNode* merge(ListNode* head1, ListNode* head2)&#123; ListNode* dummyHead = new ListNode(0); ListNode* temp = dummyHead; ListNode* temp1 = head1; ListNode* temp2 = head2; while(temp1 != nullptr &amp;&amp; temp2 != nullptr) &#123; if(temp1-&gt;val &lt;= temp2-&gt;val) &#123; temp-&gt;next = temp1; temp1 = temp1-&gt;next; &#125; else &#123; temp-&gt;next = temp2; temp2 = temp2-&gt;next; &#125; temp = temp-&gt;next; &#125; if(temp1 != nullptr) &#123; temp-&gt;next = temp1; &#125; else if(temp2 != nullptr) &#123; temp-&gt;next = temp2; &#125; return dummyHead-&gt;next;&#125; 152. 乘积最大子数组12345678910111213int maxProduct(vector&lt;int&gt;&amp; nums)&#123; int maxF = nums[0], minF = nums[0]; int ans = nums[0]; for(int i = 1; i &lt; nums.size(); i++) &#123; int mx = maxF, mn = minF; maxF = max(mx * nums[i], max(mn * nums[i], nums[i])); minF = min(mx * nums[i], min(mn * nums[i], nums[i])); ans = max(maxF, ans); &#125; return ans;&#125; 155. 最小栈（保证能常数时间内返回最小值）12345678910111213141516171819202122232425262728class MinStack&#123;public: stack&lt;int&gt; xStack; stack&lt;int&gt; mStack; MinStack() &#123; mStack.push(INT_MIN); &#125; void push(int x) &#123; xStack.push(x); mStack.push(min(x, mStack.pop())); &#125; void pop() &#123; xStack.pop(); mStack.pop(); &#125; int top() &#123; return xStack.top(); &#125; int getMin() &#123; return mStack.top(); &#125;&#125;; 198. 打家劫舍12345678910111213141516int rob(vector&lt;int&gt;&amp; nums)&#123; if(nums.empty()) return 0; int n = nums.size(); if(n == 1) return nums[0]; vector&lt;int&gt; dp(n, 0); dp[0] = nums[0]; dp[1] = max(nums[0], nums[1]); for(int i = 2; i &lt; n; i++) &#123; dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]); &#125; return dp[n - 1];&#125; 200. 岛屿数量12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182class UnionFind&#123;private: vector&lt;int&gt; parent; vector&lt;int&gt; rank; int count = 0;public: UnionFind(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123; int m = grid.size(); int n = grid[0].size(); for(int r = 0; r &lt; m; r++) &#123; for(int c = 0; c &lt; n; c++) &#123; if(grid[r][c] == '1') &#123; parent.push_back(r * n + c); count++; &#125; else &#123; parent.push_back(-1); &#125; rank.push_back(0); &#125; &#125; &#125; int find(int i) &#123; if(parent[i] != i) parent[i] = find(parent[i]); return parent[i]; &#125; void unite(int x, int y) &#123; int rootx = find(x); int rooty = find(y); if(rootx != rooty) &#123; if(rank[rootx] &lt; rank[rooty]) &#123; swap(rootx, rooty); &#125; if(rank[rootx] == rank[rooty]) &#123; rank[rootx] += 1; &#125; parent[rooty] = rootx; count--; &#125; &#125; int getCount() &#123; return count; &#125;&#125;;class Solution&#123;public: int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123; int nr = grid.size(); int nc = grid[0].size(); UnionFind uf(grid); for(int r = 0; r &lt; nr; r++) &#123; for(int c = 0; c &lt; nc; c++) &#123; if(grid[r][c] == '1') &#123; grid[r][c] = '0'; if(r - 1 &gt;= 0 &amp;&amp; grid[r - 1][c] == '1') uf.unite(r * nc + c, (r - 1) * nc + c); if(r + 1 &lt; nr &amp;&amp; grid[r + 1][c] == '1') uf.unite(r * nc + c, (r + 1) * nc + c); if(c - 1 &gt;= 0 &amp;&amp; grid[r][c - 1] == '1') uf.unite(r * nc + c, r * nc + c - 1); if(c + 1 &lt; nc &amp;&amp; grid[r][c + 1] == '1') uf.unite(r * nc + c, r * nc + c + 1); &#125; &#125; &#125; return uf.getCount(); &#125;&#125;; 206. 翻转链表1234567891011121314151617181920212223242526// 递归ListNode* reverseList(ListNode* head)&#123; if(head == nullptr || head-&gt;next == nullptr) &#123; return head; &#125; ListNode* ret = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = nullptr; return ret;&#125;// 双指针迭代ListNode* reverseList(ListNode* head)&#123; ListNode* pre = head; ListNode* cur = nullptr; while(pre != nullptr) &#123; ListNode* p = pre-&gt;next; pre-&gt;next = cur; cur = pre; pre = p; &#125; return cur;&#125; 208. 实现Trie(前缀树)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Trie&#123;private: bool isEnd; Trie* next[26];public: Trie() &#123; isEnd = false; memset(next, 0, sizeof(next)); &#125; void insert(string word) &#123; Trie* node = this; for(char c : word) &#123; if(node-&gt;next[c - 'a'] == nullptr) &#123; node-&gt;next[c - 'a'] = new Trie(); &#125; node = node-&gt;next[c - 'a']; &#125; node-&gt;isEnd = true; &#125; bool search(string word) &#123; Trie* node = this; for(char c : word) &#123; if(node-&gt;next[c - 'a'] == nullptr) &#123; return false; &#125; node = node-&gt;next[c - 'a']; &#125; return node-&gt;isEnd; &#125; bool startsWith(string prefix) &#123; Trie* node = this; for(char c : prefix) &#123; if(node-&gt;next[c - 'a'] == nullptr) &#123; return false; &#125; node = node-&gt;next[c - 'a']; &#125; return true; &#125;&#125;; 739. 每日温度（每天找下一个比今天更高的温度）1234567891011121314151617vector&lt;int&gt; dailyTemperature(vector&lt;int&gt;&amp; T)&#123; int n = T.size(); vector&lt;int&gt; ret(n); stack&lt;int&gt; stk; for(int i = 0; i &lt; n; i++) &#123; while(!stk.empty() &amp;&amp; T[i] &gt; T[stk.top()]) &#123; int prevIndex = stk.top(); ret[prevIndex] = i - prevIndex; stk.pop(); &#125; stk.push(i); &#125; return ret;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/tags/Algorithm/"}]},{"title":"哈希专题","slug":"哈希专题","date":"2020-10-29T06:07:49.000Z","updated":"2020-12-28T08:56:55.493Z","comments":true,"path":"2020/10/29/哈希专题/","link":"","permalink":"https://chasencenge.github.io/2020/10/29/哈希专题/","excerpt":"49. 字母异位词分组如何将异位词分到一组？ 对于每个字符串，对其进行字典排序，利用排序后的string作为map的key，将排序前的string推到value中 用到的数据结构为：unordered_map&lt;string, vector&gt; mp 最后将mp中的每个元素的second push_back到结果集ret中","text":"49. 字母异位词分组如何将异位词分到一组？ 对于每个字符串，对其进行字典排序，利用排序后的string作为map的key，将排序前的string推到value中 用到的数据结构为：unordered_map&lt;string, vector&gt; mp 最后将mp中的每个元素的second push_back到结果集ret中","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/tags/Algorithm/"}]},{"title":"特殊技巧专题","slug":"特殊技巧专题","date":"2020-10-29T05:15:00.000Z","updated":"2020-12-28T12:32:33.350Z","comments":true,"path":"2020/10/29/特殊技巧专题/","link":"","permalink":"https://chasencenge.github.io/2020/10/29/特殊技巧专题/","excerpt":"48. 旋转图像对矩阵的原地旋转操作可通过转置并翻转来实现 本题要求完成90°旋转，可先求转置，再对每一行进行翻转 如果要旋转180°，可以先对列翻转，再对行翻转 如果要逆时针旋转90°，则先求转置，再对列进行翻转","text":"48. 旋转图像对矩阵的原地旋转操作可通过转置并翻转来实现 本题要求完成90°旋转，可先求转置，再对每一行进行翻转 如果要旋转180°，可以先对列翻转，再对行翻转 如果要逆时针旋转90°，则先求转置，再对列进行翻转 29. 顺时针打印矩阵123456处理移动四个移动方向用：vector&lt;vector&lt;int&gt;&gt; move&#123; &#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125; &#125;;或者：static constexpr int directions[4][2] = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;标记矩阵的已访问元素和未访问元素用一个相同大小的bool矩阵visit输入一个空matrix时，如果对其求matrix[0].size()会报错，因为没有matrix[0] 12345678910111213141516171819202122232425262728293031vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;int&gt; order; if (matrix.size() == 0 || matrix[0].size() == 0) &#123; return &#123;&#125;; &#125; int rowRange = matrix.size(); int colRange = matrix[0].size(); vector&lt;vector&lt;bool&gt;&gt; visit(rowRange, vector&lt;bool&gt;(colRange)); int total = rowRange * colRange; vector&lt;vector&lt;int&gt;&gt; move&#123; &#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125; &#125;; int row = 0; int col = 0; int moveIndex = 0; int nextRow, nextCol; for (int i = 0; i &lt; total; i++) &#123; order.push_back(matrix[row][col]); visit[row][col] = true; nextRow = row + move[moveIndex][0]; nextCol = col + move[moveIndex][1]; if (nextRow &gt;= rowRange || nextRow &lt; 0 || nextCol &gt;= colRange || nextCol &lt; 0 || visit[nextRow][nextCol]) &#123; moveIndex = (moveIndex + 1) % 4; &#125; row += move[moveIndex][0]; col += move[moveIndex][1]; &#125; return order;&#125; 56. 合并区间先按区间左边界进行升序排序 每次检查是否能合并时，比较：当前区间的左边界和结果集合中最后一个区间的右边界 1if(intervals[i][0] &lt;= ret.back()[1]) 如果当前区间左边界小于结果集合中最后一个区间的右边界，说明区间重叠，修改当前区间的右边界，选择当前比较的两个区间的右边界中的较大值作为新的右边界 如果不能合并，在结果集合ret中push_back当前检查的区间 62. 不同路径求只能往右或者往下走的全路径：排列组合中的组合 尽可能的防止溢出，每次循环中更新完分子和分母后，都用分子和分母分别除以公约数 公约数计算方法： 1234int gcd(int a, int b) &#123; return b == 0 ? a : gcd(b, a % b); &#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/tags/Algorithm/"}]},{"title":"栈和队列专题","slug":"栈和队列专题","date":"2020-10-29T05:14:13.000Z","updated":"2020-12-28T08:57:06.498Z","comments":true,"path":"2020/10/29/栈和队列专题/","link":"","permalink":"https://chasencenge.github.io/2020/10/29/栈和队列专题/","excerpt":"","text":"","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/tags/Algorithm/"}]},{"title":"树专题","slug":"树图专题","date":"2020-10-28T11:50:18.000Z","updated":"2020-12-28T07:01:51.738Z","comments":true,"path":"2020/10/28/树图专题/","link":"","permalink":"https://chasencenge.github.io/2020/10/28/树图专题/","excerpt":"207. 课程表我们可以将本题建模成一个求拓扑排序的问题：将每一门课看成一个节点，如果想要学习课程 A之前必须完成课程 B，那么我们从B到A连接一条有向边。这样以来，在拓扑排序中，B一定出现在 A的前面","text":"207. 课程表我们可以将本题建模成一个求拓扑排序的问题：将每一门课看成一个节点，如果想要学习课程 A之前必须完成课程 B，那么我们从B到A连接一条有向边。这样以来，在拓扑排序中，B一定出现在 A的前面 思路： 考虑拓扑排序中最前面的节点，该节点一定不会有任何入边，也就是它没有任何的先修课程要求。当我们将一个节点加入答案中后，我们就可以移除它的所有出边，代表着它的相邻节点少了一门先修课程的要求。如果某个相邻节点变成了「没有任何入边的节点」，那么就代表着这门课可以开始学习了。按照这样的流程，我们不断地将没有入边的节点加入答案，直到答案中包含所有的节点（得到了一种拓扑排序）或者不存在没有入边的节点（图中包含环） 算法： 使用一个队列来进行广度优先搜索。初始时，所有入度为 00 的节点都被放入队列中，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。 在广度优先搜索的每一步中，我们取出队首的节点u： 我们将u放入答案中 我们移除 u的所有出边，也就是将u的所有相邻节点的入度减少1。如果某个相邻节点v的入度变为0，那么我们就将v放入队列中 在广度优先搜索的过程结束后。如果答案中包含了这n个节点，那么我们就找到了一种拓扑排序，否则说明图中存在环，也就不存在拓扑排序了 1234567891011121314151617181920212223242526272829303132333435363738394041bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123; //入度 in degree vector&lt;int&gt; indeg; vector&lt;vector&lt;int&gt;&gt; edges; //resize内的默认初始化值为0 indeg.resize(numCourses); edges.resize(numCourses); for (const auto&amp; info : prerequisites) &#123; //以info[1]为起始的边，指向info[0] edges[info[1]].push_back(info[0]); //info[0]的入度加一，指向它的是info[1] ++indeg[info[0]]; &#125; queue&lt;int&gt; q; for (int i = 0; i &lt; numCourses; i++) &#123; //把最开始入度为0的点push进去 if (indeg[i] == 0) &#123; q.push(i); &#125; &#125; int visited = 0; while (!q.empty()) &#123; visited++; int u = q.front(); q.pop(); for (int v : edges[u]) &#123; --indeg[v]; //如果去掉指向它的u之后，v点的入度变为0，那么push进队列 if (indeg[v] == 0) &#123; q.push(v); &#125; &#125; &#125; return visited == numCourses;&#125; 8. 字符串转换整数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 有限自动机，写一个有限自动机类class Automation&#123;public: unordered_map&lt;string, vector&lt;string&gt;&gt; table = &#123; &#123;\"start\", &#123;\"start\", \"signed\", \"in_number\", \"end\"&#125;&#125;, &#123;\"signed\", &#123;\"end\", \"end\", \"in_number\", \"end\"&#125;&#125;, &#123;\"in_number\", &#123;\"end\", \"end\", \"in_number\", \"end\"&#125;&#125;, &#123;\"end\", &#123;\"end\", \"end\", \"end\", \"end\"&#125;&#125; &#125;; string status = \"start\"; int get_col(char c) &#123; if(c == ' ') return 0; if(c == '+' || c == '-') return 1; if(isdigit(c)) return 2; return 3; &#125; int sign = 1; long long res = 0; void get(char c) &#123; status = table[status][get_col(c)]; if(status == \"in_number\") &#123; res = res * 10 + (c - '0'); res = sign == 1 ? min(res, (long long)INT_MAX) : min(res, -(long long)INT_MIN); &#125; if(status == \"signed\") &#123; sign = c == '+' ? 1 : -1; &#125; &#125;&#125;;class Solution&#123;public: int myAtoi(string str) &#123; Automation atmn; for(char c : str) &#123; atmn.get(c); &#125; return atmn.sign * atmn.res; &#125;&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/tags/Algorithm/"}]},{"title":"空间换时间专题","slug":"空间换时间专题","date":"2020-10-28T11:49:39.000Z","updated":"2020-12-28T12:33:01.703Z","comments":true,"path":"2020/10/28/空间换时间专题/","link":"","permalink":"https://chasencenge.github.io/2020/10/28/空间换时间专题/","excerpt":"42. 接雨水此题首先需知如何计算总雨水量： 总雨水量的计算需知数组中的每个数左侧和右侧的最高值，取二者较小值减去当前高度，即为当前点处能蓄水的量 如果不用空间换时间，计算每个点左右两侧的最大值都需要遍历一次所有数据 所以用两个数组leftMax和rightMax分别存储每个点左侧的最大值和右侧的最大值 最后再一次遍历计算总蓄水量","text":"42. 接雨水此题首先需知如何计算总雨水量： 总雨水量的计算需知数组中的每个数左侧和右侧的最高值，取二者较小值减去当前高度，即为当前点处能蓄水的量 如果不用空间换时间，计算每个点左右两侧的最大值都需要遍历一次所有数据 所以用两个数组leftMax和rightMax分别存储每个点左侧的最大值和右侧的最大值 最后再一次遍历计算总蓄水量","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/tags/Algorithm/"}]},{"title":"C++ Lambda表达式","slug":"C-Lambda表达式","date":"2020-10-25T09:01:24.000Z","updated":"2020-12-28T12:28:48.792Z","comments":true,"path":"2020/10/25/C-Lambda表达式/","link":"","permalink":"https://chasencenge.github.io/2020/10/25/C-Lambda表达式/","excerpt":"Lambda申明方式Lambda表达式允许在函数内部创建一个匿名函数 声明方式：[captrues(params) -&gt;ret {Statements};1234auto fadd = [](int a, int b)&#123; return a + b;&#125;; // 注意最后有分号 []表示开始定定义Lambda表达式，()里面是函数的参数 ，{}里面是函数体","text":"Lambda申明方式Lambda表达式允许在函数内部创建一个匿名函数 声明方式：[captrues(params) -&gt;ret {Statements};1234auto fadd = [](int a, int b)&#123; return a + b;&#125;; // 注意最后有分号 []表示开始定定义Lambda表达式，()里面是函数的参数 ，{}里面是函数体 显示指明返回值：1234auto fadd = [](int a, int b) -&gt; ret&#123; return a + b;&#125;; Lambda表达式的变量截取[] 不截取任何变量 [&amp;] 截取外部作用域的所有变量，并作为引用在函数体中使用 [=] 截取外部作用域中的所有变量，并拷贝一份在函数体中使用 [=, &amp;foo] 截取外部作用域中所有变量并拷贝一份在函数体中使用，但对foo变量使用引用 [bar] 截取bar变量并拷贝一份在函数体使用，不截取其他变量 [this] 截取当前类中的指针","categories":[{"name":"cpp","slug":"cpp","permalink":"https://chasencenge.github.io/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://chasencenge.github.io/tags/cpp/"}]},{"title":"双指针专题","slug":"双指针专题","date":"2020-10-15T16:08:03.000Z","updated":"2020-12-28T12:32:41.452Z","comments":true,"path":"2020/10/16/双指针专题/","link":"","permalink":"https://chasencenge.github.io/2020/10/16/双指针专题/","excerpt":"16. 最接近的三数之和相对于暴力解法，双指针能够通过首尾指针和合理移动，减少不合理情况的遍历，即a+b+c &lt; target，则c向左移动，a+b+c &gt; target，b向右移动 进一步可以总结出：若想要使两数之和逼近某一个目标值，可使用双指针对已排序数组进行查找","text":"16. 最接近的三数之和相对于暴力解法，双指针能够通过首尾指针和合理移动，减少不合理情况的遍历，即a+b+c &lt; target，则c向左移动，a+b+c &gt; target，b向右移动 进一步可以总结出：若想要使两数之和逼近某一个目标值，可使用双指针对已排序数组进行查找 对已排序数组的遍历时跳过重复值的通用优化： 123int p0 = p + 1;while(nums[p0] == nums[p] &amp;&amp; p0 &lt; q) p0++; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; int ans = 1e7; int n = nums.size(); sort(nums.begin(), nums.end()); int sum; auto update = [&amp;](int cur) &#123; if(abs(cur - target) &lt; abs(ans - target)) &#123; ans = cur; &#125; &#125;; for(int i = 0; i &lt; n - 2; i++) &#123; if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; int p = i + 1; int q = n - 1; while(p &lt; q) &#123; sum = nums[i] + nums[p] + nums[q]; if(sum == target) &#123; return target; &#125; update(sum); if(sum &lt; target) &#123; int p0 = p + 1; while(nums[p0] == nums[p] &amp;&amp; p0 &lt; q) p0++; p = p0; &#125; if(sum &gt; target) &#123; int q0 = q - 1; while(q0 &gt; p &amp;&amp; nums[q0] == nums[q]) &#123; q0--; &#125; q = q0; &#125; &#125; &#125; return ans;&#125; 19. 删除链表的倒数第N个节点怎样一次遍历找到倒数第N个节点？双指针，前面的指针在后面的指针前N+1的位置，同步前进，然后当前面的指针指到nullptr时，后面的指针处于倒数N+1位置，这时令： 1p-&gt;next = p-&gt;next-&gt;next; 怎样保证最后返回正确的头节点？（原链表的头节点可能被删除）开始时在head前new一个节点hair： 1ListNode* hair = new ListNode(0, head); // (val, next) 最后返回hair-&gt;next 18. 四数之和先将数组用sort()进行排序 双重循环遍历前两个数，后两个数分配双指针一前一后 外面双重循环： 1234567for(int i = 0; i &lt; n-3; i++)&#123; for(int j = i+1; j &lt; n-2; j++) &#123; ...... &#125;&#125; 双指针起始位置： 12int p = j + 1;int q = n - 1; 剪枝操作： 在外层的两重循环中分别做如下几种情况的剪枝： 当前值nums[i]与上一个值nums[i-1]相同时，continue 当前值nums[i]加上后面连续三个数nums[i+1], nums[i+2], nums[i+3]的和大于target，则之后不论如何取值都一定大于target，直接跳出循环break 当前值nums[i]加上倒数三个最大的值nums[n-1], nums[n-2], nums[n-3]的和小于target，说明以nums[i]起始的任意四个数的和均小于target，跳出本次循环continue 对于第二层循环做类似的三种情况的剪枝处理 415. 字符串相加实现两个字符串的数值相加，不能用类型转换 12345678910111213141516171819202122232425262728293031string addStrings(string num1, string num2) &#123; //双指针，双指针的“指针”不一定非得是指针类型，能做flag标记就行 int i = num1.length() - 1; int j = num2.length() - 1; string res; int multi = 1; //进位 int add = 0; while (i &gt;= 0 || j &gt;= 0 || add &gt; 0) &#123; int x = 0; int y = 0; if (i &gt;= 0) &#123; //两者相减得到的是int型 x = num1[i] - '0'; &#125; if (j &gt;= 0) &#123; y = num2[j] - '0'; &#125; int result = x + y + add; res.push_back('0' + result % 10); add = result / 10; i--; j--; &#125; //因为每次push_back是从低位到高位的，所以结果要翻转 reverse(res.begin(), res.end()); return res;&#125; 75. 颜色分类数组中只有0，1，2三种值，对其排序的方式： 双指针p0和p2，p0用于交换0，p2用于交换2 p0 = 0，p2 = n - 1 一次遍历，当前值如果为0，交换当前位置和p0位置的值，当前值如果为2，和p2交换 1234567891011// 这里while的使用要注意，对照输入[2,1,2]while(i &lt;= p2 &amp;&amp; nums[i] == 2)&#123; swap(nums[i], nums[p2]); --p2;&#125;if(nums[i] == 0)&#123; swap(nums[i], nums[p0]); ++p0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/tags/Algorithm/"}]},{"title":"UE学习文档","slug":"UE学习笔记","date":"2020-10-12T08:43:46.000Z","updated":"2020-12-28T12:32:15.788Z","comments":true,"path":"2020/10/12/UE学习笔记/","link":"","permalink":"https://chasencenge.github.io/2020/10/12/UE学习笔记/","excerpt":"UE4源码编译git clone源码 运行Setup.bat下载依赖文件 运行GenerateProjectFiles.bat生成工程文件 运行UE.sln 在vs打开的工程中，最上方的解决方案配置设置为Development Editor，启动项目设置为UE4，平台WIN64，右键UE4 – Build进行编译 编译完成后按F5在vs中启动 注意 生成工程文件前可能会报错，根据报错信息可判断是否缺少相应的.NET Framework，如果缺少在vs installer中选中相应版本的vs – 修改 – 添加相应的.NET工具 Epic Game Launcher中不能识别非公版的引擎，向编译版的引擎创建的工程中添加保管库中的素材时，点击添加到工程–显示所有工程–为相应工程手动选择对应的版本号即可添加素材（因为又编译版引擎创建的工程在Launcher中显示的版本标识为“其他”，不选择相应的版本号则素材或插件都会显示不兼容）","text":"UE4源码编译git clone源码 运行Setup.bat下载依赖文件 运行GenerateProjectFiles.bat生成工程文件 运行UE.sln 在vs打开的工程中，最上方的解决方案配置设置为Development Editor，启动项目设置为UE4，平台WIN64，右键UE4 – Build进行编译 编译完成后按F5在vs中启动 注意 生成工程文件前可能会报错，根据报错信息可判断是否缺少相应的.NET Framework，如果缺少在vs installer中选中相应版本的vs – 修改 – 添加相应的.NET工具 Epic Game Launcher中不能识别非公版的引擎，向编译版的引擎创建的工程中添加保管库中的素材时，点击添加到工程–显示所有工程–为相应工程手动选择对应的版本号即可添加素材（因为又编译版引擎创建的工程在Launcher中显示的版本标识为“其他”，不选择相应的版本号则素材或插件都会显示不兼容） 项目打包项目打包注意事项启动地图构建项目时会从游戏默认地图开始，需要点击Project Settings — Maps &amp; Modes 设置game default map 选择目标平台 还要记得选择目标硬件(Target Hardware) 编辑器查看方式 细化平台性能控制 打开Device Profiles以后点击想要修改的设备型号后面的扳手即可对其值进行修改 Android设置和打包方式设置方式寻找UE4 Android Works文件夹，一般默认为C:/Program Files/Epic Games/UE_4_版本/Engine/Extras/Android Works/Win64 安装后可看到CodeWorks Manager窗口 在手机端，有时需找到usb driver才能使用，一般连数据线即可 http://developer.android.com/tools/extras/oem-usb.html 解锁设备时要开启开发者模式，开启usb调试 在设置主页找到“已连接设备”选择启用文件传输 在电脑上cmd输入adb devices，如果列出了自己的手机设备名，则准备就绪 注意： 手机开发者选项中不但需开启USB调试，还打开USB安装，允许通过USB安装应用 打包方式为了更准确的测试，使用Play – Mobile Preview 退出游戏方式： “~”打开控制台，输入quit game 确保项目做好准备： Settings – Project Settings – Platforms – Android 页面顶部会有警告称项目尚未对Android完成配置，点击configure now 设置文件包名称，格式为：com.MyGameCompany.MyCoolGame 并完成项目命名 如果要计划使用Google Play服务，向下滚动到Google Play Services并点击Configure Now，以将平台构建到游戏中 构建到设备： 测试并部署到自己的设备很方便，如果需要部署到其他设备，需打包 双击生成的.bat项目可以将其安装到自己的Android设备上 注意 记得在项目设置 – Android勾选将游戏数据打包至.apk中 UE4游戏框架 游戏架构的基类是GameMode，设置游戏规则，也分则处理生成玩家 Pawn作为世界中的一个“代理”Actor，可由控制器处理 ，可接收输入并且可执行各种各样类似于玩家的动作（但不假定Pawn就是类人的） Character类人的Pawn，本身默认具有用于碰撞的CapsuleComponent（胶囊体组件）和CharacterMovementComponent（角色运动组件）；可进行基本的拟人运动、平滑地在网格上复制运动，并具有一些动画相关的功能 控制PawnController负责管理Pawn的Actor，一般分为PlayerController和AIController，控制器可以“具有”一个Pawn并控制它 HUD平视显示信息 GameMode游戏的定义，包括像游戏规则和获胜条件这样的内容；仅存在于服务器上，一般在游戏过程中不会有太多数据改变，并且一定不会具有客户端需要的临时数据 GameState包含游戏状态，包括像关联玩家的列表、分数、象棋游戏中的棋子位置或在开放世界中已经完成的任务列表 存在于服务器和所有客户端上，可以自由地进行复制来保持同步 PlayerState表示游戏中一个参与者的状态（AI没有PlayerState），适合包含的实例数据有：玩家姓名，分数，多人在线竞技场比赛中的级别，夺旗模式游戏中玩家当前是否占领旗帜 所有玩家的PlayerStates在所有的机器上都存在，并且可以自由复制包持同步 UE C++命名规则派生自Actor的类前缀为A 派生自Object的类前缀为U 派生自Swidget（Slate UI）的类前缀为S Enums的类前缀为E Interface类的前缀通常为I Template类的前缀为T 其余类的前缀均为F 布尔值用b前缀 全局元素用G前缀 输入参数用In前缀 输出参数用Out前缀 在API文档寻找类或函数进入UE4文档 –&gt; Unreal Engine API Reference –&gt; Contents Contents下面点击All classes或者All Functions查看所有的类和函数 防止头文件被编译多次的两种方法（1） 1234# ifndef _SOMEFILE_H_# define _SOMEFILE_H_......# endif （2） 1# pragma once UCLASS()UCLASS 宏（在头文件）可用于标记从 UObject 派生的类，使 UObject 处理系统识别到它们 GENERATED_BODY 宏不获取参数，但会对类进行设置，以支持引擎要求的基础结构。所有 UCLASS 均有此要求 UPROPERTY()为将变量公开到虚幻引擎，需使其成为 UPROPERTY。利用此操作，可在启动游戏或加载保存的关卡时保留变量的值。带有空括号的 UPROPERTY 标记，将被添加到受其它影响的变量正上方 UPROPERTY 支持改变虚幻引擎使用变量方式的参数。将变量设为可编辑，可添加 EditAnywhere 参数 12UPROPERTY(EditAnywhere)int32 CountdownTime; 然后该变量的修改便可在Details（细节面板）中进行 UFUNCTION()UFUNCTION()宏把C++函数对反射系统公开，BlueprintCallable选项将对其蓝图虚拟机公开 BlueprintCallable：该函数可以在蓝图或关卡蓝图图表中执行 BlueprintImplementableEvent：此函数可以在蓝图或关卡蓝图图表内进行重载 BlueprintNativeEvent：此函数将由蓝图进行重载，但同时也包含native类的执行。提供一个名称为[FunctionName]_Implementation的函数本体而非[FunctionName];自动生成的代码将包含转换程序,此程序在需要时会调用实施方式 游戏客户端公开课学习文档","categories":[{"name":"GameDev","slug":"GameDev","permalink":"https://chasencenge.github.io/categories/GameDev/"}],"tags":[{"name":"GameDev","slug":"GameDev","permalink":"https://chasencenge.github.io/tags/GameDev/"}]},{"title":"实时计算机图形学笔记","slug":"实时计算机图形学笔记","date":"2020-10-02T12:04:03.000Z","updated":"2020-10-26T09:31:51.557Z","comments":true,"path":"2020/10/02/实时计算机图形学笔记/","link":"","permalink":"https://chasencenge.github.io/2020/10/02/实时计算机图形学笔记/","excerpt":"","text":"","categories":[{"name":"GameDev","slug":"GameDev","permalink":"https://chasencenge.github.io/categories/GameDev/"}],"tags":[{"name":"GameDev","slug":"GameDev","permalink":"https://chasencenge.github.io/tags/GameDev/"}]},{"title":"腾讯游戏开发精粹笔记","slug":"腾讯游戏开发精粹笔记","date":"2020-09-25T06:07:13.000Z","updated":"2020-12-28T12:31:24.697Z","comments":true,"path":"2020/09/25/腾讯游戏开发精粹笔记/","link":"","permalink":"https://chasencenge.github.io/2020/09/25/腾讯游戏开发精粹笔记/","excerpt":"一、游戏数学","text":"一、游戏数学 1.基于SDF的摇杆移动SDF：SDF全称Signed Distance Field（有号距离场），定义为空间中的点到形状表面的最小距离，并用正值表示点在形状外部，负值表示点在形状内部。 为什么要使用SDF？空间换时间，在O(1)时间复杂度计算出是否碰撞。 如何判断碰撞？基于已有SDF信息的栅格，使用其邻近四个角的SD信息进行插值，得到当前点的SD，若SD&lt;=0, 则判定该点和碰撞物发生了碰撞。 插值获得任意点的SD值：123456789101112//计算位置pos的SD值//每个栅格的实际尺寸为grid，横向栅格数量为widthpublic float Sample(Vector2 pos)&#123; pos = pos / grid; int fx = Mathf.FloorToInt(pos.x); int fy = Mathf.FloorToInt(pos.y); float rx = pos.x - fx; float ry = pos.y - fy; int i = fy * width + fx; return (sdf[i]*(1-rx) + sdf[i+1]*rx)*(1-ry) + (sdf[i+width]*(1-rx) + sdf[i+width+1]*rx)*ry;&#125; 如何实现发生碰撞后绕障碍物滑行？ v表示摇杆方向，与障碍物发生碰撞后需要沿着v’方向滑行，n为碰撞法线，v’和v有以上关系。 如何获取碰撞法线n？利用SDF的梯度作为碰撞法线。 求梯度方向：12345678public Vector2 Gradient(Vector2 pos)&#123; float delta = 1f; return 0.5f * new Vector2( Sample(new Vector2(pos.x+delta, pos.y)) - Sample(new Vector2(pos.x-delta, pos.y)), Sample(new Vector2(pos.x, pos.y+delta)) - Sample(new Vector2(pos.x, pos.y-delta)) );&#125; 发生碰撞后实际移动方向代码：123456789101112131415161718192021222324252627282930//获取在移动过程使用SDF得到的最佳位置public Vector2 GetValidPositionBySDF(Vector2 pos, Vector2 dir, float speed)&#123; Vector2 newPos = pos + dir * speed; float SD = Sample(newPos); //不可行走 if(SD &lt; playerRadius) &#123; Vector2 gradient = Gradient(newPos); Vector2 adjustDir = dir - gradient * Vector2.Dot(gradient, dir); newPos = pos + adjustDir.normalized * speed; &#125; //多次迭代 for(int i = 0; i &lt; 3; i++) &#123; SD = Sample(newPos); if(SD &gt;= playerRadius) break; newPos += Gradient(newPos) * (playerRadius - SD); &#125; //避免往返 if(Vector2.Dot(newPos - pos, dir) &lt; 0) &#123; newPos = pos; &#125; return newPos;&#125; 角色不能越过障碍物的远距离移动用于当校色进行瞬时远距离移动但不能越过障碍物的情况。 使用连续碰撞检测规避穿越障碍物的情况，具体方法是圆盘投射（Disk Casting）。 使用圆盘投射计算位置：123456789101112131415//oriPos:原始位置，dir:冲刺方向，radius:角色半径，maxDist:最大冲刺距离public Vector2 DiskCast(Vector2 origin, Vector2 dir, float radius, float maxDist)&#123; float t = 0f; while(true) &#123; Vector2 p = origin + dir * t; float sd = Sample(p); if(sd &lt;= radius) return p; t += sd - radius; if(t &gt;= maxDist) return origin + dir * maxDist; &#125;&#125; 动态地图在均匀网格地图上，当角色在一帧内的行走距离不会超过单个网格大小时，可以通过检测每一帧与玩家所在网格相邻的8个网格的碰撞来实现规避障碍物的功能。 红色为障碍物区域，虚线圆圈为角色。 实现规避障碍物：12345678910111213141516171819202122232425262728293031323334353637383940414243float EvalSDF(Vector2 p)&#123; //坐标离散成网格 int x = posToGridX(p); int y = posToGridY(p); float dist = cellSize; int center = grid[y * width + x]; //WALL格子不可行走 //检测与玩家最近的距离 if(center == WALL) &#123; dist = min(dist, sdBox(centerPos - vecTopLeft, cellExtents)); &#125; int topleft = grid[(y - 1) * width + (x - 1)]; if(topleft == WALL) &#123; dist = min(dist, sdBox(centerPos - vecTop, cellExtents)); &#125; //... return dist;&#125;Vector2 EvalGradient(Vector2 p)&#123; //...&#125;void Update()&#123; //新目标位置 Vector2 nextPlayerPos = playerPos + moveDir * moveSpeed; //目标位置的最近距离 float d = EvalSDF(nextPlayerPos); //距离小于玩家半径，有穿插 if(d &lt; playerRadius) &#123; //计算最近表面的法线 Vector2 n = EvalGradient(nextPlayerPos); //将玩家推出障碍区域 nextPlayerPos = nextPlayerPos + n * (playerRadius - d); &#125; playerPos = nextPlayerPos;&#125; 场景中的其他障碍物，如较大的汽车、其他玩家等，可通过矩形、圆形的SDF函数来表示，并将结果与网格地图取出的SDF做交集操作。 圆盘SDF:12345//x为任意点坐标，c为圆盘中心，r为圆盘半径float sdCircle(Vector2 x, Vector2 c, float r)&#123; return (x - c).length() - r;&#125; 矩形SDF:d = (x - c)R(-θ) - b Φx = min(max(dx, dy), 0) + ||max(d, 0)|| 1234567//x为任意点坐标，c为矩形中心，rot为矩形旋转角度，b为矩形边长float sdBox(Vector2 x, Vector c, Vector2 rot, Vector2 b)&#123; Vector2 p = Vector2.Dot(x - c, -rot); Vector2 d = Vector2.Abs(p) - b; return Mathf.Min(Mathf.Max(d.x, d.y), 0f) + Vector2.Max(d, Vector2.zero).Length(); &#125; 2. 高性能的定点数实现方案用途解决不同平台上的浮点数运算结果不同而导致的对帧同步的严重影响。 32位浮点数结构 S=0时为正数，S=1时为负数 基于整数的二进制表示的定点数原理设a为定点数，f(a)为这个定点数对应的整数值 a = 2^-n^f(a) 32和64位定点数表示原理 32位定点数表示的范围：[-2^21^, 2^21^ - 2^-10^] 64位定点数表示的范围：[-2^31^, 2^31^ - 2^-32^] 定点数四则运算a + b = 2^-n^ (f(a) + f(b)) a - b = 2^-n^ (f(a) - f(b)) ab = (2^-n^)^2^ f(a) f(b) = 2^-n^ (2^-n^ f(a) f(b)) a / b = 2^-n^ (2^n^ f(a) / f(b)) 二、游戏物理1. 一种高效的弧长参数化路径系统需求在跑酷游戏中，人物的移动靠路径引导；想要实现“弧长参数化”的特性—即令曲线参数t与曲线长度为L为线性关系，从而将参数t的线性变化映射到长度的线性变化上，实现曲线上的匀线速度运动。 曲线路径系统需求：路径布置简单，最直观的就是布置路点。 修改具有局部性，修改一个路点只会影响上下游。 曲线至少具有C1连续性，满足基本的光滑需求。 两个路点之间的曲线可以是异面曲线，等同于可以自由控制邻接路点曲线的方向。 与曲线相关的计算尽量简单，尽量少地进行迭代计算。 端点间二次样条的构建为什么要拼接两条二次曲线？要求两个路点可以自由控制位置和朝向（切线方向），单一的一段二次曲线自由度不够。 二次样条曲线： 起点P0、起点切线T0、终点P1、终点切线T1。 f1(t) = a1t^2^ + b1t + c1 f2(t) = a2t^2^ + b2t + c2 为了将分段曲线当作一段曲线使用，需将两段曲线的参数t归一化到统一的[0, 1]范围内，fs(0) = P0，fs(1) = P1。 例如当L1长度为4，L2长度为6，归一化t = 0.3时，fs(t) = fs(0.3) = f1(0.3 x 10 / 4) = f1(3/4)，恰好对应L1的四分之三位置。 路径的构建路径为路点间曲线的拼接，切线的设置模仿Catmull-Rom这类Cardinal曲线的做法：路点i处的切线由路点i-1和路点i+1的位置决定： Ti = τ(Pi+1 - Pi-1), τ为切线的缩放因子（张弛因子） 使用邻接路点的信息构建曲线时，将邻接路点转换到自己的局部坐标系下，在上图的构建中，Pi处于坐标原点且旋转为(0, 0, 0)，最后在使用路径时，每段曲线的计算结果要做一次从局部到世界坐标系的转换，好处是路径作为一个整体不受刚体变换的影响，适合游戏中场景动态拼接的需求。 弧长的重参数化（arc-length parametrization）为什么要做弧长的重参数化？可近似理解为在曲线上，每一点处的速度不同，相同的Δt内对应“走过”的弧长也不相同。 例如，对于曲线： 直接用t取点，具有明显不均匀现象： arc-length:定义一个映射Δ: [a, b] -&gt; [0, L], 获取原弧线参数t的定义域到弧长区间上的一个满射： 其反函数设为Φ(s)，那么在给定s位置下，对应曲线参数为Φ(s)，对于上述曲线，先求Δ(t)，再求其反函数： 其反函数： 重参数化形式： arc-length参数化后结果： 曲线上的简单运动法平面定义：过空间曲线的切点并且与切线垂直的平面。 相邻路径的切换路径切换的过程中，使用当前路径上的基准点的法平面与另一路径的交点（等位点），由于路径的切换不能瞬时完成，将当前基准点变换到相邻路径基准点的局部坐标系下，将变换后的值和(O, X, Y, Z)插值的结果转换到世界坐标系，作为当前基准点及其关联的局部坐标系输入给物理模块。 曲线上的旋转插值 2. 船的物理模拟及同步设计船的两种刚体移动碰撞体：用于计算浮力的动态刚体 射击碰撞体：用来做射击检测的动力学动态刚体 浮力计算中计算多面体入水体积分成三角面判断，一个三角面只有三种状态：完全入水、完全出水、部分出水。 三角面完全入水，则三角面可以和P形成四面体为入水体积（点P必须在水面上）。 三角面完全出水，丢弃。 三角面部分入水，分两种情况，两点入水和一点入水。两点入水，分成的三个三角形，将水面上部的丢弃；一点入水，分成的三个三角形将水面上的两个三角形丢弃。 于是，入水体积的求解收敛为两个问题： 求一个四面体的体积。 已知三角形的顶点A, B, C, 求与水面的交点问题。 浮力系统物理更新机制 三种第三方位置同步方法： 设置位置：会造成物体瞬移。 设置速度：通过计算位移差求出速度，在物理引擎进行物理模拟前应用到动态刚体上。 设置力：增加了一层间接性。 问题：第三方同步组件会每帧更新刚体的速度，浮力组件会每帧更新刚体受到的力，会造成位置的不一致（例如第三方刚体本来以速度v移动到位置X，但是浮力组件在速度方向上施加了阻力、浮力和升力，从而使物理系统算出的速度和v有偏差，导致最终物理模拟结束时物体的位置不是X）。 解决：浮力系统根据是否是第一方选择最终计算结果是力还是速度。 Component物理更新的过程：第一方通过引擎组件(EngineComponent)计算出驱动力，通过浮力组件(BuoyancyComponent)计算出浮力，将这些力在物理引擎进行物理模拟之前统一施加在刚体组件(PhyComponent)上； 第三方通过同步组件(SyncComponent)计算出下一帧的同步速度，通过浮力组件计算出的浮力推算出下一帧的浮力速度，将这两个速度糅合后，在物理引擎进行物理模拟之前设置在刚体组件上。","categories":[{"name":"GameDev","slug":"GameDev","permalink":"https://chasencenge.github.io/categories/GameDev/"}],"tags":[{"name":"GameDev","slug":"GameDev","permalink":"https://chasencenge.github.io/tags/GameDev/"}]},{"title":"容器","slug":"容器","date":"2020-09-15T13:50:54.000Z","updated":"2020-12-28T12:31:32.081Z","comments":true,"path":"2020/09/15/容器/","link":"","permalink":"https://chasencenge.github.io/2020/09/15/容器/","excerpt":"容器与镜像进程可见、可相互通信、共享一份文件系统 高级权限的进程可能破环低权限的进程 资源抢占 Linux通过 chroot 可将一个子目录变成根目录 namespace在资源视图上进行隔离 cgroup限制资源使用率 容器：容器是一个视图隔离、资源可限制、独立文件系统的进程集合 镜像：运行容器需要的所有文件集合 构建步骤所带来的文件系统的变化叫做changeset 镜像可进行分层复用 如何构建镜像？编写Dockerfile // 表示以下的步骤是基于golang构建的 FROM golang:1.12-alpine // 类似于cd WORKDIR /go/src/app // 把数据拷入到容器内 COPY //下载依赖 RUN go get -d -v ./... //创建应用并安装 RUN go install -v ./... //使用镜像默认程序的名字是什么 CMD [&quot;app&quot;] 有了这样一个Dockerfile之后就可以通过docker build构建镜像（存储到本地的） docker registry进行镜像数据的存储和转发，通过 docker push可以将本地的镜像推送到镜像仓库中","text":"容器与镜像进程可见、可相互通信、共享一份文件系统 高级权限的进程可能破环低权限的进程 资源抢占 Linux通过 chroot 可将一个子目录变成根目录 namespace在资源视图上进行隔离 cgroup限制资源使用率 容器：容器是一个视图隔离、资源可限制、独立文件系统的进程集合 镜像：运行容器需要的所有文件集合 构建步骤所带来的文件系统的变化叫做changeset 镜像可进行分层复用 如何构建镜像？编写Dockerfile // 表示以下的步骤是基于golang构建的 FROM golang:1.12-alpine // 类似于cd WORKDIR /go/src/app // 把数据拷入到容器内 COPY //下载依赖 RUN go get -d -v ./... //创建应用并安装 RUN go install -v ./... //使用镜像默认程序的名字是什么 CMD [&quot;app&quot;] 有了这样一个Dockerfile之后就可以通过docker build构建镜像（存储到本地的） docker registry进行镜像数据的存储和转发，通过 docker push可以将本地的镜像推送到镜像仓库中","categories":[{"name":"Docker","slug":"Docker","permalink":"https://chasencenge.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://chasencenge.github.io/tags/Docker/"}]},{"title":"贪心专题","slug":"贪心专题","date":"2020-09-15T11:24:25.000Z","updated":"2020-12-28T08:56:46.769Z","comments":true,"path":"2020/09/15/贪心专题/","link":"","permalink":"https://chasencenge.github.io/2020/09/15/贪心专题/","excerpt":"12. 整数转罗马数字12345678910111213141516// 处理上有优先级，对于当前的数，优先处理大于1000的部分，然后处理900，500，400.....（每一部分的处理方式也有固定的对应） --&gt; 贪心算法string intToRoman(int num) &#123; string res; vector&lt;int&gt; store&#123; 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 &#125;; vector&lt;string&gt; strs&#123; \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" &#125;; int n = store.size(); for (int i = 0; i &lt; n; i++) &#123; while (num &gt;= store[i]) &#123; res.append(strs[i]); num -= store[i]; &#125; &#125; return res;&#125;","text":"12. 整数转罗马数字12345678910111213141516// 处理上有优先级，对于当前的数，优先处理大于1000的部分，然后处理900，500，400.....（每一部分的处理方式也有固定的对应） --&gt; 贪心算法string intToRoman(int num) &#123; string res; vector&lt;int&gt; store&#123; 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 &#125;; vector&lt;string&gt; strs&#123; \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" &#125;; int n = store.size(); for (int i = 0; i &lt; n; i++) &#123; while (num &gt;= store[i]) &#123; res.append(strs[i]); num -= store[i]; &#125; &#125; return res;&#125; 13. 罗马数字转整数123456789101112131415int romanToInt(string s) &#123; int res = 0; map&lt;char, int&gt; hash&#123; &#123;'M', 1000&#125;, &#123;'D', 500&#125;, &#123;'C', 100&#125;, &#123;'L', 50&#125;, &#123;'X', 10&#125;, &#123;'V', 5&#125;, &#123;'I', 1&#125; &#125;; for (int i = 0; i &lt; s.size(); i++) &#123; // s.size()为'\\0',将'\\0'赋给int型变量时，变量值为0； if (hash[s[i]] &lt; hash[s[i + 1]]) res -= hash[s[i]]; else res += hash[s[i]]; &#125; cout &lt;&lt; s[s.size()]; return res;&#125; 55. 跳跃游戏在每个能到达的点检查从该点出发能到达的最远距离，最远距离超过nums.size() - 1则能到达终点 如何判断中间的某一点是否能到达？ 因为是顺序遍历所有位置，每次遍历当前位置时都用maxPos检查是否能达到下一点，如果无法达到说明已经中断，此时使用break跳出循环","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/tags/Algorithm/"}]},{"title":"递归专题","slug":"回溯专题","date":"2020-09-08T06:17:54.000Z","updated":"2020-12-28T12:32:15.120Z","comments":true,"path":"2020/09/08/回溯专题/","link":"","permalink":"https://chasencenge.github.io/2020/09/08/回溯专题/","excerpt":"回溯算法的写法：画出递归树，找到状态变量（回溯函数的参数）根据题意确立结束条件找准选择列表判断是否需要剪枝（去掉重复的集合，即去掉递归树上的某些分支）做出选择，递归调用，进入下一层撤销选择","text":"回溯算法的写法：画出递归树，找到状态变量（回溯函数的参数）根据题意确立结束条件找准选择列表判断是否需要剪枝（去掉重复的集合，即去掉递归树上的某些分支）做出选择，递归调用，进入下一层撤销选择 77. 组合12345678910111213141516171819202122232425262728293031323334//给出n，k返回可能的组合vector&lt;vector&lt;int&gt;&gt; res;vector&lt;int&gt; temp;void dfs(int cur, int n, int k)&#123; // 如果[cur, n]中元素的个数加上temo中元素的个数少于k，无法构成需要的组合 if (temp.size() + (n - cur + 1) &lt; k) &#123; return; &#125; // 如果temp的size == k，说明找到了组合，插入res if (temp.size() == k) &#123; res.push_back(temp); return; &#125; // 小于k的话继续往里添加元素 if (temp.size() &lt; k) &#123; // 考虑选择当前位置 temp.push_back(cur); dfs(cur + 1, n, k); temp.pop_back(); // 考虑不选择当前位置 dfs(cur + 1, n, k); &#125;&#125;vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; dfs(1, n, k); return res;&#125; 39. 组合总和12345678910111213141516171819202122232425262728293031323334// 因为是数据可重复选择的情况，所以在回溯中，可选择跳过和不跳过当前数值，这样就会包括某一个值重复选择的情况，在不跳过当前值的选择中，需要确定当前数值没有超过所需值vector&lt;vector&lt;int&gt;&gt; res;vector&lt;int&gt; temp;void dfs(int cur, int n, vector&lt;int&gt;&amp; candidates, int remain)&#123; if(cur == n) &#123; return; &#125; if(remain == 0) &#123; res.push_back(temp); return; &#125; // 不选择当前位置，直接跳过 dfs(cur + 1, n, candidates, remain); // 选择当前数，不跳过，不跳过的话需要判断当前数是否还能选择 if(candidates[cur] &lt;= remain) &#123; temp.push_back(candidates[cur]); remain -= candidates[cur]; dfs(cur, n, candidates, remain); temp.pop_back(); &#125; &#125;vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; int n = candidates.size(); dfs(0, n,candidates, target); return res;&#125; 401. 二进制手表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748vector&lt;string&gt; res;unordered_map&lt;int, int&gt; hashdata = &#123;&#123;0,1&#125;,&#123;1,2&#125;,&#123;2,4&#125;,&#123;3,8&#125;,&#123;4,1&#125;,&#123;5,2&#125;,&#123;6,4&#125;,&#123;7,8&#125;,&#123;8,16&#125;,&#123;9,32&#125;&#125;;void backtrack(int num,int start,pair&lt;int,int&gt;&amp; time)&#123; // 结束条件 if(num == 0) &#123; if(time.first &gt; 11 || time.second &gt; 59) &#123; return; &#125; string temp_hour = to_string(time.first); string temp_minute = to_string(time.second); if(temp_minute.size() == 1) &#123; temp_minute.insert(0, \"0\"); &#125; res.push_back(temp_hour + \":\" + temp_minute); return; &#125; for(int i = start; i &lt; 10; i++) &#123; if(time.first &gt; 11 || time.second &gt; 59) &#123; continue; &#125; // 在本层中创建一个变量store用来存储当前的time值，回退时使用 pair&lt;int, int&gt; store = time; if(i &lt; 4) &#123; time.first += hashdata[i]; &#125; else &#123; time.second += hashdata[i]; &#125; backtrack(num - 1, i + 1, time); // 在同层回退时把前面存好的store再赋给time，时time恢复到原状态 time = store; &#125;&#125;vector&lt;string&gt; readBinaryWatch(int num) &#123; pair&lt;int, int&gt; time(0, 0); backtrack(num, 0, time); return res;&#125; 40. 组合总数212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 去重复结果组合使用pair计数，将给的数组里的相同数值的数放在一起去递归处理vector&lt;int&gt; temp;vector&lt;vector&lt;int&gt;&gt; res;vector&lt;pair&lt;int, int&gt;&gt; freq;void dfs(int pos, int rest)&#123; if(rest == 0) &#123; res.push_back(temp); return; &#125; if(pos == freq.size() || rest &lt; freq[pos].first) &#123; return; &#125; dfs(pos+1, rest); // most用来判断处理相同数值的数时，进行几次递归，例如有五个2，但是target是7，那么只进行对2这个数值只进行三次递归 int most = min(rest / freq[pos].first, freq[pos].second); for(int a = 1; a &lt;= most; a++) &#123; temp.push_back(freq[pos].first); dfs(pos+1, rest - a * freq[pos].first); &#125; for(int b = 1; b &lt;= most; b++) &#123; temp.pop_back(); &#125; &#125;vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; // vector&lt;pair&lt;int, int&gt;&gt; freq; sort(candidates.begin(), candidates.end()); for(int num : candidates) &#123; if(freq.empty() || num != freq.back().first) &#123; // 用push_back的话需要make_pair，用emplace_back则不需要 // freq.push_back(make_pair(num, 1)); freq.emplace_back(num, 1); &#125; else &#123; ++freq.back().second; &#125; &#125; dfs(0, target); return res;&#125; 216. 组合总数3123456789101112131415161718192021222324vector&lt;int&gt; temp;vector&lt;vector&lt;int&gt;&gt; res;void dfs(int cur, int remain, int k)&#123; if(remain == 0 &amp;&amp; temp.size() == k) &#123; res.push_back(temp); return; &#125; if(cur &gt; remain || temp.size() == k || cur &gt; 9) &#123; return; &#125; temp.push_back(cur); dfs(cur+1, remain-cur, k); temp.pop_back(); dfs(cur+1, remain, k);&#125;vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123; dfs(1, n, k); return res;&#125; 22. 括号生成回溯函数参数：要生成的括号对数n，存结果的vector rets，单个结果的string ret，当前左括号数open，当前右括号数close 用ret.size() == 2 * n判断是否将ret添加到结果rets 用open &lt; n判断是否继续添加左括号 用close &lt; open判断当前是否能添加右括号 46. 全排列什么情况适合使用回溯法： 通过探索所有可能的候选解来找出所有解 终止条件为： 1cur == len 回溯体结构为： 从已构造长度开始往后，逐个与当前位置进行数据交换 123456for(int i = cur; i &lt; len; i++)&#123; swap(output[cur], output[i]); backtrack(ret, output, cur+1, len); swap(output[cur], output[i]); //回溯里一定要记得的撤销操作&#125; 78. 子集没啥说的，最基础的回溯….","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/tags/Algorithm/"}]},{"title":"查找专题","slug":"查找专题","date":"2020-09-03T12:56:48.000Z","updated":"2020-12-28T12:32:55.614Z","comments":true,"path":"2020/09/03/查找专题/","link":"","permalink":"https://chasencenge.github.io/2020/09/03/查找专题/","excerpt":"4. 寻找两个正序数组的中位数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//二分查找//写一个查找第k大的函数，k值在运行过程中会慢慢减小int findKthElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k)&#123; int m = nums1.size(); int n = nums2.size(); int index1 = 0; int index2 = 0; while (true) &#123; //nums1中的指针位置已经到了末尾，直接在num2中找剩下的第k大 if (index1 == m) &#123; return nums2[index2 + k - 1]; &#125; if (index2 == n) &#123; return nums1[index1 + k - 1]; &#125; if (k == 1) &#123; return min(nums1[index1], nums2[index2]); &#125; //边界检测，index如果加了k / 2 - 1越界了，就直接将新的index设置为数组的最后一位 int newIndex1 = min(index1 + k / 2 - 1, m - 1); int newIndex2 = min(index2 + k / 2 - 1, n - 1); int pivot1 = nums1[newIndex1]; int pivot2 = nums2[newIndex2]; if (pivot1 &lt;= pivot2) &#123; //更新k和index k -= newIndex1 - index1 + 1; index1 = newIndex1 + 1; &#125; else &#123; k -= newIndex2 - index2 + 1; index2 = newIndex2 + 1; &#125; &#125;&#125;double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int totalLength = nums1.size() + nums2.size(); if (totalLength % 2 == 1) &#123; //奇数总数和偶数总数分开讨论 return findKthElement(nums1, nums2, (totalLength + 1) / 2); &#125; else &#123; return (findKthElement(nums1, nums2, totalLength / 2) + findKthElement(nums1, nums2, totalLength / 2 + 1)) / 2.0; &#125;&#125;","text":"4. 寻找两个正序数组的中位数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//二分查找//写一个查找第k大的函数，k值在运行过程中会慢慢减小int findKthElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k)&#123; int m = nums1.size(); int n = nums2.size(); int index1 = 0; int index2 = 0; while (true) &#123; //nums1中的指针位置已经到了末尾，直接在num2中找剩下的第k大 if (index1 == m) &#123; return nums2[index2 + k - 1]; &#125; if (index2 == n) &#123; return nums1[index1 + k - 1]; &#125; if (k == 1) &#123; return min(nums1[index1], nums2[index2]); &#125; //边界检测，index如果加了k / 2 - 1越界了，就直接将新的index设置为数组的最后一位 int newIndex1 = min(index1 + k / 2 - 1, m - 1); int newIndex2 = min(index2 + k / 2 - 1, n - 1); int pivot1 = nums1[newIndex1]; int pivot2 = nums2[newIndex2]; if (pivot1 &lt;= pivot2) &#123; //更新k和index k -= newIndex1 - index1 + 1; index1 = newIndex1 + 1; &#125; else &#123; k -= newIndex2 - index2 + 1; index2 = newIndex2 + 1; &#125; &#125;&#125;double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int totalLength = nums1.size() + nums2.size(); if (totalLength % 2 == 1) &#123; //奇数总数和偶数总数分开讨论 return findKthElement(nums1, nums2, (totalLength + 1) / 2); &#125; else &#123; return (findKthElement(nums1, nums2, totalLength / 2) + findKthElement(nums1, nums2, totalLength / 2 + 1)) / 2.0; &#125;&#125; 34. 在排序数组中查找元素的第一个和最后一个位置排序数组直接联想二分查找 对二分查找做适合题目要求的改动，有多个连续的target值，寻找左边界时要找到最左面的target下标，则需要在findLeft函数中添加判断： 12if(nums[mid] == target) right = mid; 使有边界逐渐向左逼近，以保证最后走出 while(left &lt; right) 循环时，left在多个相同的target中的最左面 在findRight函数中不仅需要添加判断： 12if(nums[mid] == target) left = mid; 特别注意，还需要修改mid的计算： 1mid = (left + right + 1) / 2 这里如果不加1的话，当left == right-1时，计算mid永远等于left，无法退出循环 347. 前 K 个高频元素12345678910111213141516171819202122232425262728293031323334353637383940// 这里的static的添加是因为sory()第三个参数是个函数指针，然而cmp函数是一个非静态成员函数，非静态成员函数指针和普通函数指针是有区别的，为防止报错在类内的成员函数定义前添加static，或者把cmp函数定义写在类外static bool cmp(pair&lt;int,int&gt; a, pair&lt;int,int&gt; b) &#123; return a.second &gt; b.second; &#125; vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; map&lt;int,int&gt; countMap; int n = nums.size(); map&lt;int, int&gt;::iterator it; for(int i = 0; i &lt; n; i++) &#123; // 判断map中某个key是否存在，使用find()，（find()返回的是迭代器） it = countMap.find(nums[i]); if(it != countMap.end()) &#123; countMap[nums[i]]++; &#125; else &#123; // map中插入新的&lt;key, value&gt;对 countMap.insert(pair&lt;int,int&gt;(nums[i], 1)); &#125; &#125; // map没有sort()函数，因为map不是线性结构，所以为了排序，将map中的pair形式的成员放到vector中再进行排序 vector&lt;pair&lt;int,int&gt;&gt; vec; for(map&lt;int,int&gt;::iterator it = countMap.begin(); it != countMap.end(); it++) &#123; vec.push_back(pair&lt;int,int&gt;(it-&gt;first, it-&gt;second)); &#125; sort(vec.begin(), vec.end(), cmp); vector&lt;int&gt; res; vector&lt;pair&lt;int,int&gt;&gt;::iterator iter = vec.begin(); while(k) &#123; res.push_back(iter-&gt;first); iter++; k--; &#125; return res; &#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/tags/Algorithm/"}]},{"title":"滑动窗口专题","slug":"滑动窗口专题","date":"2020-09-03T11:18:54.000Z","updated":"2020-12-28T12:32:39.887Z","comments":true,"path":"2020/09/03/滑动窗口专题/","link":"","permalink":"https://chasencenge.github.io/2020/09/03/滑动窗口专题/","excerpt":"3. 无重复的最长字串","text":"3. 无重复的最长字串 1234567891011121314151617181920212223int lengthOfLongestSubstring(string s) &#123; int res = 0; //右指针 int rp = -1; unordered_set&lt;char&gt; seri; //i是左指针 for (int i = 0; i &lt; s.size(); i++) &#123; //每次循环开始的时候把上一次左指针指向的值删掉 if (i != 0) &#123; seri.erase(s[i - 1]); &#125; //例如abcdcefgh，到了第二个c会产生重复，rp会停在d这里，然后删掉a继续循环，发现仍不满足!seri.count(s[rp + 1])，因为c并没被删掉，所以跳过while继续循环，删掉b，知道删掉第一个c，while中才满足!seri.count(s[rp + 1])，这时才能进入while，rp继续向后走 while (rp + 1 &lt; s.size() &amp;&amp; !seri.count(s[rp + 1])) &#123; seri.insert(s[rp + 1]); rp++; &#125; res = max(res, rp - i + 1); &#125; return res;&#125; 76. 最小覆盖字串用两个map分别记录所需包含的字母及其个数(ori)，以及当前窗口内所含所需字母及其个数(cnt) 每次检查时，检查ori中的每个key对应的value和cnt中对应的value，cnt中的值不能小于ori，不然意味着当前窗口未完全包含所需的所有字符 1234567891011bool check(unordered_map&lt;char, int&gt;&amp; ori, unordered_map&lt;char, int&gt;&amp; cnt)&#123; for(const auto&amp; p : ori) &#123; if(cnt[p.first] &lt; p.second) &#123; return false; &#125; &#125; return true;&#125; 当check满足条件，检查是否需要更新最小窗口长度len和结果起始点ansL，并且由于check满足条件需要将窗口左侧边界右移一位，所以此时如果最左侧的字母为ori中的一员，cnt对应的key的value减一 12345678910111213while(check(ori, cnt) &amp;&amp; l &lt;= r)&#123; if(r - l &lt; minLength) &#123; minLength = r - l; ansL = l; &#125; if(ori.find(s[l]) != ori.end()) &#123; --cnt[s[l]]; &#125; l++;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/tags/Algorithm/"}]},{"title":"","slug":"剑指offer","date":"2020-08-24T06:51:21.000Z","updated":"2020-12-28T08:57:02.935Z","comments":true,"path":"2020/08/24/剑指offer/","link":"","permalink":"https://chasencenge.github.io/2020/08/24/剑指offer/","excerpt":"29. 顺时针打印矩阵123456处理移动四个移动方向用：vector&lt;vector&lt;int&gt;&gt; move&#123; &#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125; &#125;;或者：static constexpr int directions[4][2] = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;标记矩阵的已访问元素和未访问元素用一个相同大小的bool矩阵visit输入一个空matrix时，如果对其求matrix[0].size()会报错，因为没有matrix[0]","text":"29. 顺时针打印矩阵123456处理移动四个移动方向用：vector&lt;vector&lt;int&gt;&gt; move&#123; &#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125; &#125;;或者：static constexpr int directions[4][2] = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;标记矩阵的已访问元素和未访问元素用一个相同大小的bool矩阵visit输入一个空matrix时，如果对其求matrix[0].size()会报错，因为没有matrix[0] 12345678910111213141516171819202122232425262728293031vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;int&gt; order; if (matrix.size() == 0 || matrix[0].size() == 0) &#123; return &#123;&#125;; &#125; int rowRange = matrix.size(); int colRange = matrix[0].size(); vector&lt;vector&lt;bool&gt;&gt; visit(rowRange, vector&lt;bool&gt;(colRange)); int total = rowRange * colRange; vector&lt;vector&lt;int&gt;&gt; move&#123; &#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125; &#125;; int row = 0; int col = 0; int moveIndex = 0; int nextRow, nextCol; for (int i = 0; i &lt; total; i++) &#123; order.push_back(matrix[row][col]); visit[row][col] = true; nextRow = row + move[moveIndex][0]; nextCol = col + move[moveIndex][1]; if (nextRow &gt;= rowRange || nextRow &lt; 0 || nextCol &gt;= colRange || nextCol &lt; 0 || visit[nextRow][nextCol]) &#123; moveIndex = (moveIndex + 1) % 4; &#125; row += move[moveIndex][0]; col += move[moveIndex][1]; &#125; return order;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/tags/Algorithm/"}]},{"title":"dp专题","slug":"dp专题","date":"2020-08-18T07:54:15.000Z","updated":"2020-12-28T08:56:50.806Z","comments":true,"path":"2020/08/18/dp专题/","link":"","permalink":"https://chasencenge.github.io/2020/08/18/dp专题/","excerpt":"5.最长回文子串单独处理长度为1和2的字符串 状态转移：字串加上相同的首尾","text":"5.最长回文子串单独处理长度为1和2的字符串 状态转移：字串加上相同的首尾 1dp[i][j] = (s[i] == s[j] &amp;&amp; dp[i+1][j-1]); 12345678910111213141516171819202122232425262728293031323334string longestPalindrome(string s) &#123; string ans; int n = s.size(); //初始化二维vector，初始值为0 vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n)); //外层循环用的是字串的长度，dp矩阵对角线（i==j）代表字串长度为1，对角线两侧的斜线代表字串长度为2，依次往外扩展更新 for (int len = 0; len &lt; n; len++) &#123;c //对于dbabcad，首轮更新d, b, a, b, c, a, d对应的dp; 第二轮更新db, ba, ab, bc, ca, ad对应的dp; 然后是dba, bab, abc......（它根据首轮的更新的dp做s[i] == s[j] &amp;&amp; dp[i + 1][j - 1]判断） for (int i = 0; i &lt; n - len; i++) &#123; int j = i + len; if (len == 0) &#123; dp[i][j] = 1; &#125; else if (len == 1) &#123; dp[i][j] = s[i] == s[j]; &#125; else &#123; dp[i][j] = (s[i] == s[j] &amp;&amp; dp[i + 1][j - 1]); &#125; //如果找到了更长的字串，更新新的字串 if (dp[i][j] &amp;&amp; len + 1 &gt; ans.size()) &#123; //substr(i, j): 从下标i开始截取j位 ans = s.substr(i, len + 1); &#125; &#125; &#125; return ans;&#125; 53. 最大子序和状态转移：nums[i]为当前遍历到的数，比较在已有数组上加上当前数值（数组里加当前数值）和当前数值的大小（开一个新数组） 1max(f[i-1]+nums[i], nums[i]) 12345678910111213141516int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; f; if(nums.empty()) &#123;return 0;&#125; f.push_back(nums[0]); for(int i = 1; i &lt; nums.size(); i++) &#123; f.push_back(max(f[i-1]+nums[i], nums[i])); &#125; int compare = f[0]; for(auto x:f) &#123; compare = max(x, compare); &#125; return compare; &#125; 超级码力复赛 3.秋叶收藏集123456要将叶子调整为“红黄红”排列，r为红，y为黄，每次可将r调整为y，也可将y调整为r，求调整所需最小次数示例：输入：leaves = &quot;rrryyyrryyyrr&quot;输出：2解释：调整两次，将中间的两片红叶替换成黄叶，得到 &quot;rrryyyyyyyyrr&quot; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970int minimumOperations(string leaves) &#123; int n = leaves.size(); //cout &lt;&lt; \"n\" &lt;&lt;n &lt;&lt; endl; int start = 0; int end = leaves.size() - 1; vector&lt;vector&lt;int&gt;&gt; dp(n - 2, vector&lt;int&gt;(n - 2, 100000)); int temp = 0; if (leaves[0] == 'y') &#123; temp++; &#125; if (leaves[1] == 'r') &#123; temp++; &#125; for (int i = 2; i &lt; n; i++) &#123; if (leaves[i] == 'y') &#123; temp++; &#125; &#125; dp[0][1] = temp; int x = 0; int y = 2; while (x != n - 3) &#123; while (y != n - 2) &#123; if (leaves[y] == 'y') dp[x][y] = dp[x][y - 1] - 1; else dp[x][y] = dp[x][y - 1] + 1; y++; &#125; if (x + 2 == n - 2) break; //cout &lt;&lt; \"test\" &lt;&lt; endl; if (leaves[x+1] == 'y') dp[x + 1][x + 2] = dp[x][x + 2] + 1; else dp[x + 1][x + 2] = dp[x][x + 2] - 1; //cout &lt;&lt; \"test2\" &lt;&lt; endl; x++; y = x + 2; //cout &lt;&lt; \"x y \" &lt;&lt; x &lt;&lt; y &lt;&lt; endl; /*for (int a = 0; a &lt; dp.size(); a++) &#123; for (int b = 0; b &lt; dp[0].size(); b++) &#123; cout &lt;&lt; dp[a][b] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; &#125;*/ &#125; int res = dp[0][0]; for (int a = 0; a &lt; dp.size(); a++) &#123; for (int b = 0; b &lt; dp[0].size(); b++) &#123; if (dp[a][b] &lt; res) &#123; res = dp[a][b]; &#125; &#125; &#125; // cout &lt;&lt; res; return res;&#125; 32. 最长有效括号寻找转移方程： 每个dp元素代表以该位置为结尾的最长有效括号数，也就是说当以’)’为结尾才可能不为0 当发现s[i]位置以’)’结尾，检查s[i-1] 如果s[i-1] == &#39;(&#39;，dp[i] = dp[i-2] + 2 如果s[i-1] == &#39;)&#39;并且 s[i - dp[i-1] - 1] == &#39;(&#39; ，dp[i] = dp[i-1] + dp[i - dp[i-1] - 2] + 2 对第二种情况举例：( ) ( ( ) ( ) )，检测到最后一位为’)’并且倒数第二位也为’)’，这时dp[6] = 4, dp[7] = dp[6]（dp[i-1]） + dp[1]（dp[7 - dp[6] -2]） + 2 = 4 + 2 + 2，分别代表第四个到第七个括号组成的dp[i-1]、第一个和第二个括号组成的dp[i - dp[i-1] - 1]，（加上这个是因为除去dp[i-1]和第三个和第八个配对的括号以外，第一个和第二个括号也因为原本没有配对的第三个括号成功配对而连接起来）、第三个和第八个括号组成的新配对的括号组 47. 礼物的最大价值构造“矩阵最优路径的寻径问题”的dp矩阵，dp矩阵每个元素的含义是到当前点的最大收益 转移方程： 1dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]; 这样的话就需要填充边界：使dp矩阵的维度加一，填充0 本题的优化：可将dp矩阵维度降为一维，在每一个外层循环中覆盖更新dp 62. 不同路径转移方程: 1dp[i][j] = dp[i-1][j]+dp[i][j-1]; 动态规划中要下意识地思考是否能够降低空间复杂度 本题中每一行的计算都只需要当前行和上一行的信息，所以将空间复杂度O(n^2^)降至O(2n): 只构造两个一维数组pre和cur，分别保存上一行和当前行的值 每次修改完当前行的值以后，将当前行cur复制给pre 进一步优化空间复杂度至O(n): 只构造一个一维数组cur，对应上面的转移方程： 1cur[j] += cur[j-1]; 因为在更新cur[j]时，更新前的cur[j]即为上一行的j列值，只需在此之上加上cur[j-1]即可 64. 最小路径和转移方程： 12345678if(i == 1 || j == 1)&#123; dp[i][j] = i == 1 ? dp[i][j-1] + grid[i-1][j-1] : dp[i-1][j] + grid[i-1][j-1];&#125;else&#123; dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i-1][j-1];&#125; 为了防止下标左溢出，dp矩阵是(m+1) * (n+1)的，第一行和第一列填充0 第一行和第一列做单独处理，因为当前点的值应为左侧和上侧的较小值加上当前点的值，而第一行的点的值只能为左侧的值加上当前点的值，第一列的点的值只能为上侧的点的值加上当前点的值 70. 爬楼梯转移方程： 123456dp[1] = 1;dp[2] = 2;for(int i = 3; i &lt;= n; i++)&#123; dp[i] = dp[i-2] + dp[i-1];&#125; 防止左溢出，提前设定dp[1]和dp[2]，并设置n=1和n=2时的返回值 72. 编辑距离问题本质等同于有三种操作： 在单词 A 中插入一个字符，如果horse到ro的编辑距离为a，那么到ros的编辑距离不会超过a+1 在单词 B 中插入一个字符，如果hors到ros的编辑距离为b，那么horse到ros的编辑距离不会超过b+1 修改单词 A 的一个字符，如果hors到ro的编辑距离为c，那么horse到ros的编辑距离不会超过c+1 因此产生状态转移方程： 12int label = word1[i-1] == word2[j-1] ? 0 : 1; //先判断A和B最后一个字母是否相同dp[i][j] = min(min(dp[i-1][j] + 1, dp[i][j-1] + 1), dp[i-1][j-1] + label);","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/tags/Algorithm/"}]},{"title":"LeetCode top100刷题","slug":"LeetCode-top&hot刷题","date":"2020-08-03T15:15:27.000Z","updated":"2020-12-28T12:32:27.904Z","comments":true,"path":"2020/08/03/LeetCode-top&hot刷题/","link":"","permalink":"https://chasencenge.github.io/2020/08/03/LeetCode-top&hot刷题/","excerpt":"1. 两数之和12345678910111213vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target)&#123; /*map*/ umordered_map&lt;int, int&gt; hashtable; for(int i = 0; i &lt; nums.size(); i++) &#123; auto it = hashtable.find(target - nums[i]); if(it != hashtable.end()) return &#123;it-&gt;second, i&#125;; hashtable[nums[i]] = i; &#125; return &#123;&#125;;&#125;","text":"1. 两数之和12345678910111213vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target)&#123; /*map*/ umordered_map&lt;int, int&gt; hashtable; for(int i = 0; i &lt; nums.size(); i++) &#123; auto it = hashtable.find(target - nums[i]); if(it != hashtable.end()) return &#123;it-&gt;second, i&#125;; hashtable[nums[i]] = i; &#125; return &#123;&#125;;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*先排序，再利用双指针遍历，初始i放首部，j放尾部，两数之和大于target的话j--，小于target的话i++，找到对应的i和j*/vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; resV&#123; 0, 0 &#125;; vector&lt;int&gt; copyV = nums; int find; int hasFound = 0; sort(nums.begin(), nums.end()); /* for(int k = 0; k &lt; nums.size(); k++)*/ /* &#123;cout &lt;&lt; nums[k] &lt;&lt; \" \";&#125;*/ int i = 0; int j = nums.size() - 1; while (i != j &amp;&amp; hasFound == 0) &#123; if (target &gt; nums[i] + nums[j]) &#123; i++; &#125; else if (target &lt; nums[i] + nums[j]) &#123; j--; &#125; else &#123; /*找到i和j还没结束，要根据nums[i], nums[j]找到排序前的数组中对应的原始下标 found1防止数组中有相同的值k使得k + k = target导致只能（进入下面的if）更新resV[0]的值 这样，如果在原数组中找到第一个k值时进入if，之后继续找到第二个k值的时候便不会再进入if重复更新resV[0]而导致resV[j]不被更新*/ int flag = 0, found1 = 0, label = 0; while (label != 2) &#123; if (copyV[flag] == nums[i] &amp;&amp; found1 == 0) &#123; label++; resV[0] = flag; found1 = 1; flag++; &#125; else if (copyV[flag] == nums[j]) &#123; label++; resV[1] = flag; flag++; &#125; else &#123; flag++; &#125; &#125; hasFound = 1; &#125; &#125; return resV;&#125; 2.两数相加123456789101112131415161718192021222324252627ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode *head = nullptr, *tail = nullptr; int carry = 0; while (l1 || l2) &#123; int n1 = l1 ? l1-&gt;val: 0; int n2 = l2 ? l2-&gt;val: 0; int sum = n1 + n2 + carry; if (!head) &#123; head = tail = new ListNode(sum % 10); &#125; else &#123; tail-&gt;next = new ListNode(sum % 10); tail = tail-&gt;next; &#125; carry = sum / 10; if (l1) &#123; l1 = l1-&gt;next; &#125; if (l2) &#123; l2 = l2-&gt;next; &#125; &#125; if (carry &gt; 0) &#123; tail-&gt;next = new ListNode(carry); &#125; return head;&#125; 3. 无重复字符的最长字串1234567891011121314151617181920212223int lengthOfLongestSubstring(string s)&#123; /* 滑动窗口 + set */ unordered_set&lt;char&gt; st; int n = s.size(); int right = 0, ret = 0; for(int left = 0; left &lt; n; left++) &#123; if(left != 0) &#123; /* 每一轮循环首先舍弃窗口左端 */ st.erase(s[left - 1]); &#125; while(right &lt; n &amp;&amp; !st.count(s[right])) &#123; st.insert(s[right]); right++; &#125; /* 这里right - left 不用再加一，因为right从0而不是从-1开始，理解right的意义 */ ret = max(ret, right - left); &#125; return ret;&#125; 15. 三数之和123456789101112131415161718192021222324252627282930/* 排序然后双指针 */vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums)&#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; ret; int n = nums.size(); if(n &gt;= 3 &amp;&amp; nums[n - 1] + nums[n - 2] + nums[n - 3] &lt; 0) /* 剪枝 */ return ret; for(int first = 0; first &lt; n - 2; first++) &#123; if(nums[first] + nums[first + 1] + nums[first + 2] &gt; 0) /* 剪枝 */ break; if(first &gt; 0 &amp;&amp; nums[first] == nums[first - 1]) continue; int target = -nums[first]; int third = n - 1; for(int second = first + 1; second &lt; n - 1; second++) &#123; if(second &gt; first + 1 &amp;&amp; nums[second] == nums[second - 1]) continue; while(second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target) --third; if(second == third) break; if(nums[second] + nums[third] == target) ret.push_back(&#123;nums[first], nums[second], nums[third]&#125;); &#125; &#125; return ret;&#125; 84. 柱状图中的最大矩形12345678910111213141516171819202122int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; int ret = 0; int n = heights.size(); vector&lt;int&gt; left(n), right(n, n); stack&lt;int&gt; monoStack; for(int i = 0; i &lt; n; i++) &#123; while(!monoStack.empty() &amp;&amp; heights[monoStack.top()] &gt;= heights[i]) &#123; right[monoStack.top()] = i; /* 终于遇到比stack中的top对应的柱低的柱了（之前可能是连续的比它高，所以无法确定矩形的宽，遇到比它低的时，就可以确定以它为高的矩形的右边界了）*/ monoStack.pop(); &#125; left[i] = monoStack.empty() ? -1 : monoStack.top(); /* 检索到某下标时就可以确定以它为高的矩形的左边界 */ monoStack.push(i); &#125; for(int i = 0; i &lt; n; i++) &#123; ret = max(ret, (right[i] - left[i] -1) * heights[i]); &#125; return ret;&#125; 85. 最大矩形12345678910111213141516171819202122232425262728293031323334353637383940int largestRectangleArea(vector&lt;int&gt;&amp; heights)&#123; int ret = 0; int n = heights.size(); vector&lt;int&gt; left(n), right(n, n); stack&lt;int&gt; monoStack; for(int i = 0; i &lt; n; i++) &#123; while(!monoStack.empty() &amp;&amp; heights[monoStack.top()] &gt;= heights[i]) &#123; right[monoStack.top()] = i; monoStack.pop(); &#125; left[i] = monoStack.empty() ? -1 : monoStack.top(); monoStack.push(i); &#125; for(int i = 0; i &lt; n; i++) &#123; ret = max(ret, (right[i] - left[i] - 1) * heights[i]); &#125; return ret;&#125;int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; int ret = 0; int m = matrix.size(); if(m == 0) /*要写在n的定义之前，因为matrix[0]不一定存在*/ return 0; int n = matrix[0].size(); vector&lt;int&gt; dp (n, 0); for(int i = 0; i &lt; m; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; dp[j] = matrix[i][j] == '0' ? 0 : dp[j] + 1; /* 这个叠加是根据上一行的dp进行的，比如上方是2，下一行如果为‘1’，相应的柱状图加1的长度变为3（即在原dp数组基础上进行修改）*/ &#125; ret = max(ret, largestRectangleArea(dp)); &#125; return ret;&#125; 114. 二叉树（原地）展开为链表（顺着右子节点连）123456789101112131415161718192021/* 还可以用前序遍历存到数组，再改节点结构；或者（只能用迭代法）同时存到数组并改节点结构，以上两种方法空间复杂度O(n)，下面是第三种方法不用前序遍历，直接改结构，空间复杂度为O(1) */void flatten(TreeNode* root)&#123; TreeNode* cur = root; while(cur) &#123; if(cur-&gt;left) &#123; auto next = cur-&gt;left; auto predecessor = next; while(predecessor-&gt;right) predecessor = predecessor-&gt;right; /* predecessor为当前节点的左子树的最右节点，连到当前节点cur的右子节点 */ predecessor-&gt;right = cur-&gt;right; /* 更新当前节点的左右子节点 */ cur-&gt;left = nullptr; cur-&gt;right = next; &#125; cur = cur-&gt;right; &#125;&#125; 124. 二叉树中的最大路径和12345678910111213141516171819int maxGain(TreeNode* root, int&amp; maxSum)&#123; if(root) /* 空节点的最大贡献值等于0 */ return 0; int left = max(maxGain(root-&gt;left), 0); int right = max(maxGain(root-&gt;right), 0); /* 当前子树中的最大路径和为当前节点值加上两个子节点的最大贡献值 */ int curMaxSum = root-&gt;val + left + right; maxSum = max(maxSum, curMaxSum); /* 非空节点的最大贡献值等于节点值与其子节点中的最大贡献值之和 */ return root-&gt;val + max(left, right);&#125;int maxPathSum(TreeNode* root)&#123; int maxSum = INT_MIN; maxGain(root, maxSum); return maxSum;&#125; 128. （无序数组中能找出的）最长连续序列（需要O(n)时间复杂度）123456789101112131415161718192021222324int longestConsecutive(vector&lt;int&gt;&amp; nums)&#123; /* 怎么也该想到用哈希表存来减少时间复杂度 */ unordered_set&lt;int&gt; st; int longestSeq = 0; for(int num : nums) st.insert(num); for(int s : st) &#123; /* 灵魂的一步剪枝，怎么确定是否检查从某一个数字开始的序列？看set中是否存在num-1，如果存在，则跳过，以此避免查询序列中间的数字 */ if(!st.count(s - 1)) &#123; int curSeq = 1; int curNum = s; while(st.count(curNum + 1)) &#123; curSeq++; curNum++; &#125; longestSeq = max(longestSeq, curSeq); &#125; &#125; return longestSeq;&#125; 139. 单词（是否可以）拆分（成字符串数组中的元素） 4min1234567891011121314151617181920bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict)&#123; unordered_set&lt;string&gt; st; for(string word : wordDict) st.insert(word); vector&lt;bool&gt; dp(s.size() + 1); dp[0] = true; /* 这里的i可以理解为字符串s的前i个字符 */ for(int i = 1; i &lt;= s.size();i++) &#123; for(int j = 0; j &lt; i; j++) /* 字符串的匹配使用的是s的子串和集合中存的string元素比较 */ if(dp[j] &amp;&amp; st.find(s.substr(j, i - j)) != st.end()) &#123; dp[i] = true; break; &#125; &#125; return dp[s.size()];&#125; 160. 相交链表1234567891011121314/* 你走过我走的路，我走过你走的路，我们殊途同归 */ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; if(!headA || !headB) return NULL; ListNode *p, *q, *pp, *qq; p = headA; q = headB; while(p != q) &#123; pp = p; qq = q; p = (!p -&gt; next &amp;&amp; qq -&gt; next) ? headB : p -&gt; next; /* 用pp的作用体现出来了，经过上面的步骤，p可能已经变为p-&gt;next*/ q = (!q -&gt; next &amp;&amp; pp -&gt; next) ? headA : q -&gt; next; &#125; return p;&#125; 739. 每日温度（每天找下一个比今天更高的温度）123456789101112131415161718/* 又是单调栈，相关题目还有84，85 */vector&lt;int&gt; dailyTemperature(vector&lt;int&gt;&amp; T)&#123; int n = T.size(); vector&lt;int&gt; ret(n); stack&lt;int&gt; stk; for(int i = 0; i &lt; n; i++) &#123; while(!stk.empty() &amp;&amp; T[i] &gt; T[stk.top()]) &#123; int prevIndex = stk.top(); ret[prevIndex] = i - prevIndex; stk.pop(); &#125; stk.push(i); &#125; return ret;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/tags/Algorithm/"}]},{"title":"LeetCode200周赛","slug":"LeetCode周赛","date":"2020-08-02T14:18:15.000Z","updated":"2020-12-28T12:39:25.468Z","comments":true,"path":"2020/08/02/LeetCode周赛/","link":"","permalink":"https://chasencenge.github.io/2020/08/02/LeetCode周赛/","excerpt":"给你一个整数数组 arr ，以及 a、b 、c 三个整数。请你统计其中好三元组的数量 如果三元组 (arr[i], arr[j], arr[k]) 满足下列全部条件，则认为它是一个 好三元组 0 &lt;= i &lt; j &lt; k &lt; arr.length |arr[i] - arr[j]| &lt;= a |arr[j] - arr[k]| &lt;= b |arr[i] - arr[k]| &lt;= c 其中 |x| 表示 x 的绝对值 返回 好三元组的数量","text":"给你一个整数数组 arr ，以及 a、b 、c 三个整数。请你统计其中好三元组的数量 如果三元组 (arr[i], arr[j], arr[k]) 满足下列全部条件，则认为它是一个 好三元组 0 &lt;= i &lt; j &lt; k &lt; arr.length |arr[i] - arr[j]| &lt;= a |arr[j] - arr[k]| &lt;= b |arr[i] - arr[k]| &lt;= c 其中 |x| 表示 x 的绝对值 返回 好三元组的数量 1234567输入：arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3输出：4解释：一共有 4 个好三元组：[(3,0,1), (3,0,1), (3,1,1), (0,1,1)]输入：arr = [1,1,2,2,3], a = 0, b = 0, c = 1输出：0解释：不存在满足所有条件的三元组 123456789101112131415161718int countGoodTriplets(vector&lt;int&gt;&amp; arr, int a, int b, int c) &#123; int res = 0; for (int i = 0; i &lt; arr.size() - 2; i++) &#123; for (int j = i + 1; j &lt; arr.size() - 1; j++) &#123; for (int k = j + 1; k &lt; arr.size(); k++) &#123; //使用abs()需引用cmath头文件 if (abs(arr[i] - arr[j]) &lt;= a &amp;&amp; abs(arr[j] - arr[k]) &lt;= b &amp;&amp; abs(arr[i] - arr[k]) &lt;= c) &#123; res++; &#125; &#125; &#125; &#125; return res;&#125; 给你一个由 不同 整数组成的整数数组 arr 和一个整数 k 每回合游戏都在数组的前两个元素（即 arr[0] 和 arr[1] ）之间进行。比较 arr[0] 与 arr[1] 的大小，较大的整数将会取得这一回合的胜利并保留在位置 0 ，较小的整数移至数组的末尾。当一个整数赢得 k 个连续回合时，游戏结束，该整数就是比赛的 赢家 返回赢得比赛的整数 题目数据 保证 游戏存在赢家 123456789输入：arr = [3,2,1], k = 10输出：3解释：3 将会在前 10 个回合中连续获胜 输入：arr = [1,9,8,2,3,7,6,4,5], k = 7输出：9 输入：arr = [1,11,22,33,44,55,66,77,88,99], k = 1000000000输出：99 123456//vector操作a.erase(a.begin()+1,a.begin()+3); //包前不包后，删除第1、2个元素a.insert(a.begin()+1,5); //在a的第1个元素（从第0个算起）的位置插入数值5a.insert(a.begin()+1,3,5); //在a的第1个元素（从第0个算起）的位置插入3个数，其值都为5a.back(); //返回a的最后一个元素a.front(); //返回a的第一个元素 123456789101112131415161718192021222324252627282930//按命题逻辑操作vector，遇到超长数组同时超大K值时会超时int getWinner(vector&lt;int&gt;&amp; arr, int k) &#123; int num = 0; int res = arr[0]; if (k &gt; arr.size()) &#123; k = arr.size(); &#125; while (num &lt; k) &#123; if (arr[0] &gt; arr[1]) &#123; num++; int temp = arr[1]; arr.erase(arr.begin() + 1, arr.begin() + 2); arr.push_back(temp); &#125; else &#123; num = 1; int temp = arr[0]; res = arr[1]; arr.erase(arr.begin(), arr.begin() + 1); arr.push_back(temp); &#125; &#125; return res;&#125; 123456789101112131415161718192021222324252627282930//trick，不用按题述方式操作vector，从前向后遍历即可int getWinner(vector&lt;int&gt;&amp; arr, int k) &#123; int num = 0; int res = arr[0]; if (k &gt; arr.size()) &#123; k = arr.size(); &#125; for(int i = 0; i &lt; arr.size(); i++) &#123; if(arr[i]&gt;arr[i+1]) &#123; //直接修改arr[i+1]的值为arr[i]，这样继续和后面比较时仍是类似命题中的：上一组的较大者和新数值比较 arr[i+1] = arr[i]; num++; &#125; else &#123; //当遇到前者小于后者的情况，看此时的num值是否满足大于等于k的要求，符合即作为结果返回 if(num &gt;= k) &#123; return arr[i]; &#125; //不符合则设置num为1，不设置为0的原因是因为已经淘汰掉上一个值，已经赢了一回合 res = arr[i+1]; num = 1; &#125; &#125; return res; &#125; 给你一个 n x n 的二进制网格 grid，每一次操作中，你可以选择网格的 相邻两行 进行交换 一个符合要求的网格需要满足主对角线以上的格子全部都是 0 请你返回使网格满足要求的最少操作次数，如果无法使网格符合要求，请你返回 -1 主对角线指的是从 (1, 1) 到 (n, n) 的这些格子 123456789输入：grid = [[0,0,1],[1,1,0],[1,0,0]]输出：3输入：grid = [[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,1,1,0]]输出：-1解释：所有行都是一样的，交换相邻行无法使网格符合要求输入：grid = [[1,0,0],[1,1,0],[1,1,1]]输出：0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//贪心//从第一行开始，如果该行的后缀0满足条件，那么直接跳过进入下一行（因为需要的后缀0个数是从大到小的顺序（理解这一点非常重要），所以不必担心前面的会抢后面的，自己不够用的时候放心的去抢后面的，因为当前行的需求（优先级）比后面都高）//如果该行后缀0个数不满足条件，那么就往下遍历找到最先（贪心，这是最小次数）满足条件的行，一行一行换上来，记录交换的次数int minSwaps(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; vector&lt;int&gt; resV; int res = 0; int n = grid.size(); //统计每行后缀0个数，存到resV中 for (int i = 0; i &lt; n; i++) &#123; int num = 0; for (int j = 0; j &lt; grid[i].size(); j++) &#123; if (grid[i][j] == 0) &#123; num++; &#125; else &#123; num = 0; &#125; &#125; resV.push_back(num); &#125; for(int i = 0; i &lt; n - 1; i++) &#123; //如果当前行的后缀0个数够用，直接往下遍历，不用担心抢了后面的，因为当前行的需求量比后面的都高 if(resV[i] &gt;= n - i - 1) continue; else &#123; int j = i + 1; while(resV[j] &lt; n - i - 1 ) &#123; j++; //找到最后都没有找到满足个数的后缀0，就直接退出 if(j == n) return -1; &#125; //while之后到这里说明找到了一行满足当前行的后缀0的个数需求，把找到的行一行一行的往上换，换到当前行，每次swap的同时更新交换次数 for(int m = j; m &gt; i; m--) &#123; swap(resV[m], resV[m - 1]); res++; &#125; &#125; &#125; return res;&#125; 5484. 找出第 N 个二进制字符串中的第 K 位12345678910输入：n = 3, k = 1输出：&quot;0&quot;解释：S3 为 &quot;0111001&quot;，其第 1 位为 &quot;0&quot; 输入：n = 4, k = 11输出：&quot;1&quot;解释：S4 为 &quot;011100110110001&quot;，其第 11 位为 &quot;1&quot;输入：n = 1, k = 1输出：&quot;0&quot; 12345678910111213141516private:// invert处理 char ch_not(char ch) &#123; if(ch == '0') &#123; return '1'; &#125; else &#123; return '0'; &#125; &#125;public: char findKthBit(int n, int k) &#123; if(n == 1) &#123; return '0'; &#125; // 1左移n-1位，pow(2, n-1) int mid = (1&lt;&lt;(n-1)); if(k == mid) &#123; return '1'; &#125; if(k &lt; mid) &#123; return findKthBit(n-1, k); &#125; // k &gt; mid的情况需要把k挪到对称位置：(1&lt;&lt;n) - k，并进行invert return ch_not(findKthBit(n-1, (1&lt;&lt;n) - k)); &#125; 5483. 整理字符串123456789101112输入：s = &quot;leEeetcode&quot;输出：&quot;leetcode&quot;解释：无论你第一次选的是 i = 1 还是 i = 2，都会使 &quot;leEeetcode&quot; 缩减为 &quot;leetcode&quot;输入：s = &quot;abBAcC&quot;输出：&quot;&quot;解释：存在多种不同情况，但所有的情况都会导致相同的结果。例如：&quot;abBAcC&quot; --&gt; &quot;aAcC&quot; --&gt; &quot;cC&quot; --&gt; &quot;&quot;&quot;abBAcC&quot; --&gt; &quot;abBA&quot; --&gt; &quot;aA&quot; --&gt; &quot;&quot;输入：s = &quot;s&quot;输出：&quot;s&quot; 1234567891011121314151617181920string makeGood(string s) &#123;int i = 0;while (i != s.length() - 1)&#123; for (i = 0; i &lt; s.length() - 1; i++) &#123; if (abs(s[i] - s[i + 1]) == 32) &#123; s.erase(i, 2); i = 0; break; &#125; &#125; if(s.empty()) &#123; return \"\"; &#125;&#125;return s;&#125; 1234567891011121314151617181920212223//William Lin版string makeGood(string s)&#123; bool ch = 1; while(ch) &#123; ch = 0; string t = s; //size()返回类型是size_t, (unsigned) 和后面的int相减可能会溢出 for(int i = 0; i &lt; (int)s.size() - 1; i++) &#123; if(s[i] + 32 == s[i + 1] || s[i + 1] + 32 == s[i]) &#123; //string的substr()使用，带首不带尾，单个参数默认从参数位置取到末尾 t = s.substr(0, i) + s.substr(i + 2); ch = 1; break; &#125; &#125; s = t; &#125; return s;&#125; 5468. 第 k 个缺失的正整数1234567输入：arr = [2,3,4,7,11], k = 5输出：9解释：缺失的正整数包括 [1,5,6,8,9,10,12,13,...]输入：arr = [1,2,3,4], k = 2输出：6解释：缺失的正整数包括 [5,6,7,...] 1234567891011121314151617181920212223242526272829int findKthPositive(vector&lt;int&gt;&amp; arr, int k) &#123; int init = 0; int res = 0; int resNum = 0; res = arr[0] - init -1; if(res &gt;= k) &#123; return k; &#125; int i = 1; while(i &lt; arr.size() &amp;&amp; res &lt; k) &#123; if(res + arr[i] - arr[i-1] - 1 &lt; k) &#123; res += arr[i] - arr[i-1] - 1; &#125; else &#123; resNum = arr[i-1] + (k - res); res = k; &#125; i++; &#125; if(i == arr.size() &amp;&amp; res &lt; k) &#123; resNum = arr.back() + (k - res); &#125; return resNum;&#125; 5469. K 次操作转变字符串1234567891011输入：s = &quot;input&quot;, t = &quot;ouput&quot;, k = 9输出：true解释：第 6 次操作时，我们将 &apos;i&apos; 切换 6 次得到 &apos;o&apos; 。第 7 次操作时，我们将 &apos;n&apos; 切换 7 次得到 &apos;u&apos;输入：s = &quot;abc&quot;, t = &quot;bcd&quot;, k = 10输出：false解释：我们需要将每个字符切换 1 次才能得到 t 。我们可以在第 1 次操作时将 &apos;a&apos; 切换成 &apos;b&apos; ，但另外 2 个字母在剩余操作中无法再转变为 t 中对应字母输入：s = &quot;aab&quot;, t = &quot;bbb&quot;, k = 27输出：true解释：第 1 次操作时，我们将第一个 &apos;a&apos; 切换 1 次得到 &apos;b&apos; 。在第 27 次操作时，我们将第二个字母 &apos;a&apos; 切换 27 次得到 &apos;b&apos; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//结果出现的位置有数组首之前，数组中间，数组末尾之后，分别处理//创建一个数组存储每一位需要的操作数，将操作数按大小排好，一次遍历去对应k值看是否满足要求//addNum记录某个操作数出现的次数，比如6在某一位上出现一次，某另一位的操作数也是6，那么操作数只能选择6 + 26，第三次出现时操作数为6 + 26 * 2bool canConvertString(string s, string t, int k) &#123; if (s.length() != t.length()) &#123; return false; &#125; vector&lt;int&gt; resV; int temp = 0; vector&lt;int&gt; addNum(26, 0); for (int i = 0; i &lt; s.length(); i++) &#123; if (t[i] - s[i] &gt;= 0) &#123; temp = t[i] - s[i]; addNum[temp] += 1; &#125; else &#123; temp = t[i] - 'a' + 'z' - s[i] + 1; addNum[temp] += 1; &#125; //操作数为0是可以重复的，不需要加重叠次数*26 if (temp != 0) &#123; int pushNum = temp + 26 * (addNum[temp] - 1); resV.push_back(pushNum); &#125; else &#123; resV.push_back(temp); &#125; &#125; sort(resV.begin(), resV.end()); while (!resV.empty() &amp;&amp; resV.back() != 0) &#123; if (k &gt; resV.back()) &#123; k = resV.back() - 1; resV.pop_back(); &#125; else if (k == resV.back()) &#123; resV.pop_back(); k--; &#125; else &#123; return false; &#125; &#125; return true; &#125; 1546. 和为目标值的最大数目不重叠非空子数组数目1234567891011121314输入：nums = [1,1,1,1,1], target = 2输出：2解释：总共有 2 个不重叠子数组（加粗数字表示） [1,1,1,1,1] ，它们的和为目标值 2 输入：nums = [-1,3,5,1,4,2,-9], target = 6输出：2解释：总共有 3 个子数组和为 6 。([5,1], [4,2], [3,5,1,4,2,-9]) 但只有前 2 个是不重叠的输入：nums = [-2,6,6,3,5,4,1,2,8], target = 10输出：3输入：nums = [0,0,0], target = 0输出：3 12345678910111213141516171819202122// 贪心int maxNonOverlapping(vector&lt;int&gt;&amp; nums, int target)&#123; set&lt;int&gt; s; //初始时累计值为0，保证在&#123;-1, 3, 5, 1&#125;中找target=6时能找去掉-1, 3，找到&#123;5, 1&#125; s.insert(0); int ps = 0, ans = 0; //一个替代遍历vector中每个值的方法（不关注下标时可使用） for(int a : nums) &#123; //记录到每个当前值的累计值，其中的两个值相减就是两者之间的子数组中的各个值和 ps += a; //注意理解ps - target的含义，是在当前位置根据target找前面是否有能截断而得到要的子数组的位置 if(s.find(ps - target != s.end())) &#123; ++ans; s.clear(); &#125; s.insert(ps); &#125; return ans;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/tags/Algorithm/"}]},{"title":"LeetCode广度优先搜索","slug":"bfs专题","date":"2020-08-01T10:13:29.000Z","updated":"2020-12-28T12:31:12.659Z","comments":true,"path":"2020/08/01/bfs专题/","link":"","permalink":"https://chasencenge.github.io/2020/08/01/bfs专题/","excerpt":"107. 二叉树的层次遍历给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） STL queue：原理：队尾（rear）插入，队首（front）删除","text":"107. 二叉树的层次遍历给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） STL queue：原理：队尾（rear）插入，队首（front）删除 头文件： 1#include&lt;queue&gt; 方法： 123456push(): 推一个元素进队列front(): 返回队首元素(栈对应的是top())back(): 返回队尾元素pop(): 移除队首元素empty()size() 创建： 1queue&lt;string&gt; q; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; resV; vector&lt;int&gt; levelNumV; TreeNode* cur = root; //层次遍历借助队列实现 queue&lt;TreeNode*&gt; q; q.push(cur); //跳出遍历的条件为队列为空 while(!q.empty()) &#123; int size = q.size(); while(size-- &gt; 0) &#123; cur = q.front(); //砍头操作 q.pop(); if(cur) &#123; levelNumV.push_back(cur-&gt;val); //爆菊操作 q.push(cur-&gt;left); q.push(cur-&gt;right); &#125; &#125; if(!levelNumV.empty()) &#123; //输出格式不是规则的二维数组可选用vector&lt;vector&gt;，它的push_back内容为vector（不限制子vector长度） resV.push_back(levelNumV); levelNumV.clear(); &#125; &#125; //vector中reverse的使用 reverse(resV.begin(), resV.end()); return resV; &#125;&#125;; 207. 课程表你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1] 给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？ 1234567输入: 2, [[1,0]] 输出: true解释: 总共有2门课程。学习课程1之前，你需要完成课程0。所以这是可能的输入: 2, [[1,0],[0,1]]输出: false解释: 总共有2门课程。学习课程1之前，你需要先完成课程0；并且学习课程0之前，你还应先完成课程1。这是不可能的 我们就可以将本题建模成一个求拓扑排序的问题了： 我们将每一门课看成一个节点 如果想要学习课程 A之前必须完成课程 B，那么我们从B到A连接一条有向边。这样以来，在拓扑排序中，B一定出现在 A的前面 思路： 考虑拓扑排序中最前面的节点，该节点一定不会有任何入边，也就是它没有任何的先修课程要求。当我们将一个节点加入答案中后，我们就可以移除它的所有出边，代表着它的相邻节点少了一门先修课程的要求。如果某个相邻节点变成了「没有任何入边的节点」，那么就代表着这门课可以开始学习了。按照这样的流程，我们不断地将没有入边的节点加入答案，直到答案中包含所有的节点（得到了一种拓扑排序）或者不存在没有入边的节点（图中包含环） 算法： 使用一个队列来进行广度优先搜索。初始时，所有入度为 00 的节点都被放入队列中，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。 在广度优先搜索的每一步中，我们取出队首的节点u： 我们将u放入答案中 我们移除 u的所有出边，也就是将u的所有相邻节点的入度减少1。如果某个相邻节点v的入度变为0，那么我们就将v放入队列中 在广度优先搜索的过程结束后。如果答案中包含了这n个节点，那么我们就找到了一种拓扑排序，否则说明图中存在环，也就不存在拓扑排序了 1234567891011121314151617181920212223242526272829303132333435363738394041bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123; //入度 in degree vector&lt;int&gt; indeg; vector&lt;vector&lt;int&gt;&gt; edges; //resize内的默认初始化值为0 indeg.resize(numCourses); edges.resize(numCourses); for (const auto&amp; info : prerequisites) &#123; //以info[1]为起始的边，指向info[0] edges[info[1]].push_back(info[0]); //info[0]的入度加一，指向它的是info[1] ++indeg[info[0]]; &#125; queue&lt;int&gt; q; for (int i = 0; i &lt; numCourses; i++) &#123; //把最开始入度为0的点push进去 if (indeg[i] == 0) &#123; q.push(i); &#125; &#125; int visited = 0; while (!q.empty()) &#123; visited++; int u = q.front(); q.pop(); for (int v : edges[u]) &#123; --indeg[v]; //如果去掉指向它的u之后，v点的入度变为0，那么push进队列 if (indeg[v] == 0) &#123; q.push(v); &#125; &#125; &#125; return visited == numCourses;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/tags/Algorithm/"}]},{"title":"字节夏令营20游戏程序笔试题","slug":"字节夏令营20游戏程序笔试题","date":"2020-08-01T03:42:48.000Z","updated":"2020-12-28T12:29:33.331Z","comments":true,"path":"2020/08/01/字节夏令营20游戏程序笔试题/","link":"","permalink":"https://chasencenge.github.io/2020/08/01/字节夏令营20游戏程序笔试题/","excerpt":"给素材分类，若作品1中有素材1和素材2，则认为素材1和素材2为一类，若作品2中有素材2和素材3，那么此后认为素材1、2、3为一类 输入：第一行为作品数n，此后n行中每行第一位为该作品中的素材总数m，此后m个数字为素材名（int型） 输出：素材的分类，并且每一类素材，类内顺序由小到大，类外顺序按照类内最小值由小到大排序输出","text":"给素材分类，若作品1中有素材1和素材2，则认为素材1和素材2为一类，若作品2中有素材2和素材3，那么此后认为素材1、2、3为一类 输入：第一行为作品数n，此后n行中每行第一位为该作品中的素材总数m，此后m个数字为素材名（int型） 输出：素材的分类，并且每一类素材，类内顺序由小到大，类外顺序按照类内最小值由小到大排序输出 示例： 1234567891011输入：42 1 33 0 5 63 2 3 41 7输出：0 5 61 2 3 47 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;int main()&#123; vector&lt;vector&lt;int&gt;&gt; resV; int num; cin &gt;&gt; num; for (int i = 0; i &lt; num; i++) &#123; int cat; cin &gt;&gt; cat; //存放该作品内所有素材的vector vector&lt;int&gt; tempV; for (int j = 0; j &lt; cat; j++) &#123; int mem; cin &gt;&gt; mem; tempV.push_back(mem); //cout &lt;&lt; tempV[j]; &#125; //能否找到已存在的类，能找到就将tempV添加进去 int label = 0; for (int k = 0; k &lt; tempV.size(); k++) &#123; for (int out = 0; out &lt; resV.size(); out++) &#123; int flag = 0; for (int in = 0; in &lt; resV[out].size(); in++) &#123; if (tempV[k] == resV[out][in]) &#123; label = 1; flag = 1; for (int copy = 0; copy &lt; tempV.size(); copy++) &#123; //检查重复素材，重复的素材不添加，只在已有的分类中添加还未加入的素材 if (find(resV[out].begin(), resV[out].end(), tempV[copy]) == resV[out].end()) resV[out].push_back(tempV[copy]); &#125; break; &#125; &#125; //不用再继续遍历后面的子vector了，添加进一个分类中就一定不会添加进另外一个分类 if (flag == 1) break; &#125; &#125; //是新的素材分类 if (label == 0) &#123; resV.push_back(tempV); &#125; &#125; //子vector按最小元素排序 sort(resV.begin(), resV.end()); for (int i = 0; i &lt; resV.size(); i++) &#123; //子vector内部排序 sort(resV[i].begin(), resV[i].end()); for (int j = 0; j &lt; resV[i].size(); j++) cout &lt;&lt; resV[i][j] &lt;&lt; \" \"; cout &lt;&lt; endl; &#125; return 0;&#125; 计算给出时间和格林尼治时间之间的秒数，格式：YYYY/MM/DD hh:mm:ss 需要考虑平年和闰年 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;int main()&#123; string date, time; cin &gt;&gt; date &gt;&gt; time; long long int year, month, day; //切分成子字符串之后再转整型，赋给年月日时分秒 //atoi()的参数是 const char* ,因此对于一个字符串str我们必须调用c_str()的方法把这个string转换成const char*类型的 //substr(pos, num)两个参数是从起始位置和pos开始取的字符个数，而不是起始位置和末尾位置 year = atoi(date.substr(0, 4).c_str()); month = atoi(date.substr(5, 2).c_str()); day = atoi(date.substr(8, 2).c_str()); long long int hour, minute, second; hour = atoi(time.substr(0, 2).c_str()); minute = atoi(time.substr(3, 2).c_str()); second = atoi(time.substr(6, 2).c_str()); long long int time1 = 0; //cout &lt;&lt; hour &lt;&lt; \" \" &lt;&lt; minute &lt;&lt; \" \" &lt;&lt; second; cout &lt;&lt; year &lt;&lt; \" \" &lt;&lt; month &lt;&lt; \" \" &lt;&lt; day &lt;&lt; endl; //cout &lt;&lt; second &lt;&lt; to_string(minute * 60) &lt;&lt; to_string(hour * 3600) &lt;&lt; second + minute * 60 + hour * 3600; //给出的一天内的时间计算 time1 = second + minute * 60 + hour * 3600; long long int time2 = 0; long long int run = 0; for (int i = 1970; i &lt; year; i++) &#123; if ((i % 4 == 0 &amp;&amp; i % 100 != 0) || i % 400 == 0) run++; &#125; cout &lt;&lt; run &lt;&lt; endl; //给出的年月日的时间计算 time2 += run * 366 * 3600 * 24 + (year - 1970 - run) * 365 * 3600 * 24; cout &lt;&lt; time2 &lt;&lt; endl; long long int temp = 0; //最后一年单独计算，因为最后一年未满整一年 //最后一年是闰年还是平年 if ((year % 4 == 0 &amp;&amp; year % 100 != 0) || year % 400 == 0) temp = 29; else temp = 28; //最后一年除掉最后一个月的时间，因为最后一个月未满整一个月 switch (month) &#123; case 01: time2 += 0; break; case 02: time2 += 31 * 3600 * 24; break; case 03: time2 += (31 + temp) * 3600 * 24; break; case 04: time2 += (62 + temp) * 3600 * 24; break; case 05: time2 += (92 + temp) * 3600 * 24; break; case 06: time2 += (123 + temp) * 3600 * 24; break; case 07: time2 += (153 + temp) * 3600 * 24; break; //8和9特殊，编译器在识别08和09时不会自动转换成8和9，而是提示错误的八进制数 case 8: time2 += (184 + temp) * 3600 * 24; break; case 9: time2 += (215 + temp) * 3600 * 24; break; case 10: time2 += (245 + temp) * 3600 * 24; break; case 11: time2 += (276 + temp) * 3600 * 24; break; case 12: time2 += (306 + temp) * 3600 * 24; break; &#125; //cout &lt;&lt; time2 &lt;&lt; endl; time2 += (day - 1) * 24 * 3600; //整的年月日的时间计算加上最后一日内的时分秒时间计算 long long int res = time1 + time2; cout &lt;&lt; res &lt;&lt; endl; return 0; //1970/02/01 00:00:00 //2716/02/02 00:00:00&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/tags/Algorithm/"}]},{"title":"网易20秋招Unity工程师笔试编程题","slug":"网易20秋招Unity工程师笔试编程题","date":"2020-07-31T14:25:33.000Z","updated":"2020-12-28T12:29:40.607Z","comments":true,"path":"2020/07/31/网易20秋招Unity工程师笔试编程题/","link":"","permalink":"https://chasencenge.github.io/2020/07/31/网易20秋招Unity工程师笔试编程题/","excerpt":"定义S(n)，表示n在十进制下的各位数字和。 现在给定一个x,请你求出最小正整数n，满足x&lt;=S(n)。","text":"定义S(n)，表示n在十进制下的各位数字和。 现在给定一个x,请你求出最小正整数n，满足x&lt;=S(n)。 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;string&gt;int main()&#123; int num; cin &gt;&gt; num; vector&lt;string&gt; resV; string a = \"9\"; for (int n = 0; n &lt; num; n++) &#123; int x; cin &gt;&gt; x; //long long int multi = 1; string res; while (x &gt; 9) &#123; x -= 9; res = a + res; //multi *= 10; &#125; if (x != 0) &#123; //res += multi * x; res = to_string(x) + res; &#125; resV.push_back(res); &#125; for (int n = 0; n &lt; num; n++) &#123; cout &lt;&lt; resV[n] &lt;&lt; endl; &#125; return 0;&#125; 小易给定你数字A, B (A &lt; B)和系数p, q。每次操作你可以将A变成A + p或者将p变成p * q。问至少几次操作使得B &lt;= A。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;string&gt;int main()&#123; int num; cin &gt;&gt; num; vector&lt;long long int&gt; resV; for (int n = 0; n &lt; num; n++) &#123; long long int a; long long int b; long long int p; long long int q; cin &gt;&gt; a &gt;&gt; b &gt;&gt; p &gt;&gt; q; long long int res = 0; if (b - a &gt; p) &#123; long long int temp = b - a; long long int multiNum = p; while (temp &gt; multiNum) &#123; multiNum *= q; res++; &#125; res++; &#125; else &#123; res++; &#125; resV.push_back(res); &#125; for (int n = 0; n &lt; num; n++) &#123; cout &lt;&lt; resV[n] &lt;&lt; endl; &#125; return 0;&#125; 小易定义一个数字序列是完美的，当且仅当对于任意2 &lt;= i &lt;= n，都满足，即每个数字都要大于等于前面所有数字的和。现在给定数字序列Ai，小易想请你从中找出最长的一段连续子序列，满足它是完美的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;string&gt;int main()&#123; vector&lt;int&gt; resV; int num; cin &gt;&gt; num; for (int i = 0; i &lt; num; i++) &#123; int tempLength = 1; int maxLength = 0; vector&lt;int&gt; n; int serialNum; cin &gt;&gt; serialNum; for (int j = 0; j &lt; serialNum; j++) &#123; int data; cin &gt;&gt; data; n.push_back(data); &#125; int compute = n[0]; for (int k = 1; k &lt; serialNum; k++) &#123; if (n[k] &gt;= compute) &#123; compute += n[k]; tempLength++; &#125; else &#123; maxLength = max(maxLength, tempLength); tempLength = 1; compute = n[k]; &#125; &#125; resV.push_back(maxLength); &#125; for (int i = 0; i &lt; num; i++) &#123; cout &lt;&lt; resV[i] &lt;&lt; endl; &#125; return 0;&#125; 小易的公司一共有n名员工, 第i个人每个月的薪酬是xi万元。现在小易的老板向小易提了m次询问, 每次询问老板都会给出一个整数k, 小易要快速回答老板工资等于k的员工的数量。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;unordered_map&gt;using namespace std;int main()&#123; int people, question; cin &gt;&gt; people &gt;&gt; question; vector&lt;int&gt; resV(question, 0); vector&lt;int&gt; salaryV; vector&lt;int&gt; questionV; unordered_map&lt;string, size_t&gt; questionMap; for (int i = 0; i &lt; people; i++) &#123; int salary; cin &gt;&gt; salary; salaryV.push_back(salary); &#125; for (int i = 0; i &lt; question; i++) &#123; int data; cin &gt;&gt; data; questionV.push_back(data); questionMap[to_string(data)]; &#125; for (int i = 0; i &lt; people; i++) &#123; if (questionMap.find(to_string(salaryV[i])) != questionMap.end()) &#123; ++questionMap[to_string(salaryV[i])]; &#125; &#125; for (int i = 0; i &lt; question; i++) &#123; cout &lt;&lt; questionMap.find(to_string(questionV[i]))-&gt;second &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/tags/Algorithm/"}]},{"title":"Pyplot绘图","slug":"Pyplot绘图","date":"2020-07-27T12:56:31.000Z","updated":"2020-12-28T12:31:38.193Z","comments":true,"path":"2020/07/27/Pyplot绘图/","link":"","permalink":"https://chasencenge.github.io/2020/07/27/Pyplot绘图/","excerpt":"标识散点：plt.scatter(x, y)可选项s修改散点大小，color修改颜色 1plt.scatter(thisNodeLoc[0], thisNodeLoc[1], s=10, color='b')","text":"标识散点：plt.scatter(x, y)可选项s修改散点大小，color修改颜色 1plt.scatter(thisNodeLoc[0], thisNodeLoc[1], s=10, color='b') 连线：plt.plot([x1, y1], [x2, y2])1plt.plot([thisNodeLoc[0], sendToNodeLoc[0]], [thisNodeLoc[1], sendToNodeLoc[1]]) 注释文字：plt.annotate(txt, xy=(), xytext=())xy处填注释点坐标，xytext处填文本位置，可加偏移offset 1plt.annotate(thisNodeLoc, xy=(thisNodeLoc[0], thisNodeLoc[1]), xytext=(thisNodeLoc[0]+1, thisNodeLoc[1]+1)) 限制坐标区间：12plt.xlim(-2200,2200)plt.ylim(-2200,2200) 12345678910for n in range(0, nodeNum): thisNodeLoc = [nodes[n].locX, nodes[n].locY] sendToNodeLoc = [nodes[n].sendTo.locX, nodes[n].sendTo.locY] plt.scatter(thisNodeLoc[0], thisNodeLoc[1], s=10, color='b') plt.plot([thisNodeLoc[0], sendToNodeLoc[0]], [thisNodeLoc[1], sendToNodeLoc[1]]) plt.annotate(thisNodeLoc, xy=(thisNodeLoc[0], thisNodeLoc[1]), xytext=(thisNodeLoc[0]+1, thisNodeLoc[1]+1))plt.xlim(-2200,2200)plt.ylim(-2200,2200)plt.show() 最后记得用plt.show()将其显示出来","categories":[{"name":"Python","slug":"Python","permalink":"https://chasencenge.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://chasencenge.github.io/tags/Python/"}]},{"title":"百度之星2020---1003.Permutation","slug":"百度之星2020-1003-Permutation","date":"2020-07-26T10:04:53.000Z","updated":"2020-12-28T12:31:02.192Z","comments":true,"path":"2020/07/26/百度之星2020-1003-Permutation/","link":"","permalink":"https://chasencenge.github.io/2020/07/26/百度之星2020-1003-Permutation/","excerpt":"Problem Description 一开始有 n个数，他们按 1…n的顺序排列，要求交换最多 m对数字（同一个数字可以参与多次交换），使得逆序对数目最大。 对于一个序列 A，如果存在正整数 i, j使得1≤i&lt;j≤n 而且 A[i] &gt; A[j]，则 &lt;A[i],A[j]&gt; 这个有序对称为 A的一个逆序对。 Input 第一行一个正整数test (1≤test≤100000) 表示数据组数。 对于每组数据，一行两个整数 n，m (1≤n≤1000000,0≤m≤1000000) 表示数字个数和最多可以交换的数字对数。","text":"Problem Description 一开始有 n个数，他们按 1…n的顺序排列，要求交换最多 m对数字（同一个数字可以参与多次交换），使得逆序对数目最大。 对于一个序列 A，如果存在正整数 i, j使得1≤i&lt;j≤n 而且 A[i] &gt; A[j]，则 &lt;A[i],A[j]&gt; 这个有序对称为 A的一个逆序对。 Input 第一行一个正整数test (1≤test≤100000) 表示数据组数。 对于每组数据，一行两个整数 n，m (1≤n≤1000000,0≤m≤1000000) 表示数字个数和最多可以交换的数字对数。 Output 对于每组数据，一行一个整数表示答案。 Sample Input 123456761 12 02 13 14 14 2 Sample Output 123456001356 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;// 对每个（n, 1）结果都为：2 * n - 3int com(int n)&#123; int com = 2 * n - 3; return com;&#125;// 把（n, m）转换为（n, 1）, (n -2, 1)...(n - 2m + 2, 1)之和的形式并利用com()计算结果int arr(int n, int m)&#123; int res = 0; for (int i = 0; i &lt; m; i++) &#123; res += com(n - 2 * i); //cout &lt;&lt; i &lt;&lt;\" \"&lt;&lt; res&lt;&lt;endl; &#125; return res;&#125;vector&lt;int&gt; compute() &#123; int groupNum; cin &gt;&gt; groupNum; vector&lt;int&gt; output; for (int i = 0; i &lt; groupNum; i++) &#123; int n; int m; //cout &lt;&lt; \"choiseNum:\" &lt;&lt; choiseNum &lt;&lt; endl; cin &gt;&gt; n; //cout &lt;&lt; \"b:\" &lt;&lt; b &lt;&lt; endl; cin &gt;&gt; m; //cout &lt;&lt; \"c:\" &lt;&lt; c &lt;&lt; endl; if (n == 1 || m == 0) &#123; output.push_back(0); &#125; else &#123; if (2 * m &lt; n) &#123; int res = arr(n, m); output.push_back(res); &#125; else &#123; m = n / 2; int res = arr(n, m); output.push_back(res); &#125; &#125; &#125; return output; &#125;int main()&#123; vector&lt;int&gt; res = compute(); for (int i = 0; i &lt; res.size(); i++) &#123; //cout &lt;&lt; res[i]; printf(\"%d\\n\", res[i]); &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/tags/Algorithm/"}]},{"title":"百度之星2020---1002.Game","slug":"百度之星2020-1002-Game","date":"2020-07-26T10:04:18.000Z","updated":"2020-12-28T12:30:58.866Z","comments":true,"path":"2020/07/26/百度之星2020-1002-Game/","link":"","permalink":"https://chasencenge.github.io/2020/07/26/百度之星2020-1002-Game/","excerpt":"Problem Description Alice 和 Bob 在玩游戏。 桌面上有两堆金币，少的那堆有 x 个金币，多的那堆有 2x 个金币。 假设金币可以被无限细分。Alice 和 Bob 事先都不知道 x是几，但是他们都知道 x是一个 (0, 1]之间均匀分布的随机实数。 Alice 会等概率的被分配到其中的一堆金币，Bob 会得到另一堆。x的值和两堆金币的分配是相互独立的。 拿到金币以后，Alice 会马上数清自己拿到多少金币。然后 Alice 可以选择是否和 Bob 那堆换。 给定 Alice 拿到的金币数目，请问 Alice 要不要交换，使得她期望能得到的金币数目更多？ 如果交换期望得到的金币数目多于不交换期望得到的金币数目，输出交换，否则不交换。 Input 第一行一个正整数test (1≤test≤200000) 表示数据组数。 接下来每行一个小数p(0&lt;p≤2)，p最多保留五位小数，表示 Alice 拿到的金币数目。","text":"Problem Description Alice 和 Bob 在玩游戏。 桌面上有两堆金币，少的那堆有 x 个金币，多的那堆有 2x 个金币。 假设金币可以被无限细分。Alice 和 Bob 事先都不知道 x是几，但是他们都知道 x是一个 (0, 1]之间均匀分布的随机实数。 Alice 会等概率的被分配到其中的一堆金币，Bob 会得到另一堆。x的值和两堆金币的分配是相互独立的。 拿到金币以后，Alice 会马上数清自己拿到多少金币。然后 Alice 可以选择是否和 Bob 那堆换。 给定 Alice 拿到的金币数目，请问 Alice 要不要交换，使得她期望能得到的金币数目更多？ 如果交换期望得到的金币数目多于不交换期望得到的金币数目，输出交换，否则不交换。 Input 第一行一个正整数test (1≤test≤200000) 表示数据组数。 接下来每行一个小数p(0&lt;p≤2)，p最多保留五位小数，表示 Alice 拿到的金币数目。 Output 对于每组数据，输出 Yes 表示需要交换，输出 No 表示不要交换。 Sample Input 1211.00000 Sample Output 1Yes 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include &lt;string&gt;using namespace std;vector&lt;string&gt; compute()&#123; int groupNum; std::cin &gt;&gt; groupNum; vector&lt;string&gt; output; for (int i = 0; i &lt; groupNum; i++) &#123; float num; std::cin &gt;&gt; num; //float exception; if (num &gt; 1) &#123; output.push_back(\"No\"); &#125; else &#123; if (2 * num * 0.5 + num / 2 * 0.5 &gt; num) &#123; output.push_back(\"Yes\"); &#125; else &#123; output.push_back(\"No\"); &#125; &#125; &#125; return output;&#125;int main()&#123; vector&lt;string&gt; res = compute(); for (int i = 0; i &lt; res.size(); i++) &#123; //cout &lt;&lt; res[i]; printf(\"%s\\n\", res[i].c_str()); &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/tags/Algorithm/"}]},{"title":"百度之星2020---1001.Discount","slug":"百度之星2020-1001-Discount","date":"2020-07-26T10:03:53.000Z","updated":"2020-12-28T12:30:53.946Z","comments":true,"path":"2020/07/26/百度之星2020-1001-Discount/","link":"","permalink":"https://chasencenge.github.io/2020/07/26/百度之星2020-1001-Discount/","excerpt":"Problem Description 学皇来到了一个餐馆吃饭。他觉得这家餐馆很好吃，于是就想办个会员。 一共有 n种会员充值卡套餐，假设学皇这餐饭的消费为 a元，选择第 i种套餐，需要充值 b[i] * a 的钱，这次吃饭可以打 c[i]×10 折，由充值的钱支付（即这次吃饭只需要从充值金额中扣除 a×c[i] 元）。以后用剩余的充值的钱吃饭不再打折。 请问学皇应该选择哪个套餐（必须选择恰好一个套餐），使得优惠的比例最大？ 优惠比例的定义是把充的钱用完以后，(本来应该付的钱 - 实际付的钱) / 本来应该付的钱。在这个题目里，实际付的钱就是这次充值的花费。","text":"Problem Description 学皇来到了一个餐馆吃饭。他觉得这家餐馆很好吃，于是就想办个会员。 一共有 n种会员充值卡套餐，假设学皇这餐饭的消费为 a元，选择第 i种套餐，需要充值 b[i] * a 的钱，这次吃饭可以打 c[i]×10 折，由充值的钱支付（即这次吃饭只需要从充值金额中扣除 a×c[i] 元）。以后用剩余的充值的钱吃饭不再打折。 请问学皇应该选择哪个套餐（必须选择恰好一个套餐），使得优惠的比例最大？ 优惠比例的定义是把充的钱用完以后，(本来应该付的钱 - 实际付的钱) / 本来应该付的钱。在这个题目里，实际付的钱就是这次充值的花费。 Input 第一行一个整数 test(1≤test≤100) 表示数据组数。 对于每组数据，第一行一个正整数 n(1≤n≤100) 表示套餐的数目。 接下来 n行，每行一个正整数 b[i]和一个小数 c[i]。 Output 对于每组数据，输出一个五位小数表示最大的优惠比例。如果小数点后超过五位，四舍五入到五位。 Sample Input 1234122 0.53 0.1 Sample Output 123450.23077样例解释对于第一种套餐，优惠比例为 0.5a / (2a + 0.5a） = 0.2；对于第二种套餐，优惠比例为 0.9a / (3a + 0.9a） = 9 / 39； 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;vector&lt;float&gt; compute() &#123; int groupNum; cin &gt;&gt; groupNum; vector&lt;float&gt; output; for (int i = 0; i &lt; groupNum; i++) &#123; float res = 0; int choiseNum; cin &gt;&gt; choiseNum; //cout &lt;&lt; \"choiseNum:\" &lt;&lt; choiseNum &lt;&lt; endl; int b; float c; for (int j = 0; j &lt; choiseNum; j++) &#123; cin &gt;&gt; b; //cout &lt;&lt; \"b:\" &lt;&lt; b &lt;&lt; endl; cin &gt;&gt; c; //cout &lt;&lt; \"c:\" &lt;&lt; c &lt;&lt; endl; float temp = (1 - c) / (b + 1 - c); res = max(res, temp); &#125; output.push_back(res); &#125; return output;&#125;int main()&#123; vector&lt;float&gt; res = compute(); for (int i = 0; i &lt; res.size(); i++) &#123; //cout &lt;&lt; res[i]; printf(\"%.5f\\n\", res[i]); &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/tags/Algorithm/"}]},{"title":"游戏客户端面经知识点","slug":"游戏客户端面经知识点","date":"2020-07-24T05:40:54.000Z","updated":"2020-07-24T05:43:25.394Z","comments":true,"path":"2020/07/24/游戏客户端面经知识点/","link":"","permalink":"https://chasencenge.github.io/2020/07/24/游戏客户端面经知识点/","excerpt":"","text":"","categories":[{"name":"Unity","slug":"Unity","permalink":"https://chasencenge.github.io/categories/Unity/"},{"name":"Unreal","slug":"Unity/Unreal","permalink":"https://chasencenge.github.io/categories/Unity/Unreal/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://chasencenge.github.io/tags/Unity/"},{"name":"Unreal","slug":"Unreal","permalink":"https://chasencenge.github.io/tags/Unreal/"}]},{"title":"C++面经知识点","slug":"C-面经知识点","date":"2020-07-24T05:40:35.000Z","updated":"2020-10-26T09:30:14.541Z","comments":true,"path":"2020/07/24/C-面经知识点/","link":"","permalink":"https://chasencenge.github.io/2020/07/24/C-面经知识点/","excerpt":"","text":"","categories":[{"name":"cpp","slug":"cpp","permalink":"https://chasencenge.github.io/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://chasencenge.github.io/tags/cpp/"}]},{"title":"Unity项目对接到Laya","slug":"Unity项目对接到Laya","date":"2020-07-21T09:29:24.000Z","updated":"2020-12-28T12:30:06.465Z","comments":true,"path":"2020/07/21/Unity项目对接到Laya/","link":"","permalink":"https://chasencenge.github.io/2020/07/21/Unity项目对接到Laya/","excerpt":"Unity APIGameObject.FindWithTag通过Tag名找到游戏对象 1ring = GameObject.FindWithTag(&quot;ring&quot;) FindWithTag 返回一个标记为 tag 的活动 GameObject。如果未找到 GameObject，则返回 null。 Find 按 name 查找 GameObject，然后返回它。","text":"Unity APIGameObject.FindWithTag通过Tag名找到游戏对象 1ring = GameObject.FindWithTag(&quot;ring&quot;) FindWithTag 返回一个标记为 tag 的活动 GameObject。如果未找到 GameObject，则返回 null。 Find 按 name 查找 GameObject，然后返回它。 RigidbodyRigidbody是刚体，可以为游戏对象赋予物理属性，向对象添加 Rigidbody 组件后，其运动将受到 Unity 物理引擎的控制。即使不添加任何代码，Rigidbody 对象也受到向下的重力，并在与其他对象碰撞时作出反应（需有适当的collider） position 刚体的位置 rotation 刚体的旋转 useGravity 控制重力是否影响该刚体 angularVelocity 刚体的角速度矢量（以弧度/秒为单位） velocity 刚体的速度矢量 AddForce 向 Rigidbody 添加力 Sleep 强制刚体进入睡眠状态至少一帧 AddTorque 向刚体添加扭矩 Quaternion在API中的UnityEngine-&gt;classes，四元数 12Vector3 dir = hoopPoint.position - ballPoint.position;Quaternion wantedRotation = Quaternion.LookRotation(dir); Quaternion.LookRotation(dir)使用指定的 forward 和 upwards 方向创建旋转 AngleAxis 创建一个围绕 axis 旋转 angle 度的旋转 LookRotation 使用指定的 forward 和 upwards 方向创建旋转 GameObject.GetComponentGameObject.GetComponent() 在UnityEngine-&gt;classes-&gt;GameObject 返回 GameObject 中类型为 type 的所有组件 示例： 12345678void Start()&#123; Component[] hingeJoints; hingeJoints = GetComponents(typeof(HingeJoint)); foreach (HingeJoint joint in hingeJoints) joint.useSpring = false;&#125; ForceMode位于UnityEngine-&gt;Enumerations 使用 ForceMode 指定如何使用 Rigidbody.AddForce 来施加力。 AddForce 函数可定义自己的力矢量，以及选择如何将此力施加于 GameObject（此 GameObject 必须附加有 Rigidbody 组件），从而影响您的 GameObject 的移动方式。 Force 向此刚体添加连续力，使用其质量 Acceleration 向此刚体添加连续加速度，忽略其质量 Impulse 向此刚体添加瞬时力冲击，考虑其质量 VelocityChange 向此刚体添加瞬时速度变化，忽略其质量 transform对象的位置、旋转和缩放 每个变换都可以有一个父级，使得能够分层应用位置、旋转和缩放 parent 变换的父级 position 世界空间中的变换位置 rotation 一个四元数，用于存储变换在世界空间中的旋转 localEulerAngles 以欧拉角表示的相对于父变换旋转的旋转（以度为单位） localPosition 相对于父变换的变换位置 localRotation 相对于父级变换旋转的变换旋转 localScale 相对于父对象的变换缩放 childCount 父变换具有的子项数 Camera.ScreenPointToRay1Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition); Physics.Raycast参数： origin 射线在世界坐标系中的起点 direction 射线的方向 maxDistance 射线应检查碰撞的最大距离 layerMask 层遮罩，用于在投射射线时有选择地忽略碰撞体 queryTriggerInteraction 指定该查询是否应该命中触发器 bool 如果射线与任何碰撞体相交，返回 true，否则为 false。 RaycastHit用于从射线投射获取信息的结构 barycentricCoordinate 命中的三角形的重心坐标 collider 命中的 Collider distance 从射线原点到撞击点的距离 lightmapCoord 撞击点处的 UV 光照贴图坐标 normal 射线命中的表面的法线 point 世界空间中射线命中碰撞体的撞击点 rigidbody 命中的碰撞体的 Rigidbody。如果该碰撞体未附加到刚体，则值为 /null/ textureCoord 碰撞位置处的 UV 纹理坐标 textureCoord2 撞击点处的辅助 UV 纹理坐标 transform 命中的刚体或碰撞体的 Transform triangleIndex 命中的三角形的索引 Collider所有碰撞体的基类 BoxCollider、SphereCollider、CapsuleCollider、MeshCollider、PhysicMaterial、Rigidbody 如果在游戏过程中需要移动具有 Collider 的对象，还应将 Rigidbody 组件附加到该对象。如果不想使该对象与其他对象进行物理交互，可将 Rigidbody 设置为运动刚体 变量： attachedRigidbody 碰撞体附加到的刚体 bounds 碰撞体的世界空间包围体积（只读） contactOffset 该碰撞体的接触偏移值 enabled 启用的 Collider 将与其他 Collider 碰撞，禁用的 Collider 不会这样 isTrigger 碰撞体是不是触发器 material 碰撞体使用的材质 sharedMaterial 该碰撞体的共享物理材质 消息： OnCollisionEnter 当该碰撞体/刚体已开始接触另一个刚体/碰撞体时，调用 OnCollisionEnter OnCollisionExit 当该碰撞体/刚体已停止接触另一个刚体/碰撞体时，调用 OnCollisionExit OnCollisionStay 对应正在接触刚体/碰撞体的每一个碰撞体/刚体，每帧调用一次 OnCollisionStay OnTriggerEnter 当 Collider other 事件进入该触发器时调用 OnTriggerEnter OnTriggerExit 当 Collider other 已停止接触该触发器时调用 OnTriggerExit OnTriggerStay 对于正在接触该触发器的每个其他 Collider，“几乎”所有帧都调用 OnTriggerStay。此函数位于物理计时器上，因此它不必运行每个帧 继承的成员变量： gameObject 此组件附加到的游戏对象。始终将组件附加到游戏对象 tag 此游戏对象的标签 transform 附加到此 GameObject 的 Transform hideFlags 该对象应该隐藏、随场景一起保存还是由用户修改 name 对象的名称 公共函数： BroadcastMessage 调用此游戏对象或其任何子项中的每个 MonoBehaviour 上名为 methodName 的方法 CompareTag 此游戏对象是否使用 tag 进行了标记 GetComponent 如果游戏对象附加了类型为 type 的组件，则将其返回，否则返回 null GetComponentInChildren 使用深度首次搜索返回 GameObject 或其任何子项中类型为 type 的组件 GetComponentInParent 返回 GameObject 或其任何父项中类型为 type 的组件 GetComponents 返回 GameObject 中类型为 type 的所有组件 GetComponentsInChildren 返回 GameObject 或其任何子项中类型为 type 的所有组件 GetComponentsInParent 返回 GameObject 或其任何父项中类型为 type 的所有组件 SendMessage 调用此游戏对象中的每个 MonoBehaviour 上名为 methodName 的方法 SendMessageUpwards 调用此游戏对象中的每个 MonoBehaviour 上或此行为的每个父级上名为 methodName 的方法 GetInstanceID 返回对象的实例 ID ToString 返回 GameObject 的名称 静态函数： Destroy 删除 GameObject、组件或资源 DestroyImmediate 立即销毁对象 /obj/。强烈建议您改用 Destroy DontDestroyOnLoad 在加载新的 Scene 时，请勿销毁 Object FindObjectOfType 返回第一个类型为 type 的已加载的激活对象 FindObjectsOfType 返回所有类型为 type 的已加载的激活对象的列表 Instantiate 克隆 original 对象并返回克隆对象 C#outout同ref一样，都是有一级地址传递的，也就是，带有这两个修饰符的参数，如果被修改了原来的值，将以新的值作为他的值（在函数执行完毕后，该参数的值将返回给函数调用中使用的变量，有点像C++ &amp;） 在函数中使用out参数时，必须将其看成尚未赋值。也就是说调用代码可以把已赋值的变量用作out参数，但在函数执行时该变量的值会丢失，所以就算在函数外已经初始化，在函数内也要重新初始化 示例： // 第一行hit不用初始化，参数中hit前加out，尽管Physics.Raycast返回bool，hit已在其中赋值，所以下一个if语句中hit可以调用其对象的属性方法 123456789101112131415RaycastHit hit;if (Physics.Raycast(ray, out hit, 1000, 1 &lt;&lt; 8)) &#123; if (hit.collider.gameObject.tag == &quot;Basketball&quot; &amp;&amp; !hit.collider.gameObject.GetComponent&lt;BSKBall&gt;().IsShooting()) &#123; currentBall = hit.collider.gameObject; Rigidbody r = currentBall.GetComponent&lt;Rigidbody&gt;(); r.isKinematic = true; Vector3 touchPoint = Camera.main.ScreenToWorldPoint(Input.mousePosition + new Vector3(0, 0, depth)); touchPoint.x = Mathf.Clamp(touchPoint.x, leftEdge.transform.position.x + 0.29f, rightEdge.transform.position.x - 0.29f); touchPoint.y = selectBallPosY; currentBall.transform.position = touchPoint; &#125; &#125; Unity坐标四种坐标：世界坐标(World Space)：游戏物体在创造的世界中的坐标 transfrom.position获得的是物体相对于世界坐标的位置 transfrom.localPosition获得的是物体相对于父物体坐标的位置 屏幕坐标(Screen Space)：以像素记 视口坐标(Viewport Space)：将屏幕坐标单位化 坐标转换：物体B相对于物体A的局部坐标：A.transform.InverseTransformPoint(B) 屏幕坐标转世界坐标：Camera.main.ScreenToWorldPoint 12Vector3 mousePos = Input.mousePosition;Vector3 screenToWorld = Camera.main.ScreenToWorldPoint(new Vector3(mousePos.x, mousePos.y, -Camera.main.transform.position.z)); 世界坐标转屏幕坐标：Camera.main.WorldToScreenPoint 1Vector3 worldToScreen = Camera.main.WorldToScreenPoint(transform.position); Mathf.Clamp在给定的最小浮点值和最大浮点值之间钳制给定值。如果在最小和最大范围内，则返回给定值 如果给定的浮点值小于最小值，则返回最小值。如果给定值大于最大值，则返回最大值。使用 Clamp 可将某个值限制为最小值和最大值定义的某个范围内 变量 gameObject 此组件附加到的游戏对象。始终将组件附加到游戏对象。 tag 此游戏对象的标签。 transform 附加到此 GameObject 的 Transform。 公共函数 BroadcastMessage 调用此游戏对象或其任何子项中的每个 MonoBehaviour 上名为 methodName 的方法。 CompareTag 此游戏对象是否使用 tag 进行了标记？ GetComponent 如果游戏对象附加了类型为 type 的组件，则将其返回，否则返回 null。 GetComponentInChildren 使用深度首次搜索返回 GameObject 或其任何子项中类型为 type 的组件。 GetComponentInParent 返回 GameObject 或其任何父项中类型为 type 的组件。 GetComponents 返回 GameObject 中类型为 type 的所有组件。 GetComponentsInChildren 返回 GameObject 或其任何子项中类型为 type 的所有组件。 GetComponentsInParent 返回 GameObject 或其任何父项中类型为 type 的所有组件。 SendMessage 调用此游戏对象中的每个 MonoBehaviour 上名为 methodName 的方法。 SendMessageUpwards 调用此游戏对象中的每个 MonoBehaviour 上或此行为的每个父级上名为 methodName 的方法。 继承的成员变量 hideFlags 该对象应该隐藏、随场景一起保存还是由用户修改？ name 对象的名称。 公共函数 GetInstanceID 返回对象的实例 ID。 ToString 返回 GameObject 的名称。 Component附加到 GameObject 的所有内容的基本类 注：代码不会直接创建 Component，而是编写脚本代码，然后将该脚本附加到GameObject ResourcesResources 类允许您查找和访问资源等对象 在编辑器中，Resources.FindObjectsOfTypeAll 可用于定位资源和场景对象 通过 Resources.Load 函数，可访问 Assets 文件夹中处于任意位置的名为“Resources”的文件夹中的所有资源。 可以存在多个“Resources”文件夹，加载对象时，将对每个文件夹进行检查 注意：Assets 中的 Resources 文件夹需要在使用前创建。创建新项目时，不会创建该文件夹 静态函数：（函数调用的结果不会访问或者修改任何对象（非static）数据成员，这样的成员声明为静态成员函数比较好） FindObjectsOfTypeAll 返回所有类型为 type 的对象的列表。 Load 加载存储在 Resources 文件夹中的 path 处的资源。 LoadAll 加载位于 Resources 文件夹中的 path 处的文件夹中的所有资源，或加载位于该处的文件。 LoadAsync 异步加载存储在 Resources 文件夹中的 path 处的资源。 UnloadAsset 从内存中卸载 /assetToUnload/。 UnloadUnusedAssets 卸载未使用的资源。 Laya APIRigidbody3D对应于Unity中Rigidbody.AddForce，Rigidbody.AddTorque， Laya提供的类为Rigidbody3D，对应的方法为Rigidbody3D.applyForce，Rigidbody3D.applyTorque 12345applyForce(force: Vector3, localOffset?: Vector3): voidapplyImpulse(impulse: Vector3, localOffset?: Vector3): voidapplyTorque(torque: Vector3): void","categories":[{"name":"Laya","slug":"Laya","permalink":"https://chasencenge.github.io/categories/Laya/"}],"tags":[{"name":"Laya","slug":"Laya","permalink":"https://chasencenge.github.io/tags/Laya/"}]},{"title":"Python实现Lora节点拓扑自动规划","slug":"Python实现Lora节点拓扑自动规划","date":"2020-07-20T02:57:58.000Z","updated":"2020-12-28T12:29:54.720Z","comments":true,"path":"2020/07/20/Python实现Lora节点拓扑自动规划/","link":"","permalink":"https://chasencenge.github.io/2020/07/20/Python实现Lora节点拓扑自动规划/","excerpt":"NodeClass.py:","text":"NodeClass.py: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252# 小记：# 先不考虑中继节点在classB模式下发Beacon的能耗# 能量效率的计算公式是否有问题？只考虑发包的能耗和时间# energyConsumption需统一成自己在lifetime中的能量消耗推导，不再用论文中笼统的折线图值# 注意区分self.sendTo.index和一些函数中的node.index的区别，前者使用的场景在确定节点拓扑之后，后者使用在确定节点拓扑之前的一些遍历情况import mathimport numpy as np# python中的public、private和protected是通过变量名前的下划线标识的，保护类型一个下划线，私有类型两个下划线class Node: def __init__(self, name, locX, locY, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, isGateway=0, whichSet=0, index=0): # 默认缺省值isGateway=0 self.name = name self.payload = _payload self.bandW = _bandW self.c = _c self.pi = _pi self.beta = _beta self.whiteNoise = _whiteNoise self.dutyCycle = _dutyCycle self.batteryE = _batteryE # 每确定要多为另一个节点进行中继，dataGen需要更新添加帮忙转发的数据量 self.dataGen = _dataGen self.cycleT = _cycleT self.transRadioE = _transRadioE self.recvRadioE = _recvRadioE self.spareRadioE = _spareRadioE self.offRadioE = _offRadioE self.onMcuE = _onMcuE self.offMcuE = _offMcuE # 注意和dataGen的区别，这个变量是节点发送给节点/网关的总数据量，带有中继数据 self.dataSend = _dataGen self.lifeT = 0.0 self.cycleE = 0.0 self.symbleT = 0.0 self.pktT = 0.0 self.transT = 0.0 self.recvT = 0.0 self.spareT = 0.0 self.airtime = 0.0 self.goodput = 0.0 # 用于MST中判断节点在哪个集合中,初始集合为0，MST集合为1 self.whichSet = whichSet # 标识一个“节点”是否是网关，输入中第一个“点”为网关，坐标[0, 0] self.isGateway = isGateway self.locX = locX self.locY = locY # 给节点一个索引标识 self.index = index self.relayNum = 0 # 存放了此节点通往其他节点时使用的参数值 self.spreadFactor = [7 for i in range(nodeNum)] self.transPower = [13 for i in range(nodeNum)] self.channel = [1 for i in range(nodeNum)] self.codingRate = [5 for i in range(nodeNum)] self.pdr = 0.0 # 标识此节点的数据直接发送给哪个节点，为Node类型 self.sendTo = self # 标识此节点帮助哪些节点进行数据转发 self.relayFrom = [] # 标识此节点工作在哪个class下，class会影响cycleE self.workClass = 'A' # self._prop = [] def distNode(self, node): dist = math.pow((math.pow((self.locX - node.locX), 2) + math.pow((self.locY - node.locY), 2)), 0.5) # print(self.locX) # print(self.locY) # print(node.locX) # print(node.locY) # print('Distance of ' + self.name + ' to ' + node.name + ' = ' + str(dist)) return dist # 8个信道，从902.1开始每次加0.2 def freq(self, node): frequency = 902.1 + 0.2 * self.channel[node.index] frequency *= math.pow(10, 6) # print('Frequency of channel ' + str(self.channel[node.index]) + ' = ' + str(frequency)) return frequency # Rayleigh fading channel def g(self): reyleigh = np.random.exponential(1.0, size=None) # print(self.name + ' return rayleigh fading channel g of: ' + str(reyleigh)) return reyleigh # 此为论文中的折线图值观测值实现的能耗函数，现替换成计算式方式实现 # energy consumption, unit is mW def enerConsump(self, node): energyPacket = [[40, 50], [50, 67], [65, 85], [95, 105], [100, 125], [110, 135]] clsP = 0 if self.transPower[node.index] &lt;= 15: cls_p = 0 else: cls_p = 1 clsS = self.spreadFactor[node.index] - 7 # rst = energy_packet[cls_s][cls_p] * 0.001 rst = energyPacket[clsS][clsP] # print(\"ec(line 70, unit is mW):\", rst) name = self.name sf = str(self.spreadFactor[node.index]) tp = str(self.transPower[node.index]) # 只是为了下一行不超长... # print('Energy Consumption of ' + name + ' with sf=' + sf + ', tp=' + tp + ' is: ' + str(rst)) return rst # 公式计算方式求energy consumption # def enerConsump(self): def th(self, si): if si == 7: return -6 elif si == 8: return -9 elif si == 9: return -12 elif si == 10: return -15 elif si == 11: return -17.5 elif si == 12: return -20 def ss(self, si): if si == 7: return -123 elif si == 8: return -126 elif si == 9: return -129 elif si == 10: return -132 elif si == 11: return -134.5 elif si == 12: return -137 def tomWatt(self, dBm): mWatt = math.pow(10, (dBm / 10)) # print(self.name + ' dBm to mWatt is: ' + str(mWatt)) return mWatt # 如果有relay，EE计算为payload * pdr1 * pdr2 / (energyInTime1 + energyInTime2) def energyEffi(self, node): tempVar = (8 * self.payload - 4 * self.spreadFactor[node.index] + 28 + 16) / (4 * self.spreadFactor[node.index]) time = (20.25 + max(math.ceil(tempVar) * self.channel[node.index], 0)) * 2 ** self.spreadFactor[node.index] / self.bandW energyInTime = time * self.enerConsump(node) energyEfficiency = self.payload * self.selfToNodePdr(node) / energyInTime # print('EnergyEfficiency of ' + self.name + ' is: ' + str(energyEfficiency)) return energyEfficiency def energyIntime(self, node): tempVar = (8 * self.payload - 4 * self.spreadFactor[node.index] + 28 + 16) / (4 * self.spreadFactor[node.index]) time = (20.25 + max(math.ceil(tempVar) * self.channel[node.index], 0)) * 2 ** self.spreadFactor[ node.index] / self.bandW energyInTime = time * self.enerConsump(node) return energyInTime def energyEffiRelay(self, node1, node2): tempVar1 = (8 * self.payload - 4 * self.spreadFactor[node1.index] + 28 + 16) / (4 * self.spreadFactor[node1.index]) time1 = (20.25 + max(math.ceil(tempVar1) * self.channel[node1.index], 0)) * 2 ** self.spreadFactor[node1.index] / self.bandW energyInTime1 = time1 * self.enerConsump(node1) tempVar2 = (8 * node1.payload - 4 * node1.spreadFactor[node2.index] + 28 + 16) / ( 4 * node1.spreadFactor[node2.index]) time2 = (20.25 + max(math.ceil(tempVar2) * node1.channel[node2.index], 0)) * 2 ** node1.spreadFactor[ node2.index] / node1.bandW energyInTime2 = time2 * node1.enerConsump(node2) energyEfficiency = self.payload * self.selfToNodePdr(node1) * node1.selfToNodePdr(node2) / (energyInTime1 + energyInTime2) return energyEfficiency def relayPdr(self): if(self.isGateway == 1): return 1 else: temp = self.sendTo.relayPdr() * self.selfToNodePdr(self.sendTo) return temp def relayEnergyInTime(self): if(self.isGateway == 1): return 0 else: temp = self.sendTo.relayEnergyInTime() + self.energyIntime(self.sendTo) return temp # 将设备重叠数考虑进来，重叠、channel会降低pdr def selfToNodePdr(self, node): # tempVal1是路径损失函数 tempVar1 = (self.c / (4 * self.pi * self.freq(node) * self.distNode(node))) ** self.beta # print('tempVar1:', tempVar1) # whiteNoise对pdr的影响大 tempVar2 = (self.tomWatt(self.th(self.spreadFactor[node.index])) * self.whiteNoise + self.tomWatt( self.ss(self.spreadFactor[node.index]))) # print('tempVar2:', tempVar2) # 这地方还是有问题！！！！为什么是/1000/1000，对比注释行 # pdr = math.exp(-math.pow(tempVar2 / (self.tomWatt(self.transPower) * tempVar1), 0.5)) pdr = math.exp(-math.pow(tempVar2 / (self.transPower[node.index] * tempVar1), 0.5) / 1000 / 1000) # print('Pdr of ' + self.name + ' to ' + node.name + ' is: ' + str(pdr)) return pdr # 主文件里先确定sendTo谁，再更新transT值 def updateTransT(self): self.symbleT = math.pow(2, self.spreadFactor[self.sendTo.index]) / self.bandW tempVal1 = 8 * self.payload - 4 * self.spreadFactor[self.sendTo.index] + 28 + 16 tempVal2 = 20.25 + max(math.ceil(tempVal1 / (4 * self.spreadFactor[self.sendTo.index])) * self.codingRate[self.sendTo.index], 0) self.pktT = self.symbleT * tempVal2 # 计算transT # 此节点将数据（包括自己的和中转的）发给其将要发至的节点时的pdr pdr = self.selfToNodePdr(self.sendTo) if pdr != 0: if self.relayFrom: for child in self.relayFrom: # 根据中继了哪些节点来更新dataSend的数据量，dataSend是此节点总共发送的数据量 # 若此节点非中继节点，则dataSend == dataGen self.dataSend += child.dataGen self.transT = self.pktT * self.cycleT / self.dataSend / pdr else: self.transT = 10000 return self.transT # 确定在self.relayFrom中添加完所有的远端节点后再进行更新 def updateRecvT(self): # 计算recvT，此时间包括自身发送时的class A模式的部分和中继时class B模式的recv time # 没考虑作为发送端时的recvT，因为发送时工作在classA，只在发送数据的时候顺便开一个窗口接收数据，暂时不知道窗口总时长 if self.relayFrom: if self.relayFrom: for child in self.relayFrom: self.recvT += child.transT print('Update transT of ' + self.name + ' to: ' + str(self.recvT)) return self.recvT def lifetime(self): # 设置transRadioE级别（87和120） if self.transPower[self.sendTo.index] &lt; 15: self.transRadioE = 3.3 * 87e-3 self.spareT = self.dutyCycle * self.cycleT - self.transT - self.recvT radioOnE = self.transT * self.transRadioE + self.recvT * self.recvRadioE + self.spareT * self.spareRadioE radioOffE = (1 - self.dutyCycle) * self.cycleT * self.offRadioE mcuE = self.cycleT * self.dutyCycle * self.onMcuE + self.cycleT * (1 - self.dutyCycle) * self.offMcuE self.cycleE = radioOnE + radioOffE + mcuE self.lifeT = self.cycleT * self.batteryE / self.cycleE / 3600 / 24 print('Lifetime of ' + self.name + ' is: ' + str(self.lifeT)) return self.lifeT def goodput(self): # 注意：goodput中计算的数据量用的是dataGen，而不是dataSend goodput = self.cycleT / self.dataGen * self.payload / self.transT print('Goodput of ' + self.name + ' is: ' + goodput) return goodput TopoWithMST.py:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310from MST.Node.NodeClass import Nodeimport randomimport matplotlib.pyplot as pltimport numpy as npimport mathimport scipy as syfrom scipy import statsimport xlsxwriter# 添加node要修改三个地方，node初始化，nodes列表添加该node，nodeNum值# 常量，全局变量均以“_”开头命名# _nodeNum = 6 # device number_payload = 4 # payload size of a packet, need to be modified_bandW = 125000_c = 3 * 10 ** 8_pi = 3.1415926_beta = 3 # path loss exponent, maybe a list, need to be init_whiteNoise = random.random() # gauss white noise_dutyCycle = 0.02_batteryE = 3.7 * 2 * 3600_dataGen = 2000# Radio耗电常量_cycleT = 3600 * 12_transRadioE = 3.3 * 120e-3 # 29, 87, 120_recvRadioE = 3.3 * 11.5e-3_spareRadioE = 3.3 * 1.6e-3_offRadioE = 3.3 * 1.5e-6# Known and Unknown... P10 MCU耗电情况_onMcuE = 23.48e-4_offMcuE = 174.65e-7sfRange = [7,8,9,10,11,12]tpRange = [13,14,15,16,17,18,19,20]chRange = [1,2,3,4,5,6,7,8]crRange = [5,6,7,8]nodeNum = 18# _node0是网关，所以isGateway=1, whichSet=1_node0 = Node('_node0', 0, 0, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, isGateway=1, whichSet=1)_node1 = Node('_node1', -2800, -500, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, index=1)_node2 = Node('_node2', 2500, 2700, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, index=2)_node3 = Node('_node3', 1000, 800, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, index=3)_node4 = Node('_node4', 2500, 0, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, index=4)_node5 = Node('_node5', 1000, 0, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, index=5)_node6 = Node('_node6', 1500, 2000, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, index=6)_node7 = Node('_node7', -800, 700, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, index=7)_node8 = Node('_node8', -600, -400, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, index=8)_node9 = Node('_node9', -1000, -1200, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, index=9)_node10 = Node('_node10', -1800, -2000, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, index=10)_node11 = Node('_node11', -2000, 1800, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, index=11)_node12 = Node('_node12', 1500, -2000, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, index=12)_node13 = Node('_node13', 500, -500, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, index=13)_node14 = Node('_node14', 1200, -1200, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, index=14)_node15 = Node('_node15', 2000, -2500, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, index=15)_node16 = Node('_node16', -2500, -2000, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, index=16)_node17 = Node('_node17', 2500, 1000, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, index=17)# 先求所有的边权（取所有sf，tp，cr选择中代价最小的）存储，再用MST连线（每次连线需根据isGateway确定代价是否叠加）划分集合，直到原本集合为空indexes= [i for i in range(nodeNum)]# print(indexes)nodes = [_node0, _node1, _node2, _node3, _node4, _node5, _node6, _node7, _node8, _node9, _node10, _node11, _node12, _node13, _node14, _node15, _node16, _node17]# 初始化代价矩阵costMatrix = [[0.0 for i in range(nodeNum)] for j in range(nodeNum)]# 注意python中不可用 energyEffiMatrix = costMatrix形式给矩阵赋值# 否则energyEffiMatrix的值会随costMatrix的变化而变化energyEffiMatrix = [[0.0 for i in range(nodeNum)] for p in range(nodeNum)]# 计算每条边的代价，存入代价矩阵（不过记得后面MST时代价会根据是否relay确定是否进行叠加）# 求每条边的代价实际上是先做预处理求最小代价，即遍历了可选的sf、tp、cr、# 需要考虑sf和ch相同导致的重叠,暂未添加# zip的使用for rowIndex, node in zip(indexes, nodes): for colIndex, coloum in zip(indexes, nodes): if node is not coloum: # 针对某一条边求cheapest代价 maxEE = 0 setSpreadFactor = 7 setTransPower = 13 setChannel = 1 setCodingRate =5 for sf in sfRange: for tp in tpRange: for ch in chRange: for cr in crRange: node.spreadFactor[coloum.index] = sf node.transPower[coloum.index] = tp node.channel[coloum.index] = ch node.codingRate[coloum.index] = cr tempEE = node.energyEffi(coloum) if(maxEE &lt; tempEE): maxEE = tempEE setSpreadFactor = sf setTransPower = tp setChannel = ch setCodingRate = cr node.spreadFactor[coloum.index] = setSpreadFactor node.transPower[coloum.index] = setTransPower node.channel[coloum.index] = setChannel node.codingRate[coloum.index] = setCodingRate costMatrix[rowIndex][colIndex] = maxEE else: costMatrix[rowIndex][colIndex] = 0.1for row in range(nodeNum): for col in range(nodeNum): energyEffiMatrix[row][col] = costMatrix[row][col]for n in range(0, nodeNum): print(costMatrix[n])# 代价是能量效率的倒数for row in range(nodeNum): for col in range(nodeNum): costMatrix[row][col] = 1 / costMatrix[row][col]print('cost statistic:')for n in range(0, nodeNum): print(costMatrix[n])# print(_node1.spreadFactor)# print(_node1.transPower)# print(_node1.channel)# print(_node1.codingRate)# 此部分仍有问题，需核对pdr和代价（能量效率EE）计算中各个参数对energy efficiency的影响toWhichIndexes= [i for i in range(nodeNum)]# u集合中的节点数uNodeNum = 1while(uNodeNum != nodeNum): minCost = 9999 addRelay = nodes[0] ifRelay = False nodeToUSet = nodes[0] backTrack = nodes[0] for nodeIndex in range(0, nodeNum): # minCost = 9999 # toWhichIndex为当前查看的v集合中的节点的index，可通过nodes列表反索引到相应的node # thisLineCost为单条边的cost，我们需要的是实际的cost（即带relay） # relay是在MST的过程中产生的 # 网关初始应在u集合，对应的whichSet=1 # addRelay = nodes[0] # ifRelay = False # nodeToUSet = nodes[0] for toWhichIndex, thisLineCost in zip(toWhichIndexes, costMatrix[nodeIndex]): # 一个节点属于u集合，一个节点属于v集合，才进行处理，否则不符合MST要求，进行下轮循环 # addRelay = nodes[0] # ifRelay = False # nodeToUSet = nodes[0] if (nodes[nodeIndex].whichSet == 1 and nodes[toWhichIndex].whichSet == 0): # if ((nodes[nodeIndex].whichSet == 1 and nodes[toWhichIndex].whichSet == 0) or # (nodes[nodeIndex].whichSet == 0 and nodes[toWhichIndex].whichSet == 1)): # 其中有一个是网关的话，说明与网关直接相连，thisLineCost即为realCost if (nodes[nodeIndex].isGateway == 1 or nodes[toWhichIndex].isGateway == 1): realCost = thisLineCost if realCost &lt; minCost: print('node:', nodes[nodeIndex].name, ' nodeTo:', nodes[toWhichIndex].name) backTrack = nodes[nodeIndex] ifRelay = False minCost = realCost nodeToUSet = nodes[toWhichIndex] # 所检索的边不是与网关直接相连，需要中继 else: # print(nodes[nodeIndex].name, nodes[toWhichIndex].name, thisLineCost, costMatrix[toWhichIndex][0], minCost) # 需要中继的，先把代价求倒数转换成EE，两段EE相加之后再求倒数得到整段的代价 # [0]代表中继节点到网关的代价，因为网关为矩阵的第一列 # cost计算方式1 # realCost = thisLineCost + costMatrix[nodeIndex][0] # cost计算方式2，见NodeClass中EE计算函数注释 # 这里energyEffiiRelay的实现实际应该是有递归，比如如果有两次relay，则 # payload * pdr1 * pdr2 * pdr3 / (energyInTime1 + energyInTime2 + energyInTime3)，怎么实现? # 分别实现一个pdr的递归和一个energyInTime的递归 energyEffiRelay = nodes[toWhichIndex].payload * nodes[toWhichIndex].selfToNodePdr(nodes[nodeIndex]) * nodes[nodeIndex].relayPdr() / (nodes[toWhichIndex].energyIntime(nodes[nodeIndex]) + nodes[nodeIndex].relayEnergyInTime()) realCost = 1 / energyEffiRelay if realCost &lt; minCost: # 如果12-0代价大于12-14-0，修改cost矩阵，将costMatrix[12][0]修改为12-14-0（经14中继）的代价 costMatrix[toWhichIndex][0] = realCost # print(minCost) print('node:', nodes[nodeIndex].name, ' nodeTo:', nodes[toWhichIndex].name) print(1 / thisLineCost) print(1 / costMatrix[nodeIndex][0]) print(realCost) backTrack = nodes[nodeIndex] addRelay = nodes[toWhichIndex] # node类型 ifRelay = True minCost = realCost nodeToUSet = nodes[toWhichIndex] # 如果有中继的拓扑选择，为中继点修改relayNum, relayFrom信息 if (ifRelay == True and addRelay): # addRelay.relayNum += 1 # addRelay.relayFrom.append(backTrack.name) backTrack.relayNum += 1 backTrack.relayFrom.append(addRelay.name) # 把新选择的节点添加到U集合 nodeToUSet.whichSet = 1 # 注意生成树的方向 # 到最后应该_node0(网关)的sendTo没什么用 nodeToUSet.sendTo = backTrack uNodeNum += 1 print('one loop.')for n in range(0, nodeNum): print(energyEffiMatrix[n]) print(costMatrix[n])# 测试结果for n in range(0, nodeNum): print(costMatrix[n])# 检查拓扑print('Topo statistic:')for n in range(0, nodeNum): print(nodes[n].name + ' send to ' + nodes[n].sendTo.name)print('nodes belong to which set:')# 检查集合setList = []for n in range(0, nodeNum): # print(nodes[n].whichSet) setList.append(nodes[n].whichSet)print(setList)# 检查每个节点的relayNum# relayNum技术规则还有问题print(' relay number statistic: ')for n in range(0, nodeNum): print(nodes[n].name + ' relay number: ' + str(nodes[n].relayNum))print('params choise:')for n in range(0, nodeNum): # 现有结果表明优先增大tp，增到最大才开始增加sf，即增大sf带来的代价远超增大tp print(nodes[n].name + ' sf: ' + str(nodes[n].spreadFactor) + ' tp:' + str(nodes[n].transPower) + ' cr:' + str(nodes[n].codingRate))print('relay:')for n in range(0, nodeNum): print(nodes[n].name , 'relay:', nodes[n].relayFrom)# 检查EEprint('EE origin:')for n in range(1, nodeNum): print(nodes[n].name, ' EE origin:', energyEffiMatrix[n][0])print('EE final:')for n in range(1, nodeNum): print(nodes[n].name, ' EE final:', 1 / costMatrix[n][0])# 绘图plt.subplot(121)for n in range(0, nodeNum): thisNodeLoc = [nodes[n].locX, nodes[n].locY] sendToNodeLoc = [nodes[n].sendTo.locX, nodes[n].sendTo.locY] plt.scatter(thisNodeLoc[0], thisNodeLoc[1], s=10, color='b') plt.plot([thisNodeLoc[0], sendToNodeLoc[0]], [thisNodeLoc[1], sendToNodeLoc[1]]) plt.annotate(thisNodeLoc, xy=(thisNodeLoc[0], thisNodeLoc[1]), xytext=(thisNodeLoc[0]+1, thisNodeLoc[1]+1))plt.xlim(-2800,2800)plt.ylim(-2800,2800)# 绘EE柱状图# subplot绘制子图plt.subplot(122)nodeNameList = []nodeEEOriginList = []nodeEEFinalList = []for n in range(0, nodeNum): nodeNameList.append(str(n)) nodeEEOriginList.append(energyEffiMatrix[n][0]) nodeEEFinalList.append(1 / costMatrix[n][0])total_width, n = 0.8, 2width = total_width / nplt.bar(indexes, nodeEEOriginList, width=width, label='1', fc='b')for i in range(len(indexes)): indexes[i] += widthplt.bar(indexes, nodeEEFinalList, width=width, label='2', tick_label=nodeNameList, fc='g')plt.legend()plt.show()","categories":[{"name":"Python","slug":"Python","permalink":"https://chasencenge.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://chasencenge.github.io/tags/Python/"}]},{"title":"hexo更换flex-block主题","slug":"hexo更换flex-block主题","date":"2020-07-17T03:00:22.000Z","updated":"2020-12-28T12:29:17.602Z","comments":true,"path":"2020/07/17/hexo更换flex-block主题/","link":"","permalink":"https://chasencenge.github.io/2020/07/17/hexo更换flex-block主题/","excerpt":"基础配置hexo/_config.yml文件中： 1theme: flex-block 为了能够正常显示图片，在hexo/_config.yml： 12# Writingpost_asset_folder: true 这样每次创建新文件时会生成一个asset文件夹，用到的图片素材均放在此同名文件夹中进行调用","text":"基础配置hexo/_config.yml文件中： 1theme: flex-block 为了能够正常显示图片，在hexo/_config.yml： 12# Writingpost_asset_folder: true 这样每次创建新文件时会生成一个asset文件夹，用到的图片素材均放在此同名文件夹中进行调用 还需安装相应插件： 1npm install https://github.com/CodeFalling/hexo-asset-image --save 在相应的.md文件中调用图片资源时，切记！！！！💊💊💊 调用图片资源的路径直接写图片文件名，默认路径已经切到相应同名文件夹下，不可使用绝对路径名！！！！ 修改新建文件时给出的默认Front-MatterFront-Matter说明 修改hexo/scaffolds下的： draft.md, page.md, post.md 修改方式见：https://github.com/miiiku/flex-block 添加代码高亮https://highlightjs.org/ 下载依赖： 1npm install highlight.js hexo/_config.yml: （theme格式：小写，空格以“-”替代，如monokai-sublime） 12345678highlight: enable: true line_number: true auto_detect: false tab_replace: hljs: true # theme: railscasts theme: pojoaque 添加社交平台链接hexo/themes/flex-block/_config.yml: 12345678910111213social_icon: header_enable: true footer_enable: true icons: - &#123; type: email, value: 958198376@qq.com&#125; - &#123; type: github, value: https://github.com/CHAsencenge&#125; - &#123; type: google+, value: &#125; - &#123; type: ins, value: &#125; - &#123; type: twitter, value: &#125; - &#123; type: youtube, value: &#125; - &#123; type: weibo, value: https://weibo.com/u/5701921017&#125; - &#123; type: cloudmusic, value: https://music.163.com/#/user/home?id=92407481&#125; - &#123; type: zhihu, value: &#125; 修改主页标签显示（英文-&gt;中文）hexo/themes/flex-block/_config.yml: 修改其中的menu: 123456menu: 主页: / 关于: /about 友链: /links 标签: /tags 分类: /categories 添加友链页面并顺手放些要用的图片资源添加友链页面：(顺口一提，hexo new page 会生成与_post同级的文件夹) 1hexo new page links 在links/index.md中修改Front-matter，添加： 1type: links 确认hexo/themes/flex-block/_config.yml中是否有(左侧为标签显示，不重要，重要的是是否写了右侧的/links目录)： 1links: /links 存放友链数据在source目录下(与_post同级) ， 创建: _data文件夹 在source/_data下新建links.yml 一行一条友链数据，格式如下(现在links文件夹下创建Asset文件夹，存放相应的图片资源，并push到仓库，因为cover参数需要url，不能是本地路径，所以将资源推到仓库同时从仓库的对应url取图片资源作为cover)： 1234567891011121314151617181920- &#123; \"name\" : \"tianzixiao\", \"describe\" : \"测试\", \"link\" : \"Asset/tianzixiao.png\", \"cover\" : \"https://chasencenge.github.io/links/Asset/tianzixiao.png\" &#125;- &#123; \"name\" : \"cover1\", \"describe\" : \"测试\", \"link\" : \"Asset/cover1.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover1.jpg\" &#125;- &#123; \"name\" : \"cover2\", \"describe\" : \"测试\", \"link\" : \"Asset/cover2.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover2.jpg\" &#125;- &#123; \"name\" : \"cover3\", \"describe\" : \"测试\", \"link\" : \"Asset/cover3.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover3.jpg\" &#125;- &#123; \"name\" : \"cover4\", \"describe\" : \"测试\", \"link\" : \"Asset/cover4.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover4.jpg\" &#125;- &#123; \"name\" : \"cover5\", \"describe\" : \"测试\", \"link\" : \"Asset/cover5.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover5.jpg\" &#125;- &#123; \"name\" : \"cover6\", \"describe\" : \"测试\", \"link\" : \"Asset/cover6.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover6.jpg\" &#125;- &#123; \"name\" : \"cover7\", \"describe\" : \"测试\", \"link\" : \"Asset/cover7.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover7.jpg\" &#125;- &#123; \"name\" : \"cover8\", \"describe\" : \"测试\", \"link\" : \"Asset/cover8.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover8.jpg\" &#125;- &#123; \"name\" : \"cover9\", \"describe\" : \"测试\", \"link\" : \"Asset/cover9.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover9.jpg\" &#125;- &#123; \"name\" : \"cover10\", \"describe\" : \"测试\", \"link\" : \"Asset/cover10.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover10.jpg\" &#125;- &#123; \"name\" : \"cover11\", \"describe\" : \"测试\", \"link\" : \"Asset/cover11.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover11.jpg\" &#125;- &#123; \"name\" : \"cover12\", \"describe\" : \"测试\", \"link\" : \"Asset/cover12.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover12.jpg\" &#125;- &#123; \"name\" : \"cover13\", \"describe\" : \"测试\", \"link\" : \"Asset/cover13.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover13.jpg\" &#125;- &#123; \"name\" : \"cover14\", \"describe\" : \"测试\", \"link\" : \"Asset/cover14.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover14.jpg\" &#125;- &#123; \"name\" : \"cover15\", \"describe\" : \"测试\", \"link\" : \"Asset/cover15.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover15.jpg\" &#125;- &#123; \"name\" : \"cover16\", \"describe\" : \"测试\", \"link\" : \"Asset/cover16.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover16.jpg\" &#125;- &#123; \"name\" : \"cover17\", \"describe\" : \"测试\", \"link\" : \"Asset/cover17.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover17.jpg\" &#125;- &#123; \"name\" : \"cover18\", \"describe\" : \"测试\", \"link\" : \"Asset/cover18.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover18.jpg\" &#125;- &#123; \"name\" : \"cover19\", \"describe\" : \"测试\", \"link\" : \"Asset/cover19.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover19.jpg\" &#125; 修改主页bannerhexo/themes/flex-block/_config.yml: 1banner: https://chasencenge.github.io/links/Asset/cover19.jpg 关于card无法显示cover图片的问题在主页按F12查看页面bug，发现无法找到cover.jpg，对比其他文章页面，无error，说明主页card的图片寻径和文章页的cover寻径不同 在F12调试工具中-&gt;Application，对比主页和文章页查看，发现各自的image加载是在各自的index.html同级目录下，故将用到的所有文件资源复制到hexo/public目录下，但是此目录仅支持主页正常显示，翻页时会进入page2，page3等等，所以将所用到的card资源同样放置在hexo/public/page/2、hexo/public/page/3等目录下 btw，为了保证主页card显示的图片不冲突，以上目录下的图片不可重名，又由于以上目录的图片名需与hexo/source/_post中的每一篇的cover同名，故每个文章的asset-folder中的cover命名不要重名，文章front-matter同理 asset-folder的cover命名： front-matter的cover命名保证与asset-folder一致，并与hexo/public中的资源名称一致：1cover: cover22.jpg 添加鼠标拖拽如果没有拖拽移动的功能，代码部分无法通过鼠标拖拽看到右侧超出框宽的部分，页面很长时也无法通过拖拽快速下拉，只能用滚轮，很不方便 解决：打开flex-block文件夹，source/css/style.styl，将9-11行注释掉","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://chasencenge.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://chasencenge.github.io/tags/Hexo/"}]},{"title":"Laya Basketball小游戏踩坑历程","slug":"Laya-Basketball小游戏踩坑历程","date":"2020-07-17T01:39:43.000Z","updated":"2020-10-26T09:30:32.078Z","comments":true,"path":"2020/07/17/Laya-Basketball小游戏踩坑历程/","link":"","permalink":"https://chasencenge.github.io/2020/07/17/Laya-Basketball小游戏踩坑历程/","excerpt":"Laya3D小项目中的踩坑历程","text":"Laya3D小项目中的踩坑历程 .lh or .ls测试Unity导出的Scene（仅包含3D球架）在导入Laya后的显示，发现若导出.lh文件，在Laya创建的Scene中挂载脚本运行时会报“cannot read ‘_addCamera’ of undefined”错误，解决此问题时选择重新导出.ls文件 相应脚本： 123456789101112131415161718import &#123; ui &#125; from \"./../ui/layaMaxUI\";export default class SmallScene extends Laya.Script &#123; constructor() &#123; super(); &#125; onEnable(): void &#123; Laya3D.init(0, 0); Laya.Stat.show(); Laya.stage.scaleMode = Laya.Stage.SCALE_FULL; Laya.stage.screenMode = Laya.Stage.SCREEN_NONE; Laya.Scene3D.load(\"res/Loading/LayaScene_SmallScene/Conventional/SmallScene.ls\", Laya.Handler.create(null, function(scene:Laya.Scene3D):void &#123; Laya.stage.addChild(scene) as Laya.Scene3D; &#125;)); &#125; onDisable(): void &#123; &#125;&#125;new SmallScene; 导出文件说明：ls — 场景文件： Json文件，包含场景中所有节点的数据信息，包含光照贴图信息lh — 层级文件： Json文件，包含场景中所有节点的数据信息，不包含光照贴图信息lt — 地形文件： Json文件，包含地形中的数据信息lm — 网格文件： 二进制文件，包含模型所有顶点的数据信息lmat — 材质文件： Json文件，包含光照，贴图，渲染模式等基本材质信息lsani — 蒙皮动画文件：二进制文件，包含骨骼动画帧率信息lrani — 刚体动画文件：二进制文件，包含刚体动画帧率信息lav — 新版动画节点文件：Json文件，只包含Animator组件下节点的数据信息lani — 新版动画文件：二进制文件，包含Animator动画帧率信息 Mesh Collider 和 Box Collider的选择：篮筐处有两个Trigger，一个在篮筐一个在篮网，篮筐环附近用Box Collider（元碰撞器），篮网用Mesh Collider（网格），后者渲染时消耗资源比前者大很多 如何进一步操作导入的Scene中的子对象？laya.display.Node 测试时在Laya.Scene3D.load的call中添加： 1console.log(\"scene.numChildren:\", scene.numChildren); 可在运行时查看scene中的子对象个数 其他类似操作代码如下： 123456789101112Laya.Scene3D.load(\"res/Loading/LayaScene_SmallScene/Conventional/SmallScene.ls\", Laya.Handler.create(null, function(scene:Laya.Scene3D):void &#123; //myScene = scene; Laya.stage.addChild(scene) as Laya.Scene3D; //var camera = new Laya.Camera(0, 3, 10); //scene.addChild(camera); console.log(\"scene.numChildren:\", scene.numChildren); let sprite:Laya.Sprite3D = new Laya.Sprite3D(); scene.addChildAt(sprite, 5); console.log(scene.getChildAt(3).name); console.log(scene.getChildAt(4).name); console.log(scene.getChildAt(5).name); &#125;)); 关于Laya.Handler.createHandler是事件处理器类 laya.utils.Handler create(caller:*, method:Fuction, args:Array = null, once:Boolean = true): Handler caller:* -执行域(this) method:Function -回调方法 args:Array -携带的参数 once:Boolean -是否只执行一次，默认为true 注意once后或者Handler.recover()后不要再使用此对象 流程GolbalDataScene -&gt; StartScene -&gt; LoadingScene -&gt; GameScene GolbalDataScene/GameStaticController/ConfigController中控制加载Assets/Resources/Config中的BallsData和StageData 一些说明每个Scene中的UIController是用相同的BSK Manager脚本，即，所有场景能用到的UI相关的管理控制都放在这个脚本，其他通用的Cotorller也如此 reset球的函数在BSKGameController -&gt; resetBalls，设置了篮球的初始化位置，Rotation，layer，放到balls列表（但是没有设置其物理属性如重力、碰撞） 给篮球（balls）获取BSKBall组件、添加刚体、并且siKinematic = true使物理影响刚体在BSKShooter中的Update函数中（Update每一帧都调用） 在Laya中创建的对应脚本的类型的选择要考虑Unity中对应脚本是否有Update等逐帧刷新的功能 对Unity中具有Update等逐帧刷新的Component（Monobehavior），在Laya中创建对应脚本所选类型要考虑是否有相同逐帧刷新的内置函数 BSKBall -&gt; Start函数： 1gameObject.GetComponent&lt;Renderer&gt;().material = BSKGameConfig.s_Instance.GetBallMaterial(); 篮球资源是如何加载进去的：在BSKGameController声明一个GameObject对象-BallPrefab，然后在Unity的Inspector中可以直接选取需要的“lanqiu”资源 将Unity中的Scene导入Laya时，games_bg不能导入，因为不支持Sprite Renderer","categories":[{"name":"Laya","slug":"Laya","permalink":"https://chasencenge.github.io/categories/Laya/"}],"tags":[{"name":"Laya","slug":"Laya","permalink":"https://chasencenge.github.io/tags/Laya/"}]},{"title":"LoRa的三种class","slug":"LoRa的三种class","date":"2020-07-14T14:30:06.000Z","updated":"2020-12-28T06:15:04.757Z","comments":true,"path":"2020/07/14/LoRa的三种class/","link":"","permalink":"https://chasencenge.github.io/2020/07/14/LoRa的三种class/","excerpt":"LoRa class A, class B, class C三种工作模式","text":"LoRa class A, class B, class C三种工作模式 class AClass A 是 LoRaWAN 强制要求所有 LoRa 终端设备必须支持的通信模式。在Class A中，终端设备只在有数据需要处理或发送的时候才从休眠模式中醒来，并且一切通信都只能由发送终端设备主动发起，网关一直处于侦听模式。当发送终端设备进行一次发送（TX）之后，会等待时间T(RX_DELAY1)之后初始化一个接收窗口RX1，若RX1内发送终端设备未收到任何数据，则会在T_(RX_DELAY2)时间后再初始化一个接收窗口RX2，继续等待接收数据，窗口关闭后则进入睡眠模式。网关可在此窗口时间内向终端设备发送数据 接收窗口RX1一般是在上行后1秒开始，接收窗口RX2是在上行后2秒开始 终端有数据了，就上报，顺便收一下服务器下发的指令。终端没数据的时候，服务器下发不了指令 class BClass B 为需要双向交互的应用设计。在 Class A 的基础上增加了可以由网关主动唤醒发送终端设备的机制，网关每隔 T_Beacon 时间会发送一个 Beacon 来主动唤醒终端设备，在两个 Beacon 之间，终端设备的通信模式和 Class A 相同。通过 Class B 主动唤醒节点的方式，网关可以定期开启终端设备的下载和上传功能。相比 Class A，Class B 降低了数据的传输时延，但也增加了终端设备的能耗 有一个同步时隙beacon，还有一个固定周期的接收窗口ping时隙。(隔几十秒收一个数据。其他时候都在休眠) 终端和基站约定一个时间下发数据，终端和基站依靠beacon信号校对时间，确保约定的时间不会错位 ClassB的目的是使得节点具有在预定时间打开接收窗口（称之为ping slot）的能力。一个支持ClassB的网络，所有的网关都必须同步发送beacon class CClass C 用于时延要求高的应用，发送终端设备再发送完成之后会立即初始化接收窗口，若未收到任何数据，则会一直开启随后的RX2窗口持续侦听信道，用于接收网关返回的数据 在class A的基础上，在class A休眠期间，一直打开接收窗口RX2（几乎随时可以接收数据） BeaconLoRa一旦约定好了时间，基站就默认设备一定会在那个时间点接收，所以需要严格的时间同步。Beacon则是时间同步的最关键的地方 节点由ClassA切换到ClassB之前必须收到beacon，进入ClassB之后还需要周期搜索/接收beacon，从而同步时钟。Class B节点可能临时收不到beacon，此时节点要逐渐加宽beacon和ping的接收窗。如果收到beacon后2小时收不到新的beacon，节点需使用内部时钟保持同步","categories":[{"name":"LoRa","slug":"LoRa","permalink":"https://chasencenge.github.io/categories/LoRa/"}],"tags":[{"name":"LoRa","slug":"LoRa","permalink":"https://chasencenge.github.io/tags/LoRa/"}]},{"title":"C++.h和.cpp","slug":"C-h和-cpp","date":"2020-07-13T03:04:52.000Z","updated":"2020-10-26T09:26:43.823Z","comments":true,"path":"2020/07/13/C-h和-cpp/","link":"","permalink":"https://chasencenge.github.io/2020/07/13/C-h和-cpp/","excerpt":"C++的.h文件和.cpp文件各应该包含什么内容","text":"C++的.h文件和.cpp文件各应该包含什么内容 .h文件类的声明，成员函数声明… 记得在头部添加： 123#ifndef XXXX_H //这里如果头文件名为LoraNode.h, 则写为LORANODE_H#define XXXX_H#pragma once //这个一般在创建头文件的时候会自动添加 尾部添加： 1#endif 目的是为了防止重复编译而报错 .cpp文件填写类成员函数的定义 首先引用头文件 1#include \"xxxx.h\" 注：不用再重写class Name{}，否则会报错为class重定义，直接使用::进行外部定义类成员函数即可 例： 123double LoraNode::th(si)&#123;...&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://chasencenge.github.io/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://chasencenge.github.io/tags/cpp/"}]},{"title":"将Unity场景导入到LayaAir","slug":"将Unity场景导入到LayaAir","date":"2020-07-09T01:02:46.000Z","updated":"2020-12-28T12:30:35.183Z","comments":true,"path":"2020/07/09/将Unity场景导入到LayaAir/","link":"","permalink":"https://chasencenge.github.io/2020/07/09/将Unity场景导入到LayaAir/","excerpt":"将U3D插件拖拽到Unity项目的Assets目录下，会自动在项目中import LayaAir3D选项 LayaAir3d-&gt;Export Tool中可以导出Unity Scene 导出到laya工程下的bin-&gt;res文件夹 LayaAir3D-&gt;Help-&gt;Tutorial可看哪些是能够兼容的 骨骼动画： spine骨骼动画工具 骨骼动画: 把动画打散, 通过工具，调骨骼的运动等来形成动画spine是一个非常流行的2D骨骼动画制作工具spine 动画美术人员导出3个文件: (1) .png文件:动画的”骨骼”的图片集; (2).atlas文件: 每个骨骼在图片集里面位置，大小; (3).json文件: 骨骼动画的anim控制文件,以及骨骼位置等信息;骨骼动画导入: 直接把三个文件拷贝到项目的资源目录下即可;使用骨骼动画 2种方式: (1) 直接拖动到场景; (2) 创建一个节点来添加sp.Skeleton组件; Unity的骨骼动画：Unity导入骨骼动画时需要的源文件也是spine导出的： .atlas .json .png三个文件，不过需要将.atlas重命名为.atlas.txt Laya的骨骼动画：Laya的骨骼动画在导入的时候是直接对接Spine导出的骨骼动画格式的，即.atlas .json .png三个文件","text":"将U3D插件拖拽到Unity项目的Assets目录下，会自动在项目中import LayaAir3D选项 LayaAir3d-&gt;Export Tool中可以导出Unity Scene 导出到laya工程下的bin-&gt;res文件夹 LayaAir3D-&gt;Help-&gt;Tutorial可看哪些是能够兼容的 骨骼动画： spine骨骼动画工具 骨骼动画: 把动画打散, 通过工具，调骨骼的运动等来形成动画spine是一个非常流行的2D骨骼动画制作工具spine 动画美术人员导出3个文件: (1) .png文件:动画的”骨骼”的图片集; (2).atlas文件: 每个骨骼在图片集里面位置，大小; (3).json文件: 骨骼动画的anim控制文件,以及骨骼位置等信息;骨骼动画导入: 直接把三个文件拷贝到项目的资源目录下即可;使用骨骼动画 2种方式: (1) 直接拖动到场景; (2) 创建一个节点来添加sp.Skeleton组件; Unity的骨骼动画：Unity导入骨骼动画时需要的源文件也是spine导出的： .atlas .json .png三个文件，不过需要将.atlas重命名为.atlas.txt Laya的骨骼动画：Laya的骨骼动画在导入的时候是直接对接Spine导出的骨骼动画格式的，即.atlas .json .png三个文件","categories":[{"name":"Laya","slug":"Laya","permalink":"https://chasencenge.github.io/categories/Laya/"}],"tags":[{"name":"Laya","slug":"Laya","permalink":"https://chasencenge.github.io/tags/Laya/"}]},{"title":"为Sublime添加TypeScript高亮支持","slug":"为Sublime添加TypeScript高亮支持","date":"2020-07-09T00:50:23.000Z","updated":"2020-12-28T12:30:17.617Z","comments":true,"path":"2020/07/09/为Sublime添加TypeScript高亮支持/","link":"","permalink":"https://chasencenge.github.io/2020/07/09/为Sublime添加TypeScript高亮支持/","excerpt":"首先在cmd或者Git CMD安装typescript编译支持：npm install -g typescript 若出现npm ERR! code EINTEGRITY报错： npm cache verify 打开sublime安装package control：在sublime中ctrl+shift+p打开命令面板 输入ip查找Package Control: Installl Package 打开package control安装TypeScript：打开preference-&gt;package control，然后继续查找TypeScript进行安装","text":"首先在cmd或者Git CMD安装typescript编译支持：npm install -g typescript 若出现npm ERR! code EINTEGRITY报错： npm cache verify 打开sublime安装package control：在sublime中ctrl+shift+p打开命令面板 输入ip查找Package Control: Installl Package 打开package control安装TypeScript：打开preference-&gt;package control，然后继续查找TypeScript进行安装","categories":[{"name":"Laya","slug":"Laya","permalink":"https://chasencenge.github.io/categories/Laya/"}],"tags":[{"name":"Laya","slug":"Laya","permalink":"https://chasencenge.github.io/tags/Laya/"}]},{"title":"UnitySprite","slug":"UnitySprite","date":"2020-07-08T01:35:52.000Z","updated":"2020-10-26T09:28:09.115Z","comments":true,"path":"2020/07/08/UnitySprite/","link":"","permalink":"https://chasencenge.github.io/2020/07/08/UnitySprite/","excerpt":"Sprite相关","text":"Sprite相关 Sprite RendererFlip：勾选后图片会在X或Y轴方向上翻转 Material:材质，默认是Sprites - Default，场景中的灯光不会影响到图片，改为Default - Diffuse，灯光可以照亮图片 Draw Mode：绘图模式, 普通，拉伸，平铺 Sorting Layer：分类层，控制图片的渲染顺序，点开Sorting Layer，越靠下的越后渲染，越在最前面，挡住后面的图片 Order In Layer：在同一层中的次序，当图片在同一个层下时，设置此数值可以再次控制渲染顺序 Mask Interaction：遮罩交互 打包图集Editor-&gt;Project Settings-&gt;Editor下面有sprite packer的模式。Disabled表示不启用它，Enabled For Builds 表示只有打包的时候才会启用它，Always Enabled 表示永远启用它。 这里的启用它就表示是否将小图自动打成图集。 .prefab文件 .prefab文件在Unity引擎中，扮演着配置文件的作用，用它将多个组件关联在了一起，组成了一个整体，默认是一个二进制文件 .meta文件新的资源导入Unity时，Unity会自动做下面这件事： 1.分配唯一ID 2.创建.meta文件 3.处理资源 .meta文件包含内容： guid：分配的唯一ID存在这里 MonoImporter：它的数据是不同的ImprotSetting数据，比如Mode Improter，Audio Improter等等，对照Inspector面板就可以看懂每行数据","categories":[{"name":"Unity","slug":"Unity","permalink":"https://chasencenge.github.io/categories/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://chasencenge.github.io/tags/Unity/"}]},{"title":"ProjectTiny爬坑记录","slug":"ProjectTiny爬坑记录","date":"2020-07-07T13:23:22.000Z","updated":"2020-10-26T09:27:51.967Z","comments":true,"path":"2020/07/07/ProjectTiny爬坑记录/","link":"","permalink":"https://chasencenge.github.io/2020/07/07/ProjectTiny爬坑记录/","excerpt":"","text":"","categories":[{"name":"Unity","slug":"Unity","permalink":"https://chasencenge.github.io/categories/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://chasencenge.github.io/tags/Unity/"}]},{"title":"ProjectTinyWorkshop核心知识点","slug":"ProjectTinyWorkshop核心知识点","date":"2020-07-07T13:03:53.000Z","updated":"2020-10-26T09:27:18.864Z","comments":true,"path":"2020/07/07/ProjectTinyWorkshop核心知识点/","link":"","permalink":"https://chasencenge.github.io/2020/07/07/ProjectTinyWorkshop核心知识点/","excerpt":"ECS & Monobehaviours","text":"ECS & Monobehaviours Monobehaviours: C#类，引用类型，数据分散在内存中，当数据取回时，系统需要遍历内存去寻找，操作时不需要的数据也被处理 ECS: 使用值类型，数据会在内存中紧密地装在一块(chunk)，仅处理需要操作的数据 Entities只是帮助我们找到(component)数据的handle Components举例：(Component只是模块化的数据) 123456789101112struct Health : IComponentData&#123; int current; int max;&#125;struct Sprite2D : IComponentData&#123; Entity image; Rect imageRegion; Vector2 pivot;&#125; Entities举例： 比如某个Entity 1有四个组件(Component)，LocalPosition组件，Sprite2DRenderer组件，Health组件，Player组件（这里没有行为，行为由系统（System）给出） Systems不在乎它处理的生命值是玩家的生命值还是一个兽人或者哥布林的生命值 Systems包括两部分，一是query，帮我找到这个数据，那个数据…，找到了之后对数据的action 用System的方式筛选要操作的rntities: 123456789101112public override void OnUpdate()&#123; var dt = Scheduler.DeltaTime(); ForEach( LocalPosition MoveToTarget Not : Frozen =&gt; //注意查询时的这种筛选，用Not &#123; //actions &#125; );&#125;","categories":[{"name":"Unity","slug":"Unity","permalink":"https://chasencenge.github.io/categories/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://chasencenge.github.io/tags/Unity/"}]},{"title":"Unity DOTS(直播笔记)","slug":"UnityDOTS(直播笔记)","date":"2020-07-07T12:52:13.000Z","updated":"2020-10-26T09:28:03.765Z","comments":true,"path":"2020/07/07/UnityDOTS(直播笔记)/","link":"","permalink":"https://chasencenge.github.io/2020/07/07/UnityDOTS(直播笔记)/","excerpt":"ECS优化缓存行-- ECS和传统游戏对象-- 原型Archtype-- 栈帧-- 组件与共享组件-- ECS实例-- 汇编指令-- SIMD-- Burst编译器-- Unity.mathematics数学库-- Job多线程计算-- 系统生命周期--","text":"ECS优化缓存行-- ECS和传统游戏对象-- 原型Archtype-- 栈帧-- 组件与共享组件-- ECS实例-- 汇编指令-- SIMD-- Burst编译器-- Unity.mathematics数学库-- Job多线程计算-- 系统生命周期-- ECS优化缓存行：怎样提高缓冲区命中率，每个对象只加载xy坐标和旋转一共12b，那么一个缓存行能存五个对象，浪费64-21*5 = 4b ECS和传统游戏对象：ECS：Entity（实体）、Component（组件）、System（系统） 传统： 12345678public class Game : MonoBehaviour&#123; public int x; private void Update() &#123; x++; &#125;&#125; ECS： 123456789101112131415public struct GameComponentData : IComponentData // 组件 //结构体只保存数据，不能写逻辑&#123; public int x;&#125;public class MyGameSystem : ComponentSystem //在System里找关心的组件&#123; protected override void OnUpdate() &#123; this.Entities.ForEach((ref GameComponentData data) =&gt; &#123; data.x++; &#125;); &#125;&#125; 原型Archtype：即使不同的实体Entity，只要组件相同都会保存在原型ArcheType。 ArcheType是16KB的数组容器。 栈帧：栈上会保留值类型数据和指向堆的指针。 组件与共享组件：值类型组件和共享类型组件。 System可以找到它关心的组件去遍历。 Component System在Main Thread，Job Component System(JCS)可以在多线程。 Main Thread–JCS &gt;&gt;&gt; Worker Thread–Job, Job, Job…… JobSystem应用：ECS实例：ArcheType Chunk容量16KB，包含Trees #1, Trees #2, Rocks #1, Big Enemies #1, Small Enemies #1, Small Enemies #2, Query出符合条件的实体组件，大敌人、小敌人统一Update（相比Rocks，Trees更感兴趣） 汇编指令：mov指令：内存中数据传到寄存器/寄存器数据传到另一寄存器 mov ax 8 数据-&gt;寄存器 mov ax bx 寄存器-&gt;寄存器 SIMD：没听懂用来干嘛 SIMD指令优化总结： 避免代码出现分支预测（会打断SIMD的向量化指令），使用math.select和math.lerp代替分支预测 使用float4 bool4等代替float bool 使用m128自己组织128位数据 编译后尽量使用v开头指令，结尾尽量是ps指令而不是ss指令 Burst编译器：Burst只支持值类型数据的编译，不支持引用类型数据编译（因为C#的GC做的不好）。 Burst编译器是以LLVM为基础的后端编译技术。 怎么启动Burst编译器？在Job上面加上[BurstCompile]，如果在Job外怎么工作呢？使用有一个限制是需要静态方法 12345678910111213141516[BurstCompile]public class MyClass&#123; [BurstCompile] public static float add(float a, float b) &#123; return a * b; &#125; [BurstCompile] &#123; public static unsafe void dot(float3* a, float3* b, float* c) &#123; *c = math.dot(*a, *b); &#125; &#125;&#125; Unity.mathematics数学库：提供矢量类型（float4 float3…）可直接映射到硬件SIMD寄存器 Math类也提供了直接映射到硬件SIMD寄存器 原本CPU一个一个计算的有了SIMD可以一次性计算 Job多线程计算：12345678910111213141516171819202122[BurstCompile]public struct MyJob1 : IJob&#123; [ReadOnly] public int left; [ReadOnly] public int right; [WriteOnly] public NativeArray&lt;int&gt; @out; public Execute() &#123; @out[0] = left * right; &#125;&#125;private void Start()&#123; MyJob1 myJob = new MyJob1(); myJob.left = 2; myJob.right = 3; myJob.@out = new NativeArray&lt;int&gt;(1, Allocator.TempJob); myJob.Schedule().Complete(); //在一个子线程中计算并且等待完成 Debug.Log(myJob.@out[0]); // log 6; myJob.@out.Dispose();&#125; 1234567891011121314151617181920212223// IJobFor[BurstCompile]public struct MyJob2 : IJobFor&#123; public NativeArray&lt;int&gt; left; [ReadOnly] public NativeArra&lt;int&gt; right; public void Execute(int index) &#123; left[index] = left[index] * right[index]; //输出线程ID和当前执行的索引 Debug.Log(System.Threading.Thread.CurrentThread.ManagedThreadId + &quot;,&quot; + index); &#125;&#125;private void start()&#123; MyJob2 myJob = new MyJob2(); myJob.left = new NativeArray&lt;int&gt;(100, Allocator.TempJob); myJob.right = new NativeArray&lt;int&gt;(100, Allocator.TempJob); myJob.Schedule(myJob.left.Length, new JobHandle()).Complete(); //实际上是在一个子线程里面开了个for循环，Schedule是在一个子线程中执行，可以保证顺序 myJob.left.Dispose(); myJob.right.Dispose();&#125; Schedule和ScheduleParallel对比： 12//ScheduleParallel可以在多个子线程中并行运行，不保证顺序myJob.ScheduleParallel(myJob.left.Length, 64, new JobHandle()).Complete(); IJobFor和IJobParallelFor 1234567891011121314151617181920212223[BurstCompile]public struct MyJob2 : IJobParallelFor&#123; public NativeArray&lt;int&gt; left; [ReadOnly] public NativeArra&lt;int&gt; right; public void Execute(int index) &#123; left[index] = left[index] * right[index]; //输出线程ID和当前执行的索引 Debug.Log(System.Threading.Thread.CurrentThread.ManagedThreadId + &quot;,&quot; + index); &#125;&#125;private void start()&#123; MyJob2 myJob = new MyJob2(); myJob.left = new NativeArray&lt;int&gt;(100, Allocator.TempJob); myJob.right = new NativeArray&lt;int&gt;(100, Allocator.TempJob); //因为接口是IJobParallelFor，这里的Schedule就完全是并行执行不保证顺序了(注意参数有些不同，多了个“64”) myJob.Schedule(myJob.left.Length, 64, new JobHandle()).Complete(); myJob.left.Dispose(); myJob.right.Dispose();&#125; Complete是实现在主线程等待执行的结果 myJob.Schedule和myJob.Run对比：Schedule是在多核子线程中并行计算，Run是完全在主线程执行 Job的处理依赖关系： 我有Job1和Job2，怎么并行执行快一些？ 1234567891011121314151617MyJob2 myJob1 = new MyJob2();MyJob3 myJob2 = new MyJob3();//同时并行执行myJob1.Schedule(100, 64);myJob2.Schedule(100, 64);//Job1执行完毕后再并行执行Job2//缺点是要在主线程等待Job1结束(因为用了Complete())myJob1.Schedule(100, 64).Complete();myJob2.Schedule(100, 64); //设置Job2依赖Job1，这样不需要在主线程等待//JobHandle和依赖项：调用Schedule方法时会返回JobHandle，可以用Job1的JobHandle作为Job2的依赖项JobHandle jobHandle = new JobHandle();JobHandle scheduleJobDependencyJob = myJob1.Schedule(100, 64, jobHandle);myJob2.Schedule(100, 64, scheduleJobDependencyJob).Complete(); 设计模式-组合模式：系统生命周期：OnCreate(), OnStartRunning(), OnUpdate(), OnStopRunning(), OnDestory()","categories":[{"name":"Unity","slug":"Unity","permalink":"https://chasencenge.github.io/categories/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://chasencenge.github.io/tags/Unity/"}]},{"title":"本地代码提交至git","slug":"本地代码提交至git","date":"2019-11-20T15:02:36.000Z","updated":"2020-10-26T09:28:15.707Z","comments":true,"path":"2019/11/20/本地代码提交至git/","link":"","permalink":"https://chasencenge.github.io/2019/11/20/本地代码提交至git/","excerpt":"本地更新如何提交至GitHub","text":"本地更新如何提交至GitHub for first use1234567git init ***init .git*** git status ***check files to be added to the local repository*** git add xxx ***add files to repo*** git commit -m &quot;commit description&quot; ***commit to repo*** git remote add origin git@github.com:mobinets/hyblora.git ***link local repo to github*** git pull --rebase origin master ***pull = fetch + merge*** git push -u origin master ***upload*** not first use repo123git add xxx git commit -m &quot;commit discription&quot; git push -u origin master","categories":[{"name":"Git","slug":"Git","permalink":"https://chasencenge.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://chasencenge.github.io/tags/Git/"}]},{"title":"ParticalFilter(粒子滤波算法)","slug":"ParticalFilter(粒子滤波算法)","date":"2019-09-23T05:36:58.000Z","updated":"2020-07-20T02:36:54.957Z","comments":true,"path":"2019/09/23/ParticalFilter(粒子滤波算法)/","link":"","permalink":"https://chasencenge.github.io/2019/09/23/ParticalFilter(粒子滤波算法)/","excerpt":"粒子滤波算法","text":"粒子滤波算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182import numpy as npimport scipy as scipyfrom numpy.random import uniformimport scipy.statsnp.set_printoptions(threshold=3)np.set_printoptions(suppress=True)import cv2def drawLines(img, points, r, g, b): cv2.polylines(img, [np.int32(points)], isClosed=False, color=(r, g, b))def drawCross(img, center, r, g, b): d = 5 t = 2 LINE_AA = cv2.LINE_AA if cv2.__version__[0] == '3' else cv2.CV_AA color = (r, g, b) ctrx = center[0,0] ctry = center[0,1] cv2.line(img, (ctrx - d, ctry - d), (ctrx + d, ctry + d), color, t, LINE_AA) cv2.line(img, (ctrx + d, ctry - d), (ctrx - d, ctry + d), color, t, LINE_AA) def mouseCallback(event, x, y, flags,null): global center global trajectory global previous_x global previous_y global zs center=np.array([[x,y]]) trajectory=np.vstack((trajectory,np.array([x,y]))) #noise=sensorSigma * np.random.randn(1,2) + sensorMu if previous_x &gt;0: heading=np.arctan2(np.array([y-previous_y]), np.array([previous_x-x ])) if heading&gt;0: heading=-(heading-np.pi) else: heading=-(np.pi+heading) distance=np.linalg.norm(np.array([[previous_x,previous_y]])-np.array([[x,y]]) ,axis=1) std=np.array([2,4]) u=np.array([heading,distance]) predict(particles, u, std, dt=1.) zs = (np.linalg.norm(landmarks - center, axis=1) + (np.random.randn(NL) * sensor_std_err)) update(particles, weights, z=zs, R=50, landmarks=landmarks) indexes = systematic_resample(weights) resample_from_index(particles, weights, indexes) previous_x=x previous_y=y WIDTH=800HEIGHT=600WINDOW_NAME=\"Particle Filter\"#sensorMu=0#sensorSigma=3sensor_std_err=5def create_uniform_particles(x_range, y_range, N): particles = np.empty((N, 2)) particles[:, 0] = uniform(x_range[0], x_range[1], size=N) particles[:, 1] = uniform(y_range[0], y_range[1], size=N) return particlesdef predict(particles, u, std, dt=1.): N = len(particles) dist = (u[1] * dt) + (np.random.randn(N) * std[1]) particles[:, 0] += np.cos(u[0]) * dist particles[:, 1] += np.sin(u[0]) * dist def update(particles, weights, z, R, landmarks): weights.fill(1.) for i, landmark in enumerate(landmarks): distance=np.power((particles[:,0] - landmark[0])**2 +(particles[:,1] - landmark[1])**2,0.5) weights *= scipy.stats.norm(distance, R).pdf(z[i]) weights += 1.e-300 # avoid round-off to zero weights /= sum(weights) def neff(weights): return 1. / np.sum(np.square(weights))def systematic_resample(weights): N = len(weights) positions = (np.arange(N) + np.random.random()) / N indexes = np.zeros(N, 'i') cumulative_sum = np.cumsum(weights) i, j = 0, 0 while i &lt; N and j&lt;N: if positions[i] &lt; cumulative_sum[j]: indexes[i] = j i += 1 else: j += 1 return indexes def estimate(particles, weights): pos = particles[:, 0:1] mean = np.average(pos, weights=weights, axis=0) var = np.average((pos - mean)**2, weights=weights, axis=0) return mean, vardef resample_from_index(particles, weights, indexes): particles[:] = particles[indexes] weights[:] = weights[indexes] weights /= np.sum(weights) x_range=np.array([0,800])y_range=np.array([0,600])#Number of partcilesN=400landmarks=np.array([ [144,73], [410,13], [336,175], [718,159], [178,484], [665,464] ])NL = len(landmarks)particles=create_uniform_particles(x_range, y_range, N)weights = np.array([1.0]*N)# Create a black image, a window and bind the function to windowimg = np.zeros((HEIGHT,WIDTH,3), np.uint8)cv2.namedWindow(WINDOW_NAME)cv2.setMouseCallback(WINDOW_NAME,mouseCallback)center=np.array([[-10,-10]])trajectory=np.zeros(shape=(0,2))robot_pos=np.zeros(shape=(0,2))previous_x=-1previous_y=-1DELAY_MSEC=50while(1): cv2.imshow(WINDOW_NAME,img) img = np.zeros((HEIGHT,WIDTH,3), np.uint8) drawLines(img, trajectory, 0, 255, 0) drawCross(img, center, r=255, g=0, b=0) #landmarks for landmark in landmarks: cv2.circle(img,tuple(landmark),10,(255,0,0),-1) #draw_particles: for particle in particles: cv2.circle(img,tuple((int(particle[0]),int(particle[1]))),1,(255,255,255),-1) if cv2.waitKey(DELAY_MSEC) &amp; 0xFF == 27: break cv2.circle(img,(10,10),10,(255,0,0),-1) cv2.circle(img,(10,30),3,(255,255,255),-1) cv2.putText(img,\"Landmarks\",(30,20),1,1.0,(255,0,0)) cv2.putText(img,\"Particles\",(30,40),1,1.0,(255,255,255)) cv2.putText(img,\"Robot Trajectory(Ground truth)\",(30,60),1,1.0,(0,255,0)) drawLines(img, np.array([[10,55],[25,55]]), 0, 255, 0) cv2.destroyAllWindows() 如何安装依赖并运行打开anaconda prompt 1234conda create -n Filters python=3conda activate Filtersconda install -c menpo opencv3conda install numpy scipy matplotlib sympy cd python_codepython partical.pypython partical_v2.py","categories":[{"name":"Python","slug":"Python","permalink":"https://chasencenge.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://chasencenge.github.io/tags/Python/"}]},{"title":"Hexo发布","slug":"Hexo发布","date":"2019-09-14T15:52:50.000Z","updated":"2020-07-20T02:28:34.779Z","comments":true,"path":"2019/09/14/Hexo发布/","link":"","permalink":"https://chasencenge.github.io/2019/09/14/Hexo发布/","excerpt":"如何发布Hexo博客","text":"如何发布Hexo博客 hexo文件夹中，git bash here hexo new ‘’ hexo clean hexo g hexo s hexo d","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://chasencenge.github.io/tags/hexo/"}]},{"title":"Python---yield关键字","slug":"Python的yield关键字","date":"2019-07-25T06:59:22.000Z","updated":"2020-07-20T02:54:05.198Z","comments":true,"path":"2019/07/25/Python的yield关键字/","link":"","permalink":"https://chasencenge.github.io/2019/07/25/Python的yield关键字/","excerpt":"python中yield关键字的用法","text":"python中yield关键字的用法 迭代(iteration)与可迭代(iterable)使用容器时逐个获取元素的过程为迭代。 哪些类型是可迭代的 python中的顺序类型： list, tuple(元组，列表可修改元组不可修改，列表用中括号元组用小括号), string. dict, set, file. 某类对象提供了 __iter__() 或者 __getitem__() 方法. 迭代器对迭代器不断调用next()方法，可依次获取下一个元素，迭代器__iter__()方法返回迭代器自身，因此迭代器也是可迭代的。 迭代器协议(iterator protocol)一个容器提供__iter__()方法，该方法能返回一个能逐个访问容器内所有元素的迭代器，则该容器实现了迭代器协议。 python处理for循环的过程12for x in something: print(x) 处理for循环首先调用内建函数iter(something),内建函数调用something.__iter__(),返回something对应的迭代器，然后for循环会调用内建函数next()，作用在迭代器上获取迭代器的下一个元素，并赋值给x 生成器函数(generaor function)和生成器(generator)如果一个函数包含 yield 表达式，那么它是一个生成器函数；调用它会返回一个特殊的迭代器，称为生成器。 生成器函数被调用后，其函数体内的代码并不会立即执行，而是返回一个生成器（generator-iterator）。当返回的生成器调用成员方法时，相应的生成器函数中的代码才会执行。 “下一个yield表达式”调用 generator.next() 时，生成器函数会从当前位置开始执行到下一个 yield 表达式。这里的「下一个」指的是执行逻辑的下一个。 12345678910111213141516def f123(): yield 1 yield 2 yield 3for item in f123(): # 1, 2, and 3, will be printed print(item)def f13(): yield 1 while False: yield 2 yield 3for item in f13(): # 1 and 3, will be printed print(item) 使用 send() 方法与生成器函数通信12345678910def func(): x = 1 while True: y = (yield x) x += ygeniter = func()geniter.next() # 1geniter.send(3) # 4geniter.send(10)# 14 生成器函数 func 用 yield 表达式，将处理好的 x 发送给生成器的调用者；与此同时，生成器的调用者通过 send 函数，将外部信息作为生成器函数内部的 yield 表达式的值，保存在 y 当中，并参与后续的处理。 yield的好处顺序访问容器内的前五个元素： way1:获取所有元素然后取前五 way2:逐个迭代，至第五个元素 假设对于一个func(),返回值为列表，调用者对其返回值只有逐个迭代： 若等函数生成所有元素可能需要很长时间 使用yield把func()变成一个生成器函数，每次产生一个元素，可以节省开销","categories":[{"name":"Python","slug":"Python","permalink":"https://chasencenge.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://chasencenge.github.io/tags/Python/"}]},{"title":"Gradle相关知识(转载自Bonker)","slug":"Gradle相关知识(转载自Bonker)","date":"2019-07-18T08:38:29.000Z","updated":"2020-07-20T02:27:58.584Z","comments":true,"path":"2019/07/18/Gradle相关知识(转载自Bonker)/","link":"","permalink":"https://chasencenge.github.io/2019/07/18/Gradle相关知识(转载自Bonker)/","excerpt":"关于Android开发中的Gradle","text":"关于Android开发中的Gradle (转载自Bonker）原文链接：https://www.cnblogs.com/Bonker/p/5619458.html 什么是Gradle简单的说，Gradle是一个构建工具，它是用来帮助我们构建app的，构建包括编译、打包等过程。我们可以为Gradle指定构建规则，然后它就会根据我们的“命令”自动为我们构建app。Android Studio中默认就使用Gradle来完成应用的构建。有些同学可能会有疑问：”我用AS不记得给Gradle指定过什么构建规则呀，最后不还是能搞出来个apk。“ 实际上，app的构建过程是大同小异的，有一些过程是”通用“的，也就是每个app的构建都要经历一些公共步骤。因此，在我们在创建工程时，Android Studio自动帮我们生成了一些通用构建规则，很多时候我们甚至完全不用修改这些规则就能完成我们app的构建。 有些时候，我们会有一些个性化的构建需求，比如我们引入了第三方库，或者我们想要在通用构建过程中做一些其他的事情，这时我们就要自己在系统默认构建规则上做一些修改。这时候我们就要自己向Gradle”下命令“了，这时候我们就需要用Gradle能听懂的话了，也就是Groovy。Groovy是一种基于JVM的动态语言，关于它的具体介绍，感兴趣的同学可以文末参考”延伸阅读“部分给出的链接。 我们在开头处提到“Gradle是一种构建工具”。实际上，当我们想要更灵活的构建过程时，Gradle就成为了一个编程框架——我们可以通过编程让构建过程按我们的意愿进行。也就是说，当我们把Gradle作为构建工具使用时，我们只需要掌握它的配置脚本的基本写法就OK了；而当我们需要对构建流程进行高度定制时，就务必要掌握Groovy等相关知识了。限于篇幅，本文只从构建工具使用者的角度来介绍Gradle的一些最佳实践，在文末“延伸阅读”部分给出了几篇高质量的深入介绍Gradle的文章，其中包含了Groovy等知识的介绍。 Gradle的基本组分Project与Task在Gradle中，每一个待构建的工程是一个Project，构建一个Project需要执行一系列Task，比如编译、打包这些构建过程的子过程都对应着一个Task。具体来说，一个apk文件的构建包含以下Task：Java源码编译、资源文件编译、Lint检查、打包以生成最终的apk文件等等。 插件插件的核心工作有两个：一是定义Task；而是执行Task。也就是说，我们想让Gradle能正常工作，完成整个构建流程中的一系列Task的执行，必须导入合适的插件，这些插件中定义了构建Project中的一系列Task，并且负责执行相应的Task。 在新建工程的app模块的build.gradle文件的第一行，往往都是如下这句： apply plugin: ‘com.android.application’这句话的意思就是应用“com.android.application“这个插件来构建app模块，app模块就是Gradle中的一个Project。也就是说，这个插件负责定义并执行Java源码编译、资源文件编译、打包等一系列Task。实际上”com.android.application”整个插件中定义了如下4个顶级任务： assemble: 构建项目的输出（apk） check: 进行校验工作 build: 执行assemble任务与check任务 clean: 清除项目的输出 当我们执行一个任务时，会自动执行它所依赖的任务。比如，执行assemble任务会执行assembleDebug任务和assembleRelease任务，这是因为一个Android项目至少要有debug和release这两个版本的输出。 Gradle配置文件我们在Android Studio中新建一个工程，可以得到如下的工程结构图： 上面我们说过，Android Studio中的一个Module即为Gradle中的一个Project。上图的app目录下，存在一个build.gradle文件，代表了app Module的构建脚本，它定义了应用于本模块的构建规则。我们可以看到，工程根目录下也存在一个build.gradle文件，它代表了整个工程的构建，其中定义了适用于这个工程中所有模块的构建规则。 接下来我们介绍一下上图中其他几个Gradle配置文件： gradle.properties: 从它的名字可以看出，这个文件中定义了一系列“属性”。实际上，这个文件中定义了一系列供build.gradle使用的常量，比如keystore的存储路径、keyalias等等。 gradlew与gradlew.bat: gradlew为Linux下的shell脚本，gradlew.bat是Windows下的批处理文件。gradlew是gradle wrapper的缩写，也就是说它对gradle的命令进行了包装，比如我们进入到指定Module目录并执行“gradlew.bat assemble”即可完成对当前Module的构建（Windows系统下）。 local.properties: 从名字就可以看出来，这个文件中定义了一些本地属性，比如SDK的路径。 settings.gradle: 假如我们的项目包含了不只一个Module时，我们想要一次性构建所有Module以完成整个项目的构建，这时我们需要用到这个文件。比如我们的项目包含了ModuleA和ModuleB这两个模块，则这个文件中会包含这样的语句：include ‘:ModuleA’, ‘:ModuleB’。 构建脚本首先我们来看一下工程目录下的build.gradle，它指定了真个整个项目的构建规则，它的内容如下： &#123;123456789101112131415 repositories &#123; jcenter() //构建脚本中所依赖的库都在jcenter仓库下载 &#125; dependencies &#123; //指定了gradle插件的版本 classpath &apos;com.android.tools.build:gradle:1.5.0&apos; &#125;&#125;allprojects &#123; repositories &#123; //当前项目所有模块所依赖的库都在jcenter仓库下载 jcenter() &#125;&#125; 我们再来简单介绍下app模块的build.gradle的内容： 12345678910111213141516171819202122232425262728//加载用于构建Android项目的插件apply plugin: &apos;com.android.application&apos;android &#123; //构建Android项目使用的配置 compileSdkVersion 23 //指定编译项目时使用的SDK版本 buildToolsVersion &quot;23.0.1&quot; //指定构建工具的版本 defaultConfig &#123; applicationId &quot;com.absfree.debugframwork&quot; //包名 minSdkVersion 15 //指定支持的最小SDK版本 targetSdkVersion 23 //针对的目标SDK版本 versionCode 1 versionName &quot;1.0&quot; &#125; buildTypes &#123; //针对不同的构建版本进行一些设置 release &#123; //对release版本进行的设置 minifyEnabled false //是否开启混淆 proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; //指定混淆文件的位置 &#125; &#125;&#125;dependencies &#123; //指定当前模块的依赖 compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) testCompile &apos;junit:junit:4.12&apos; compile &apos;com.android.support:appcompat-v7:23.1.1&apos; compile &apos;com.android.support:design:23.1.1&apos;&#125; 常见配置整个工程的build.gradle通常不需我们改动，这里我们介绍下一些对模块目录下build.gradle文件的常见配置。 依赖第三方库当我们的项目中用到了了一些第三方库时，我们就需要进行一些配置，以保证能正确导入相关依赖。设置方法很简单，比如我们在app模块中中用到了Fresco，只需要在build.gradle文件中的dependencies块添加如下语句： 1234dependencies &#123; ... compile &apos;com.facebook.fresco:fresco:0.11.0&apos;&#125; 这样一来，Gradle会自动从jcenter仓库下载我们所需的第三方库并导入到项目中。 导入本地jar包在使用第三方库时，除了像上面那样从jcenter仓库下载，我们还可以导入本地的jar包。配置方法也很简单，只需要先把jar文件添加到app\\libs目录下，然后在相应jar文件上单击右键，选择“Ad As Library”。然后在build.gradle的dependencies块下添加如下语句： compile files(‘libs/xxx.jar’)实际上我们可以看到，系统为我们创建的build.gradle中就已经包含了如下语句： compile fileTree(dir: ‘libs’, include: [‘*.jar’]) 这句话的意思是，将libs目录下的所有jar包都导入。所以实际上我们只需要把jar包添加到libs目录下并“Ad As Library”即可。 依赖其它模块假设我们的项目包含了多个模块，并且app模块依赖other模块，那么我们只需app\\build.gradle的denpendencies块下添加如下语句： compile project(‘:other’) 构建输出为aar文件通常我们构建的输出目标都是apk文件，但如果我们的当前项目时Android Library，我们的目标输出就是aar文件。要想达到这个目的也很容易，只需要把build.gradle的第一句改为如下： apply plugin:’com.android.library’这话表示我们使用的插件不再是构建Android应用的插件，而是构建Android Library的插件，这个插件定义并执行用于构建Android Library的一系列Task。 自动移除不再使用的资源只需进行如下配置： 1234567891011android &#123; ... &#125; buildTypes &#123; release &#123; ... shrinkResources true ... &#125; &#125;&#125; 忽略Lint错误在我们构建Android项目的过程中，有时候会由于Lint错误而终止。当这些错误来自第三方库中时，我们往往想要忽略这些错误从而继续构建进程。这时候，我们可以只需进行如下配置： 123456android &#123; ... lintOptions &#123; abortOnError false &#125;&#125; 集成签名配置在构建release版本的Android项目时，每次都手动导入签名文件，键入密码、keyalias等信息十分麻烦。通过将签名配置集成到构建脚本中，我们就不必每次构建发行版本时都手动设置了。具体配置如下： 1234567891011121314151617signingConfigs &#123; myConfig &#123; //将&quot;xx&quot;替换为自己的签名文件信息 storeFile file(&quot;xx.jks&quot;) storePassword &quot;xx&quot; keyAlias &quot;xx&quot; keyPassword &quot;xx&quot; &#125;&#125;android &#123; buildTypes &#123; release &#123; signingConfig signingConfigs.myConfig //在release块中加入这行 ... &#125; &#125; ...&#125; 真实开发中，我们不应该把密码等信息直接写到build.gradle中，更好的做法是放在gradle.properties中设置： 1234RELEASE_STOREFILE=xxx.jks RELEASE_STORE_PASSWORD = xxxRELEASE_KEY_ALIAS=xxxRELEASE_KEY_PASSWORD=xxx 然后在build.gradle中直接引用即可： 12345678signingConfigs &#123; myConfig &#123; storeFilefile(RELEASE_STOREFILE) storePassword RELEASE_STORE_PASSWORD keyAlias RELEASE_KEY_ALIAS keyPassword RELEASE_KEY_PASSWORD &#125;&#125; 关于Gradle的其他配置方法大家可以参考“延伸阅读”部分的“Gradle最佳实践”。","categories":[{"name":"Android","slug":"Android","permalink":"https://chasencenge.github.io/categories/Android/"}],"tags":[{"name":"Gradle","slug":"Gradle","permalink":"https://chasencenge.github.io/tags/Gradle/"}]},{"title":"Linux远程登录及服务器配置","slug":"Linux远程登录","date":"2019-07-17T13:45:43.000Z","updated":"2020-07-20T02:35:41.509Z","comments":true,"path":"2019/07/17/Linux远程登录/","link":"","permalink":"https://chasencenge.github.io/2019/07/17/Linux远程登录/","excerpt":"Linux远程登录及服务器配置","text":"Linux远程登录及服务器配置 ##Linux远程登录原理安装telnet远程客户端登录工具的客户机通过23（默认）端口连接到Linux服务器，通过telnet将远程客户机上命令传到服务器执行并反馈。###telnet软件包安装sudo apt-get install inetutils-telnetd(ubuntu没有默认安装Telnet软件包)","categories":[{"name":"Linux","slug":"Linux","permalink":"https://chasencenge.github.io/categories/Linux/"}],"tags":[{"name":"远程登录","slug":"远程登录","permalink":"https://chasencenge.github.io/tags/远程登录/"}]},{"title":"可见光认证相关","slug":"可见光认证","date":"2019-07-05T03:09:43.000Z","updated":"2020-07-20T02:41:01.059Z","comments":true,"path":"2019/07/05/可见光认证/","link":"","permalink":"https://chasencenge.github.io/2019/07/05/可见光认证/","excerpt":"基于可见光的无线网络认证","text":"基于可见光的无线网络认证 2019-07-05 802.1x认证过程： 当用户有访问网络需求时打开802.1X客户端程序，输入已经申请、登记过的用户名和密码，发起连接请求（EAPOL-Start报文）。此时，客户端程序将发出请求认证的报文给设备端，开始启动一次认证过程。 设备端收到请求认证的数据帧后，将发出一个请求帧（EAP-Request/Identity报文）要求用户的客户端程序发送输入的用户名。 客户端程序响应设备端发出的请求，将用户名信息通过数据帧（EAP-Response/Identity报文）发送给设备端。设备端将客户端发送的数据帧经过封包处理后（RADIUS Access-Request报文）送给认证服务器进行处理。 RADIUS服务器收到设备端转发的用户名信息后，将该信息与数据库中的用户名表对比，找到该用户名对应的密码信息，用随机生成的一个加密字对它进行加密处理，同时也将此加密字通过RADIUS Access-Challenge报文发送给设备端，由设备端转发给客户端程序。 客户端程序收到由设备端传来的加密字（EAP-Request/MD5 Challenge报文）后，用该加密字对密码部分进行加密处理（此种加密算法通常是不可逆的），生成EAP-Response/MD5 Challenge报文，并通过设备端传给认证服务器。 RADIUS服务器将收到的已加密的密码信息（RADIUS Access-Request报文）和本地经过加密运算后的密码信息进行对比，如果相同，则认为该用户为合法用户，反馈认证通过的消息（RADIUS Access-Accept报文和EAP-Success报文）。 设备收到认证通过消息后将端口改为授权状态，允许用户通过端口访问网络。在此期间，设备端会通过向客户端定期发送握手报文的方法，对用户的在线情况进行监测。缺省情况下，两次握手请求报文都得不到客户端应答，设备端就会让用户下线，防止用户因为异常原因下线而设备无法感知。 客户端也可以发送EAPOL-Logoff报文给设备端，主动要求下线。设备端把端口状态从授权状态改变成未授权状态，并向客户端发送EAP-Failure报文。 关于WiFidog：Portal认证，通常也会叫Web认证，未认证用户上网时，设备强制用户登录到特定站点，用户可以免费访问其中的服务。当用户需要使用互联网中的其它信息时，必须在门户网站进行认证，只有认证通过后才可以使用互联网资源。现金很多中国移动CMCC、中国联通、中国电信ChinaNet的WIFI都使用这种认证接入方式。 在OpenWRT上实现Portal认证，实际上早已有解决方案： chillispot，但原维护作者停止更新，被chillispot.info接管继续开发； coova-chilli，它是基于chillispot开发拓展的，功能最为强大；可以去官方看一下Coova-chilli； wifidog，前两个由于原维护作者停止更新，笔者也没有深入研究，重点钻研了wifidog，Wifidog也是OpenWRT和DD-WRT中实现Portal比较出名的。但是，Wifidog只是实现AP认证网关，需要配合外部的Portal服务器才能使用，Portal主要是提供认证所需的WEB页面且实现认证计费等的功能。虽然这也有很多商用解决方案，例如wiwiz、wifiap等，但是这些商业解决方案的目标都是盈利，即使可以免费使用，免费账号的功能和权限都受到了很大的限制，例如不能自定义页面，Web认证页面有广告等等。有条件的人可能打算自己搭建Portal服务器，但是看看Wifidog的官方Wiki，对搭建过程实在是难以理解。后来，笔者发现网络上还有一个 authpuppy方案 ，官方网站 www.authpuppy.org ，是一个已实现好的Wifidog认证服务器，里面包含各种插件供你使用，官方的安装过程也很简单，如果你懂的HTML和面向对象编程的相关知识且拥有一个服务器，可以自行修改认证页面，使用authpuppy也是一个不错的方案。 如何 自行编写一个轻量级的Web Portal认证服务器 ： Wifidog的工作原理： 客户端发出初始化请求，比如访问 www.dqrun.com 。 网关的防火墙规则将这个请求重定向到本地网关的端口上。这个端口是Wifidog监听的端口。 Wfidog提供一个HTTP重定向回复，重定向到Web认证页面，重定向的Url的Querystring中包含了Gateway的ID，Gateway的FQDN以及其他的信息。 用户向认证服务器发出认证请求 1234gw_id=[GatewayID, default: “default”]gw_address=[GatewayAddress, internal IP of router]gw_port=[GatewayPort, port that wifidog Gateway is listening on]url=[user requested url]； 网关返回一个（可以是自定义的）splash（也称作“登录”）页面。 用户提供他的凭据信息，比如用户名和密码。 成功认证的话，客户端将会被重定向到网关的自己的web页面上，并且带有一个认证凭据（一个一次性的token），内容比如：http://GatewayIP:GatewayPort/wifidog/auth?token=[auth token]； 用户就是用获取到的凭据访问网关。 网关去认证服务器询问token的有效性。 认证服务器确认token的有效性。 网关发送重定向给客户端，以从认证服务器上获取 成功提示页面，重定向到 http://portal_server:port/portal_script 这个位置。 认证服务器通知客户请求成功，可以上网了。 待完成工作：装wifidog ，配置:1）监听端口 2)服务器地址 3）5个脚本的地址(login, portal, msg, ping, auth) 配置方法：远程登陆openwrt: ssh root@192.168.1.1， 然后修改/etc/wifidog.conf文件。 将笔记本搭建成服务器 添加对LED的频率提取功能 实现动态调节LED频率,将此功能添加至系统 2019/07/08 路由器刷openwrt系统恢复出厂：断电后，先按住reset再通电。登陆192.168.1.1（breed web），先点“恢复出厂”，选择“openwrt”；再点击“更新固件”，选中已下载好的openwrt镜像，进行固件更新。 解决路由器联网问题 设置密码：点击Go to password configuration...，敲入2遍新的路由器密码，点击页面最下面的 保存执行按钮，密码修改即时生效。 设置主机名和时区：System菜单的system进去，主机名改为自己希望的名称，时区设置为Asia/Shanghai，保存。 联网设置 :点击菜单Network中的第二项，可以选择2G或5G无线网络连接WIFI，按 scan扫描按钮，稍等出现列表中，选择自己(想通过这个路由连接)的WIFI，输入密码，按提交，然后稍等，按保存执行。 ubuntu16.04编译OpenWrt环境搭建： ubuntu下OpenWrt编译环境需要安装很多组件：sudo apt-get install gccsudo apt-get install g++sudo apt-get install binutilssudo apt-get install patchsudo apt-get install bzip2sudo apt-get install flexsudo apt-get install bisonsudo apt-get install makesudo apt-get install autoconfsudo apt-get install gettextsudo apt-get install texinfosudo apt-get install unzipsudo apt-get install sharutilssudo apt-get install subversionsudo apt-get install libncurses5-devsudo apt-get install ncurses-termsudo apt-get install zlib1g-devsudo apt-get install subversionsudo apt-get install git-coresudo apt-get install gawksudo apt-get install asciidocsudo apt-get install libz-dev当然安装之前最好先更新下组件包：sudo apt-get update逐个安装… 新建一个openwrt目录，使用命令：mkdir openwrtsudo chmod 777 openwrt接下来的所有命令都在/openwrt目录下运行 下载OpenWrt源码:git clone git://git.openwrt.org/openwrt/openwrt.git 添加软件扩展包：cd /home/ngmi/openwrt/openwrt/cp feeds.conf.default feeds.conf(将feeds.conf.default修改为feeds.conf) 更新扩展，安装扩展：./scripts/feeds update -a./scripts/feeds install -a 测试下编译环境，使用命令：make defconfig make menuconfig如果一切正常，会出现一个配置菜单，可以选择要编译的固件平台、型号，还能选择固件中要添加的功能和组件，至此编译环境就搭建好了。 在OpenWrt的路由器上安装Wifidog应用程序 在OpenWrt系统的源码文件下，编辑feeds.conf.default文件vim feeds.conf.default在其中增加一行：src-git wifidog https://github.com/wifidog/wifidog-gateway.git 然后更新，再安装：./scripts/feeds update -a./scripts/feeds install -a 终端执行编译命令make menuconfig 在Network/captive portals/下选择wifidog 就有选择 WiFiDog 这一项了 2019/07/09 配置服务器中遇到的问题问题： python3 manage.py runserver 0.0.0.0:8000123456789101112131415161718Traceback (most recent call last): File &quot;manage.py&quot;, line 22, in &lt;module&gt; execute_from_command_line(sys.argv) File &quot;/usr/local/lib/python3.5/dist-packages/django/core/management/__init__.py&quot;, line 381, in execute_from_command_line utility.execute() File &quot;/usr/local/lib/python3.5/dist-packages/django/core/management/__init__.py&quot;, line 375, in execute self.fetch_command(subcommand).run_from_argv(self.argv) File &quot;/usr/local/lib/python3.5/dist-packages/django/core/management/base.py&quot;, line 323, in run_from_argv self.execute(*args, **cmd_options) File &quot;/usr/local/lib/python3.5/dist-packages/django/core/management/commands/runserver.py&quot;, line 60, in execute super().execute(*args, **options) File &quot;/usr/local/lib/python3.5/dist-packages/django/core/management/base.py&quot;, line 364, in execute output = self.handle(*args, **options) File &quot;/home/ngmi/lightFreq-master/my_wifi_auth_server/django_pdb/management/commands/runserver.py&quot;, line 59, in handle and middleware not in settings.MIDDLEWARE_CLASSES): File &quot;/usr/local/lib/python3.5/dist-packages/django/conf/__init__.py&quot;, line 80, in __getattr__ val = getattr(self._wrapped, name)AttributeError: &apos;Settings&apos; object has no attribute &apos;MIDDLEWARE_CLASSES&apos; 解决方法： 1234middleware = 'django_pdb.middleware.PdbMiddleware' if ((pdb_option or settings.DEBUG) and middleware not in settings.MIDDLEWARE): settings.MIDDLEWARE += (middleware,) 由于Django版本的问题，需要将（lightFreq-master/my_wifi_auth_server/django_pdb/management/conmands/runserver.py）以上代码中原本的MIDDLEWARE_CLASSES改为MIDDLEWARE。 问题： HTTP_HOST header: '0.0.0.0:8000'. You may need to add '0.0.0.0' to ALLOWED_HOSTS.12Bad Request: /[09/Jul/2019 14:14:40] &quot;GET / HTTP/1.1&quot; 400 66219 进入http://0.0.0.0:8000页面显示Invalid…解决办法：将lightFreq-master/my_wifi_auth_server/Auth_server/settings.py文件中ALLOWED_HOSTS = [&#39;192.168.1.162&#39;,&#39;127.0.0.1&#39;]修改为ALLOWED_HOSTS = [&#39;*&#39;]","categories":[{"name":"Light Frequency Authenticate","slug":"Light-Frequency-Authenticate","permalink":"https://chasencenge.github.io/categories/Light-Frequency-Authenticate/"}],"tags":[{"name":"lightFre","slug":"lightFre","permalink":"https://chasencenge.github.io/tags/lightFre/"}]},{"title":"为Hexo的Next主题添加计数功能","slug":"为Hexo的Next主题添加计数功能","date":"2019-07-03T10:22:33.000Z","updated":"2020-07-20T02:43:23.877Z","comments":true,"path":"2019/07/03/为Hexo的Next主题添加计数功能/","link":"","permalink":"https://chasencenge.github.io/2019/07/03/为Hexo的Next主题添加计数功能/","excerpt":"blog中添加wordcount功能","text":"blog中添加wordcount功能 1.在根目录git bash： npm install hexo-wordcount --save 2.在主题配置文件(hexo\\themes\\next\\config.yml)中打开wordcount功能 # Post wordcount display settings # Dependencies: https://github.com/willin/hexo-wordcount post_wordcount: item_text: true wordcount: true min2read: true totalcount: true separated_meta: true3.修改 hexo\\themes\\next\\layout\\post.swig，将下面代码复制到文件中： &lt;span title=&quot;{{ __('post.wordcount') }}&quot;&gt; {{ wordcount(post.content) }} 字 &lt;/span&gt; &lt;span title=&quot;{{ __('post.min2read') }}&quot;&gt; {{ min2read(post.content) }} 分钟 &lt;/span&gt;","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://chasencenge.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://chasencenge.github.io/tags/Hexo/"}]}]}