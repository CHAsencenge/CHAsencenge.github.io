{"meta":{"title":"解字","subtitle":null,"description":"解字无果","author":"CHAsencenge","url":"https://chasencenge.github.io","root":"/"},"pages":[{"title":"关于","date":"2020-07-17T03:53:18.000Z","updated":"2020-07-17T09:52:44.212Z","comments":true,"path":"about/index.html","permalink":"https://chasencenge.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-07-07T02:56:17.000Z","updated":"2020-07-17T09:52:44.213Z","comments":true,"path":"categories/index.html","permalink":"https://chasencenge.github.io/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2020-07-17T03:52:56.000Z","updated":"2020-07-17T09:52:44.250Z","comments":true,"path":"links/index.html","permalink":"https://chasencenge.github.io/links/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-07-07T02:57:07.000Z","updated":"2020-07-17T09:52:44.250Z","comments":true,"path":"tags/index.html","permalink":"https://chasencenge.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"LeetCode每日刷题","slug":"LeetCode每日刷题","date":"2020-08-03T15:29:34.000Z","updated":"2020-08-04T02:48:21.625Z","comments":true,"path":"2020/08/03/LeetCode每日刷题/","link":"","permalink":"https://chasencenge.github.io/2020/08/03/LeetCode每日刷题/","excerpt":"","text":"415. 字符串相加实现两个字符串的数值相加，不能用类型转换 12345678910111213141516171819202122232425262728293031string addStrings(string num1, string num2) &#123; //双指针，双指针的“指针”不一定非得是指针类型，能做flag标记就行 int i = num1.length() - 1; int j = num2.length() - 1; string res; int multi = 1; //进位 int add = 0; while (i &gt;= 0 || j &gt;= 0 || add &gt; 0) &#123; int x = 0; int y = 0; if (i &gt;= 0) &#123; //两者相减得到的是int型 x = num1[i] - '0'; &#125; if (j &gt;= 0) &#123; y = num2[j] - '0'; &#125; int result = x + y + add; res.push_back('0' + result % 10); add = result / 10; i--; j--; &#125; //因为每次push_back是从低位到高位的，所以结果要翻转 reverse(res.begin(), res.end()); return res;&#125; 207. 课程表你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1] 给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？ 1234567输入: 2, [[1,0]] 输出: true解释: 总共有2门课程。学习课程1之前，你需要完成课程0。所以这是可能的输入: 2, [[1,0],[0,1]]输出: false解释: 总共有2门课程。学习课程1之前，你需要先完成课程0；并且学习课程0之前，你还应先完成课程1。这是不可能的 我们就可以将本题建模成一个求拓扑排序的问题了： 我们将每一门课看成一个节点 如果想要学习课程 A之前必须完成课程 B，那么我们从B到A连接一条有向边。这样以来，在拓扑排序中，B一定出现在 A的前面 思路： 考虑拓扑排序中最前面的节点，该节点一定不会有任何入边，也就是它没有任何的先修课程要求。当我们将一个节点加入答案中后，我们就可以移除它的所有出边，代表着它的相邻节点少了一门先修课程的要求。如果某个相邻节点变成了「没有任何入边的节点」，那么就代表着这门课可以开始学习了。按照这样的流程，我们不断地将没有入边的节点加入答案，直到答案中包含所有的节点（得到了一种拓扑排序）或者不存在没有入边的节点（图中包含环） 算法： 使用一个队列来进行广度优先搜索。初始时，所有入度为 00 的节点都被放入队列中，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。 在广度优先搜索的每一步中，我们取出队首的节点u： 我们将u放入答案中 我们移除 u的所有出边，也就是将u的所有相邻节点的入度减少1。如果某个相邻节点v的入度变为0，那么我们就将v放入队列中 在广度优先搜索的过程结束后。如果答案中包含了这n个节点，那么我们就找到了一种拓扑排序，否则说明图中存在环，也就不存在拓扑排序了 1234567891011121314151617181920212223242526272829303132333435363738394041bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123; //入度 in degree vector&lt;int&gt; indeg; vector&lt;vector&lt;int&gt;&gt; edges; //resize内的默认初始化值为0 indeg.resize(numCourses); edges.resize(numCourses); for (const auto&amp; info : prerequisites) &#123; //以info[1]为起始的边，指向info[0] edges[info[1]].push_back(info[0]); //info[0]的入度加一，指向它的是info[1] ++indeg[info[0]]; &#125; queue&lt;int&gt; q; for (int i = 0; i &lt; numCourses; i++) &#123; //把最开始入度为0的点push进去 if (indeg[i] == 0) &#123; q.push(i); &#125; &#125; int visited = 0; while (!q.empty()) &#123; visited++; int u = q.front(); q.pop(); for (int v : edges[u]) &#123; --indeg[v]; //如果去掉指向它的u之后，v点的入度变为0，那么push进队列 if (indeg[v] == 0) &#123; q.push(v); &#125; &#125; &#125; return visited == numCourses;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://chasencenge.github.io/categories/C/"},{"name":"Algorithm","slug":"C/Algorithm","permalink":"https://chasencenge.github.io/categories/C/Algorithm/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://chasencenge.github.io/tags/C/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/tags/Algorithm/"}]},{"title":"LeetCode top100刷题","slug":"LeetCode-top刷题","date":"2020-08-03T15:15:27.000Z","updated":"2020-08-04T16:36:01.715Z","comments":true,"path":"2020/08/03/LeetCode-top刷题/","link":"","permalink":"https://chasencenge.github.io/2020/08/03/LeetCode-top刷题/","excerpt":"","text":"1. 两数之和12345678910111213141516171819202122232425//暴力循环vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; resV&#123; 0, 0 &#125;; int find; int hasFound = 0; for (int i = 0; i &lt; nums.size() - 1; i++) &#123; resV[0] = i; find = target - nums[i]; for (int j = i + 1; j &lt; nums.size(); j++) &#123; if (nums[j] == find) &#123; resV[1] = j; hasFound = 1; break; &#125; &#125; if (hasFound == 1) &#123; break; &#125; &#125; return resV;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//先排序，再利用双指针遍历，初始i放首部，j放尾部，两数之和大于target的话j--，小于target的话i++，找到对应的i和jvector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; resV&#123; 0, 0 &#125;; vector&lt;int&gt; copyV = nums; int find; int hasFound = 0; sort(nums.begin(), nums.end()); // for(int k = 0; k &lt; nums.size(); k++) // &#123;cout &lt;&lt; nums[k] &lt;&lt; \" \";&#125; int i = 0; int j = nums.size() - 1; while (i != j &amp;&amp; hasFound == 0) &#123; if (target &gt; nums[i] + nums[j]) &#123; i++; &#125; else if (target &lt; nums[i] + nums[j]) &#123; j--; &#125; else &#123; //找到i和j还没结束，要根据nums[i], nums[j]找到排序前的数组中对应的原始下标 //found1防止数组中有相同的值k使得k + k = target导致只能（进入下面的if）更新resV[0]的值 //这样，如果在原数组中找到第一个k值时进入if，之后继续找到第二个k值的时候便不会再进入if重复更新resV[0]而导致resV[j]不被更新 int flag = 0, found1 = 0, label = 0; while (label != 2) &#123; if (copyV[flag] == nums[i] &amp;&amp; found1 == 0) &#123; label++; resV[0] = flag; found1 = 1; flag++; &#125; else if (copyV[flag] == nums[j]) &#123; label++; resV[1] = flag; flag++; &#125; else &#123; flag++; &#125; &#125; hasFound = 1; &#125; &#125; return resV;&#125; 2.两数相加给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和 您可以假设除了数字 0 之外，这两个数都不会以 0 开头 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; //结构体指针初始化的时候要new一个（创建不在栈上的对象用new） ListNode* res = new ListNode(-1); //temp用来移动，res保证最后return的时候找得到链表头部 ListNode* temp = res; ListNode* p = l1; ListNode* q = l2; int add = 0; int i; //处理对称长度部分 while (p != nullptr &amp;&amp; q != nullptr) &#123; i = (p-&gt;val + q-&gt;val + add) % 10; //每个next节点都需要new一下，确定有下一位再new下一位 temp-&gt;next = new ListNode(i); add = (p-&gt;val + q-&gt;val + add) / 10; temp = temp-&gt;next; p = p-&gt;next; q = q-&gt;next; &#125; //处理不对称部分 if (p != nullptr &amp;&amp; q == nullptr) &#123; while (p != nullptr) &#123; i = (p-&gt;val + add) % 10; temp-&gt;next = new ListNode(i); add = (p-&gt;val + add) / 10; temp = temp-&gt;next; p = p-&gt;next; &#125; &#125; else if (q != nullptr &amp;&amp; p == nullptr) &#123; while (q != nullptr) &#123; i = (q-&gt;val + add) % 10; temp-&gt;next = new ListNode(i); add = (q-&gt;val + add) / 10; temp = temp-&gt;next; q = q-&gt;next; &#125; &#125; else &#123; //这个if是处理l1和l2长度相同的情况下，最高位的进位 if (add != 0) &#123; temp-&gt;next = new ListNode(add); &#125; &#125; //这个if是处理l1和l2长度不相同的情况下，最高位的进位，也就是在上面if或者else if跑完之后进行的判断 if (add != 0) &#123; temp-&gt;next = new ListNode(add); &#125; return res-&gt;next;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://chasencenge.github.io/categories/C/"},{"name":"Algorithm","slug":"C/Algorithm","permalink":"https://chasencenge.github.io/categories/C/Algorithm/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://chasencenge.github.io/tags/C/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/tags/Algorithm/"}]},{"title":"LeetCode200周赛","slug":"LeetCode200周赛","date":"2020-08-02T14:18:15.000Z","updated":"2020-08-02T15:38:14.671Z","comments":true,"path":"2020/08/02/LeetCode200周赛/","link":"","permalink":"https://chasencenge.github.io/2020/08/02/LeetCode200周赛/","excerpt":"","text":"给你一个整数数组 arr ，以及 a、b 、c 三个整数。请你统计其中好三元组的数量 如果三元组 (arr[i], arr[j], arr[k]) 满足下列全部条件，则认为它是一个 好三元组 0 &lt;= i &lt; j &lt; k &lt; arr.length |arr[i] - arr[j]| &lt;= a |arr[j] - arr[k]| &lt;= b |arr[i] - arr[k]| &lt;= c 其中 |x| 表示 x 的绝对值 返回 好三元组的数量 1234567输入：arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3输出：4解释：一共有 4 个好三元组：[(3,0,1), (3,0,1), (3,1,1), (0,1,1)]输入：arr = [1,1,2,2,3], a = 0, b = 0, c = 1输出：0解释：不存在满足所有条件的三元组 123456789101112131415161718int countGoodTriplets(vector&lt;int&gt;&amp; arr, int a, int b, int c) &#123; int res = 0; for (int i = 0; i &lt; arr.size() - 2; i++) &#123; for (int j = i + 1; j &lt; arr.size() - 1; j++) &#123; for (int k = j + 1; k &lt; arr.size(); k++) &#123; //使用abs()需引用cmath头文件 if (abs(arr[i] - arr[j]) &lt;= a &amp;&amp; abs(arr[j] - arr[k]) &lt;= b &amp;&amp; abs(arr[i] - arr[k]) &lt;= c) &#123; res++; &#125; &#125; &#125; &#125; return res;&#125; 给你一个由 不同 整数组成的整数数组 arr 和一个整数 k 每回合游戏都在数组的前两个元素（即 arr[0] 和 arr[1] ）之间进行。比较 arr[0] 与 arr[1] 的大小，较大的整数将会取得这一回合的胜利并保留在位置 0 ，较小的整数移至数组的末尾。当一个整数赢得 k 个连续回合时，游戏结束，该整数就是比赛的 赢家 返回赢得比赛的整数 题目数据 保证 游戏存在赢家 123456789输入：arr = [3,2,1], k = 10输出：3解释：3 将会在前 10 个回合中连续获胜 输入：arr = [1,9,8,2,3,7,6,4,5], k = 7输出：9 输入：arr = [1,11,22,33,44,55,66,77,88,99], k = 1000000000输出：99 123456//vector操作a.erase(a.begin()+1,a.begin()+3); //包前不包后，删除第1、2个元素a.insert(a.begin()+1,5); //在a的第1个元素（从第0个算起）的位置插入数值5a.insert(a.begin()+1,3,5); //在a的第1个元素（从第0个算起）的位置插入3个数，其值都为5a.back(); //返回a的最后一个元素a.front(); //返回a的第一个元素 123456789101112131415161718192021222324252627282930//按命题逻辑操作vector，遇到超长数组同时超大K值时会超时int getWinner(vector&lt;int&gt;&amp; arr, int k) &#123; int num = 0; int res = arr[0]; if (k &gt; arr.size()) &#123; k = arr.size(); &#125; while (num &lt; k) &#123; if (arr[0] &gt; arr[1]) &#123; num++; int temp = arr[1]; arr.erase(arr.begin() + 1, arr.begin() + 2); arr.push_back(temp); &#125; else &#123; num = 1; int temp = arr[0]; res = arr[1]; arr.erase(arr.begin(), arr.begin() + 1); arr.push_back(temp); &#125; &#125; return res;&#125; 123456789101112131415161718192021222324252627282930//trick，不用按题述方式操作vector，从前向后遍历即可int getWinner(vector&lt;int&gt;&amp; arr, int k) &#123; int num = 0; int res = arr[0]; if (k &gt; arr.size()) &#123; k = arr.size(); &#125; for(int i = 0; i &lt; arr.size(); i++) &#123; if(arr[i]&gt;arr[i+1]) &#123; //直接修改arr[i+1]的值为arr[i]，这样继续和后面比较时仍是类似命题中的：上一组的较大者和新数值比较 arr[i+1] = arr[i]; num++; &#125; else &#123; //当遇到前者小于后者的情况，看此时的num值是否满足大于等于k的要求，符合即作为结果返回 if(num &gt;= k) &#123; return arr[i]; &#125; //不符合则设置num为1，不设置为0的原因是因为已经淘汰掉上一个值，已经赢了一回合 res = arr[i+1]; num = 1; &#125; &#125; return res; &#125; 给你一个 n x n 的二进制网格 grid，每一次操作中，你可以选择网格的 相邻两行 进行交换 一个符合要求的网格需要满足主对角线以上的格子全部都是 0 请你返回使网格满足要求的最少操作次数，如果无法使网格符合要求，请你返回 -1 主对角线指的是从 (1, 1) 到 (n, n) 的这些格子 123456789输入：grid = [[0,0,1],[1,1,0],[1,0,0]]输出：3输入：grid = [[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,1,1,0]]输出：-1解释：所有行都是一样的，交换相邻行无法使网格符合要求输入：grid = [[1,0,0],[1,1,0],[1,1,1]]输出：0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//贪心//从第一行开始，如果该行的后缀0满足条件，那么直接跳过进入下一行（因为需要的后缀0个数是从大到小的顺序（理解这一点非常重要），所以不必担心前面的会抢后面的，自己不够用的时候放心的去抢后面的，因为当前行的需求（优先级）比后面都高）//如果该行后缀0个数不满足条件，那么就往下遍历找到最先（贪心，这是最小次数）满足条件的行，一行一行换上来，记录交换的次数int minSwaps(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; vector&lt;int&gt; resV; int res = 0; int n = grid.size(); //统计每行后缀0个数，存到resV中 for (int i = 0; i &lt; n; i++) &#123; int num = 0; for (int j = 0; j &lt; grid[i].size(); j++) &#123; if (grid[i][j] == 0) &#123; num++; &#125; else &#123; num = 0; &#125; &#125; resV.push_back(num); &#125; for(int i = 0; i &lt; n - 1; i++) &#123; //如果当前行的后缀0个数够用，直接往下遍历，不用担心抢了后面的，因为当前行的需求量比后面的都高 if(resV[i] &gt;= n - i - 1) continue; else &#123; int j = i + 1; while(resV[j] &lt; n - i - 1 ) &#123; j++; //找到最后都没有找到满足个数的后缀0，就直接退出 if(j == n) return -1; &#125; //while之后到这里说明找到了一行满足当前行的后缀0的个数需求，把找到的行一行一行的往上换，换到当前行，每次swap的同时更新交换次数 for(int m = j; m &gt; i; m--) &#123; swap(resV[m], resV[m - 1]); res++; &#125; &#125; &#125; return res;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://chasencenge.github.io/categories/C/"},{"name":"Algorithm","slug":"C/Algorithm","permalink":"https://chasencenge.github.io/categories/C/Algorithm/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://chasencenge.github.io/tags/C/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/tags/Algorithm/"}]},{"title":"LeetCode广度优先搜索","slug":"LeetCode广度优先搜索","date":"2020-08-01T10:13:29.000Z","updated":"2020-08-04T02:49:38.261Z","comments":true,"path":"2020/08/01/LeetCode广度优先搜索/","link":"","permalink":"https://chasencenge.github.io/2020/08/01/LeetCode广度优先搜索/","excerpt":"","text":"107. 二叉树的层次遍历给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） STL queue：原理：队尾（rear）插入，队首（front）删除 头文件： 1#include&lt;queue&gt; 方法： 123456push(): 推一个元素进队列front(): 返回队首元素(栈对应的是top())back(): 返回队尾元素pop(): 移除队首元素empty()size() 创建： 1queue&lt;string&gt; q; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; resV; vector&lt;int&gt; levelNumV; TreeNode* cur = root; //层次遍历借助队列实现 queue&lt;TreeNode*&gt; q; q.push(cur); //跳出遍历的条件为队列为空 while(!q.empty()) &#123; int size = q.size(); while(size-- &gt; 0) &#123; cur = q.front(); //砍头操作 q.pop(); if(cur) &#123; levelNumV.push_back(cur-&gt;val); //爆菊操作 q.push(cur-&gt;left); q.push(cur-&gt;right); &#125; &#125; if(!levelNumV.empty()) &#123; //输出格式不是规则的二维数组可选用vector&lt;vector&gt;，它的push_back内容为vector（不限制子vector长度） resV.push_back(levelNumV); levelNumV.clear(); &#125; &#125; //vector中reverse的使用 reverse(resV.begin(), resV.end()); return resV; &#125;&#125;; 207. 课程表你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1] 给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？ 1234567输入: 2, [[1,0]] 输出: true解释: 总共有2门课程。学习课程1之前，你需要完成课程0。所以这是可能的输入: 2, [[1,0],[0,1]]输出: false解释: 总共有2门课程。学习课程1之前，你需要先完成课程0；并且学习课程0之前，你还应先完成课程1。这是不可能的 我们就可以将本题建模成一个求拓扑排序的问题了： 我们将每一门课看成一个节点 如果想要学习课程 A之前必须完成课程 B，那么我们从B到A连接一条有向边。这样以来，在拓扑排序中，B一定出现在 A的前面 思路： 考虑拓扑排序中最前面的节点，该节点一定不会有任何入边，也就是它没有任何的先修课程要求。当我们将一个节点加入答案中后，我们就可以移除它的所有出边，代表着它的相邻节点少了一门先修课程的要求。如果某个相邻节点变成了「没有任何入边的节点」，那么就代表着这门课可以开始学习了。按照这样的流程，我们不断地将没有入边的节点加入答案，直到答案中包含所有的节点（得到了一种拓扑排序）或者不存在没有入边的节点（图中包含环） 算法： 使用一个队列来进行广度优先搜索。初始时，所有入度为 00 的节点都被放入队列中，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。 在广度优先搜索的每一步中，我们取出队首的节点u： 我们将u放入答案中 我们移除 u的所有出边，也就是将u的所有相邻节点的入度减少1。如果某个相邻节点v的入度变为0，那么我们就将v放入队列中 在广度优先搜索的过程结束后。如果答案中包含了这n个节点，那么我们就找到了一种拓扑排序，否则说明图中存在环，也就不存在拓扑排序了 1234567891011121314151617181920212223242526272829303132333435363738394041bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123; //入度 in degree vector&lt;int&gt; indeg; vector&lt;vector&lt;int&gt;&gt; edges; //resize内的默认初始化值为0 indeg.resize(numCourses); edges.resize(numCourses); for (const auto&amp; info : prerequisites) &#123; //以info[1]为起始的边，指向info[0] edges[info[1]].push_back(info[0]); //info[0]的入度加一，指向它的是info[1] ++indeg[info[0]]; &#125; queue&lt;int&gt; q; for (int i = 0; i &lt; numCourses; i++) &#123; //把最开始入度为0的点push进去 if (indeg[i] == 0) &#123; q.push(i); &#125; &#125; int visited = 0; while (!q.empty()) &#123; visited++; int u = q.front(); q.pop(); for (int v : edges[u]) &#123; --indeg[v]; //如果去掉指向它的u之后，v点的入度变为0，那么push进队列 if (indeg[v] == 0) &#123; q.push(v); &#125; &#125; &#125; return visited == numCourses;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://chasencenge.github.io/categories/C/"},{"name":"Algorithm","slug":"C/Algorithm","permalink":"https://chasencenge.github.io/categories/C/Algorithm/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://chasencenge.github.io/tags/C/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/tags/Algorithm/"}]},{"title":"字节夏令营20游戏程序笔试题","slug":"字节夏令营20游戏程序笔试题","date":"2020-08-01T03:42:48.000Z","updated":"2020-08-02T15:52:41.495Z","comments":true,"path":"2020/08/01/字节夏令营20游戏程序笔试题/","link":"","permalink":"https://chasencenge.github.io/2020/08/01/字节夏令营20游戏程序笔试题/","excerpt":"","text":"给素材分类，若作品1中有素材1和素材2，则认为素材1和素材2为一类，若作品2中有素材2和素材3，那么此后认为素材1、2、3为一类 输入：第一行为作品数n，此后n行中每行第一位为该作品中的素材总数m，此后m个数字为素材名（int型） 输出：素材的分类，并且每一类素材，类内顺序由小到大，类外顺序按照类内最小值由小到大排序输出 示例： 1234567891011输入：42 1 33 0 5 63 2 3 41 7输出：0 5 61 2 3 47 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;int main()&#123; vector&lt;vector&lt;int&gt;&gt; resV; int num; cin &gt;&gt; num; for (int i = 0; i &lt; num; i++) &#123; int cat; cin &gt;&gt; cat; //存放该作品内所有素材的vector vector&lt;int&gt; tempV; for (int j = 0; j &lt; cat; j++) &#123; int mem; cin &gt;&gt; mem; tempV.push_back(mem); //cout &lt;&lt; tempV[j]; &#125; //能否找到已存在的类，能找到就将tempV添加进去 int label = 0; for (int k = 0; k &lt; tempV.size(); k++) &#123; for (int out = 0; out &lt; resV.size(); out++) &#123; int flag = 0; for (int in = 0; in &lt; resV[out].size(); in++) &#123; if (tempV[k] == resV[out][in]) &#123; label = 1; flag = 1; for (int copy = 0; copy &lt; tempV.size(); copy++) &#123; //检查重复素材，重复的素材不添加，只在已有的分类中添加还未加入的素材 if (find(resV[out].begin(), resV[out].end(), tempV[copy]) == resV[out].end()) resV[out].push_back(tempV[copy]); &#125; break; &#125; &#125; //不用再继续遍历后面的子vector了，添加进一个分类中就一定不会添加进另外一个分类 if (flag == 1) break; &#125; &#125; //是新的素材分类 if (label == 0) &#123; resV.push_back(tempV); &#125; &#125; //子vector按最小元素排序 sort(resV.begin(), resV.end()); for (int i = 0; i &lt; resV.size(); i++) &#123; //子vector内部排序 sort(resV[i].begin(), resV[i].end()); for (int j = 0; j &lt; resV[i].size(); j++) cout &lt;&lt; resV[i][j] &lt;&lt; \" \"; cout &lt;&lt; endl; &#125; return 0;&#125; 计算给出时间和格林尼治时间之间的秒数，格式：YYYY/MM/DD hh:mm:ss 需要考虑平年和闰年 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;int main()&#123; string date, time; cin &gt;&gt; date &gt;&gt; time; long long int year, month, day; //切分成子字符串之后再转整型，赋给年月日时分秒 //atoi()的参数是 const char* ,因此对于一个字符串str我们必须调用c_str()的方法把这个string转换成const char*类型的 //substr(pos, num)两个参数是从起始位置和pos开始取的字符个数，而不是起始位置和末尾位置 year = atoi(date.substr(0, 4).c_str()); month = atoi(date.substr(5, 2).c_str()); day = atoi(date.substr(8, 2).c_str()); long long int hour, minute, second; hour = atoi(time.substr(0, 2).c_str()); minute = atoi(time.substr(3, 2).c_str()); second = atoi(time.substr(6, 2).c_str()); long long int time1 = 0; //cout &lt;&lt; hour &lt;&lt; \" \" &lt;&lt; minute &lt;&lt; \" \" &lt;&lt; second; cout &lt;&lt; year &lt;&lt; \" \" &lt;&lt; month &lt;&lt; \" \" &lt;&lt; day &lt;&lt; endl; //cout &lt;&lt; second &lt;&lt; to_string(minute * 60) &lt;&lt; to_string(hour * 3600) &lt;&lt; second + minute * 60 + hour * 3600; //给出的一天内的时间计算 time1 = second + minute * 60 + hour * 3600; long long int time2 = 0; long long int run = 0; for (int i = 1970; i &lt; year; i++) &#123; if ((i % 4 == 0 &amp;&amp; i % 100 != 0) || i % 400 == 0) run++; &#125; cout &lt;&lt; run &lt;&lt; endl; //给出的年月日的时间计算 time2 += run * 366 * 3600 * 24 + (year - 1970 - run) * 365 * 3600 * 24; cout &lt;&lt; time2 &lt;&lt; endl; long long int temp = 0; //最后一年单独计算，因为最后一年未满整一年 //最后一年是闰年还是平年 if ((year % 4 == 0 &amp;&amp; year % 100 != 0) || year % 400 == 0) temp = 29; else temp = 28; //最后一年除掉最后一个月的时间，因为最后一个月未满整一个月 switch (month) &#123; case 01: time2 += 0; break; case 02: time2 += 31 * 3600 * 24; break; case 03: time2 += (31 + temp) * 3600 * 24; break; case 04: time2 += (62 + temp) * 3600 * 24; break; case 05: time2 += (92 + temp) * 3600 * 24; break; case 06: time2 += (123 + temp) * 3600 * 24; break; case 07: time2 += (153 + temp) * 3600 * 24; break; //8和9特殊，编译器在识别08和09时不会自动转换成8和9，而是提示错误的八进制数 case 8: time2 += (184 + temp) * 3600 * 24; break; case 9: time2 += (215 + temp) * 3600 * 24; break; case 10: time2 += (245 + temp) * 3600 * 24; break; case 11: time2 += (276 + temp) * 3600 * 24; break; case 12: time2 += (306 + temp) * 3600 * 24; break; &#125; //cout &lt;&lt; time2 &lt;&lt; endl; time2 += (day - 1) * 24 * 3600; //整的年月日的时间计算加上最后一日内的时分秒时间计算 long long int res = time1 + time2; cout &lt;&lt; res &lt;&lt; endl; return 0; //1970/02/01 00:00:00 //2716/02/02 00:00:00&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/categories/Algorithm/"},{"name":"C++","slug":"Algorithm/C","permalink":"https://chasencenge.github.io/categories/Algorithm/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://chasencenge.github.io/tags/C/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/tags/Algorithm/"}]},{"title":"网易20秋招Unity工程师笔试编程题","slug":"网易20秋招Unity工程师笔试编程题","date":"2020-07-31T14:25:33.000Z","updated":"2020-07-31T16:12:44.900Z","comments":true,"path":"2020/07/31/网易20秋招Unity工程师笔试编程题/","link":"","permalink":"https://chasencenge.github.io/2020/07/31/网易20秋招Unity工程师笔试编程题/","excerpt":"","text":"定义S(n)，表示n在十进制下的各位数字和。 现在给定一个x,请你求出最小正整数n，满足x&lt;=S(n)。 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;string&gt;int main()&#123; int num; cin &gt;&gt; num; vector&lt;string&gt; resV; string a = \"9\"; for (int n = 0; n &lt; num; n++) &#123; int x; cin &gt;&gt; x; //long long int multi = 1; string res; while (x &gt; 9) &#123; x -= 9; res = a + res; //multi *= 10; &#125; if (x != 0) &#123; //res += multi * x; res = to_string(x) + res; &#125; resV.push_back(res); &#125; for (int n = 0; n &lt; num; n++) &#123; cout &lt;&lt; resV[n] &lt;&lt; endl; &#125; return 0;&#125; 小易给定你数字A, B (A &lt; B)和系数p, q。每次操作你可以将A变成A + p或者将p变成p * q。问至少几次操作使得B &lt;= A。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;string&gt;int main()&#123; int num; cin &gt;&gt; num; vector&lt;long long int&gt; resV; for (int n = 0; n &lt; num; n++) &#123; long long int a; long long int b; long long int p; long long int q; cin &gt;&gt; a &gt;&gt; b &gt;&gt; p &gt;&gt; q; long long int res = 0; if (b - a &gt; p) &#123; long long int temp = b - a; long long int multiNum = p; while (temp &gt; multiNum) &#123; multiNum *= q; res++; &#125; res++; &#125; else &#123; res++; &#125; resV.push_back(res); &#125; for (int n = 0; n &lt; num; n++) &#123; cout &lt;&lt; resV[n] &lt;&lt; endl; &#125; return 0;&#125; 小易定义一个数字序列是完美的，当且仅当对于任意2 &lt;= i &lt;= n，都满足，即每个数字都要大于等于前面所有数字的和。现在给定数字序列Ai，小易想请你从中找出最长的一段连续子序列，满足它是完美的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;string&gt;int main()&#123; vector&lt;int&gt; resV; int num; cin &gt;&gt; num; for (int i = 0; i &lt; num; i++) &#123; int tempLength = 1; int maxLength = 0; vector&lt;int&gt; n; int serialNum; cin &gt;&gt; serialNum; for (int j = 0; j &lt; serialNum; j++) &#123; int data; cin &gt;&gt; data; n.push_back(data); &#125; int compute = n[0]; for (int k = 1; k &lt; serialNum; k++) &#123; if (n[k] &gt;= compute) &#123; compute += n[k]; tempLength++; &#125; else &#123; maxLength = max(maxLength, tempLength); tempLength = 1; compute = n[k]; &#125; &#125; resV.push_back(maxLength); &#125; for (int i = 0; i &lt; num; i++) &#123; cout &lt;&lt; resV[i] &lt;&lt; endl; &#125; return 0;&#125; 小易的公司一共有n名员工, 第i个人每个月的薪酬是xi万元。现在小易的老板向小易提了m次询问, 每次询问老板都会给出一个整数k, 小易要快速回答老板工资等于k的员工的数量。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;unordered_map&gt;using namespace std;int main()&#123; int people, question; cin &gt;&gt; people &gt;&gt; question; vector&lt;int&gt; resV(question, 0); vector&lt;int&gt; salaryV; vector&lt;int&gt; questionV; unordered_map&lt;string, size_t&gt; questionMap; for (int i = 0; i &lt; people; i++) &#123; int salary; cin &gt;&gt; salary; salaryV.push_back(salary); &#125; for (int i = 0; i &lt; question; i++) &#123; int data; cin &gt;&gt; data; questionV.push_back(data); questionMap[to_string(data)]; &#125; for (int i = 0; i &lt; people; i++) &#123; if (questionMap.find(to_string(salaryV[i])) != questionMap.end()) &#123; ++questionMap[to_string(salaryV[i])]; &#125; &#125; for (int i = 0; i &lt; question; i++) &#123; cout &lt;&lt; questionMap.find(to_string(questionV[i]))-&gt;second &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/categories/Algorithm/"},{"name":"C++","slug":"Algorithm/C","permalink":"https://chasencenge.github.io/categories/Algorithm/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://chasencenge.github.io/tags/C/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/tags/Algorithm/"}]},{"title":"Pyplot绘图","slug":"Pyplot绘图","date":"2020-07-27T12:56:31.000Z","updated":"2020-07-27T13:20:21.018Z","comments":true,"path":"2020/07/27/Pyplot绘图/","link":"","permalink":"https://chasencenge.github.io/2020/07/27/Pyplot绘图/","excerpt":"","text":"标识散点：plt.scatter(x, y)可选项s修改散点大小，color修改颜色 1plt.scatter(thisNodeLoc[0], thisNodeLoc[1], s=10, color='b') 连线：plt.plot([x1, y1], [x2, y2])1plt.plot([thisNodeLoc[0], sendToNodeLoc[0]], [thisNodeLoc[1], sendToNodeLoc[1]]) 注释文字：plt.annotate(txt, xy=(), xytext=())xy处填注释点坐标，xytext处填文本位置，可加偏移offset 1plt.annotate(thisNodeLoc, xy=(thisNodeLoc[0], thisNodeLoc[1]), xytext=(thisNodeLoc[0]+1, thisNodeLoc[1]+1)) 限制坐标区间：12plt.xlim(-2200,2200)plt.ylim(-2200,2200) 12345678910for n in range(0, nodeNum): thisNodeLoc = [nodes[n].locX, nodes[n].locY] sendToNodeLoc = [nodes[n].sendTo.locX, nodes[n].sendTo.locY] plt.scatter(thisNodeLoc[0], thisNodeLoc[1], s=10, color='b') plt.plot([thisNodeLoc[0], sendToNodeLoc[0]], [thisNodeLoc[1], sendToNodeLoc[1]]) plt.annotate(thisNodeLoc, xy=(thisNodeLoc[0], thisNodeLoc[1]), xytext=(thisNodeLoc[0]+1, thisNodeLoc[1]+1))plt.xlim(-2200,2200)plt.ylim(-2200,2200)plt.show() 最后记得用plt.show()将其显示出来","categories":[{"name":"Python","slug":"Python","permalink":"https://chasencenge.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://chasencenge.github.io/tags/Python/"}]},{"title":"百度之星2020---1003.Permutation","slug":"百度之星2020-1003-Permutation","date":"2020-07-26T10:04:53.000Z","updated":"2020-07-26T10:28:00.105Z","comments":true,"path":"2020/07/26/百度之星2020-1003-Permutation/","link":"","permalink":"https://chasencenge.github.io/2020/07/26/百度之星2020-1003-Permutation/","excerpt":"","text":"Problem Description 一开始有 n个数，他们按 1…n的顺序排列，要求交换最多 m对数字（同一个数字可以参与多次交换），使得逆序对数目最大。 对于一个序列 A，如果存在正整数 i, j使得1≤i&lt;j≤n 而且 A[i] &gt; A[j]，则 &lt;A[i],A[j]&gt; 这个有序对称为 A的一个逆序对。 Input 第一行一个正整数test (1≤test≤100000) 表示数据组数。 对于每组数据，一行两个整数 n，m (1≤n≤1000000,0≤m≤1000000) 表示数字个数和最多可以交换的数字对数。 Output 对于每组数据，一行一个整数表示答案。 Sample Input 123456761 12 02 13 14 14 2 Sample Output 123456001356 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;// 对每个（n, 1）结果都为：2 * n - 3int com(int n)&#123; int com = 2 * n - 3; return com;&#125;// 把（n, m）转换为（n, 1）, (n -2, 1)...(n - 2m + 2, 1)之和的形式并利用com()计算结果int arr(int n, int m)&#123; int res = 0; for (int i = 0; i &lt; m; i++) &#123; res += com(n - 2 * i); //cout &lt;&lt; i &lt;&lt;\" \"&lt;&lt; res&lt;&lt;endl; &#125; return res;&#125;vector&lt;int&gt; compute() &#123; int groupNum; cin &gt;&gt; groupNum; vector&lt;int&gt; output; for (int i = 0; i &lt; groupNum; i++) &#123; int n; int m; //cout &lt;&lt; \"choiseNum:\" &lt;&lt; choiseNum &lt;&lt; endl; cin &gt;&gt; n; //cout &lt;&lt; \"b:\" &lt;&lt; b &lt;&lt; endl; cin &gt;&gt; m; //cout &lt;&lt; \"c:\" &lt;&lt; c &lt;&lt; endl; if (n == 1 || m == 0) &#123; output.push_back(0); &#125; else &#123; if (2 * m &lt; n) &#123; int res = arr(n, m); output.push_back(res); &#125; else &#123; m = n / 2; int res = arr(n, m); output.push_back(res); &#125; &#125; &#125; return output; &#125;int main()&#123; vector&lt;int&gt; res = compute(); for (int i = 0; i &lt; res.size(); i++) &#123; //cout &lt;&lt; res[i]; printf(\"%d\\n\", res[i]); &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/categories/Algorithm/"},{"name":"C++","slug":"Algorithm/C","permalink":"https://chasencenge.github.io/categories/Algorithm/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://chasencenge.github.io/tags/C/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/tags/Algorithm/"}]},{"title":"百度之星2020---1002.Game","slug":"百度之星2020-1002-Game","date":"2020-07-26T10:04:18.000Z","updated":"2020-07-26T10:27:47.180Z","comments":true,"path":"2020/07/26/百度之星2020-1002-Game/","link":"","permalink":"https://chasencenge.github.io/2020/07/26/百度之星2020-1002-Game/","excerpt":"","text":"Problem Description Alice 和 Bob 在玩游戏。 桌面上有两堆金币，少的那堆有 x 个金币，多的那堆有 2x 个金币。 假设金币可以被无限细分。Alice 和 Bob 事先都不知道 x是几，但是他们都知道 x是一个 (0, 1]之间均匀分布的随机实数。 Alice 会等概率的被分配到其中的一堆金币，Bob 会得到另一堆。x的值和两堆金币的分配是相互独立的。 拿到金币以后，Alice 会马上数清自己拿到多少金币。然后 Alice 可以选择是否和 Bob 那堆换。 给定 Alice 拿到的金币数目，请问 Alice 要不要交换，使得她期望能得到的金币数目更多？ 如果交换期望得到的金币数目多于不交换期望得到的金币数目，输出交换，否则不交换。 Input 第一行一个正整数test (1≤test≤200000) 表示数据组数。 接下来每行一个小数p(0&lt;p≤2)，p最多保留五位小数，表示 Alice 拿到的金币数目。 Output 对于每组数据，输出 Yes 表示需要交换，输出 No 表示不要交换。 Sample Input 1211.00000 Sample Output 1Yes 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include &lt;string&gt;using namespace std;vector&lt;string&gt; compute()&#123; int groupNum; std::cin &gt;&gt; groupNum; vector&lt;string&gt; output; for (int i = 0; i &lt; groupNum; i++) &#123; float num; std::cin &gt;&gt; num; //float exception; if (num &gt; 1) &#123; output.push_back(\"No\"); &#125; else &#123; if (2 * num * 0.5 + num / 2 * 0.5 &gt; num) &#123; output.push_back(\"Yes\"); &#125; else &#123; output.push_back(\"No\"); &#125; &#125; &#125; return output;&#125;int main()&#123; vector&lt;string&gt; res = compute(); for (int i = 0; i &lt; res.size(); i++) &#123; //cout &lt;&lt; res[i]; printf(\"%s\\n\", res[i].c_str()); &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/categories/Algorithm/"},{"name":"C++","slug":"Algorithm/C","permalink":"https://chasencenge.github.io/categories/Algorithm/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://chasencenge.github.io/tags/C/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/tags/Algorithm/"}]},{"title":"百度之星2020---1001.Discount","slug":"百度之星2020-1001-Discount","date":"2020-07-26T10:03:53.000Z","updated":"2020-07-26T10:21:02.628Z","comments":true,"path":"2020/07/26/百度之星2020-1001-Discount/","link":"","permalink":"https://chasencenge.github.io/2020/07/26/百度之星2020-1001-Discount/","excerpt":"","text":"Problem Description 学皇来到了一个餐馆吃饭。他觉得这家餐馆很好吃，于是就想办个会员。 一共有 n种会员充值卡套餐，假设学皇这餐饭的消费为 a元，选择第 i种套餐，需要充值 b[i] * a 的钱，这次吃饭可以打 c[i]×10 折，由充值的钱支付（即这次吃饭只需要从充值金额中扣除 a×c[i] 元）。以后用剩余的充值的钱吃饭不再打折。 请问学皇应该选择哪个套餐（必须选择恰好一个套餐），使得优惠的比例最大？ 优惠比例的定义是把充的钱用完以后，(本来应该付的钱 - 实际付的钱) / 本来应该付的钱。在这个题目里，实际付的钱就是这次充值的花费。 Input 第一行一个整数 test(1≤test≤100) 表示数据组数。 对于每组数据，第一行一个正整数 n(1≤n≤100) 表示套餐的数目。 接下来 n行，每行一个正整数 b[i]和一个小数 c[i]。 Output 对于每组数据，输出一个五位小数表示最大的优惠比例。如果小数点后超过五位，四舍五入到五位。 Sample Input 1234122 0.53 0.1 Sample Output 123450.23077样例解释对于第一种套餐，优惠比例为 0.5a / (2a + 0.5a） = 0.2；对于第二种套餐，优惠比例为 0.9a / (3a + 0.9a） = 9 / 39； 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;vector&lt;float&gt; compute() &#123; int groupNum; cin &gt;&gt; groupNum; vector&lt;float&gt; output; for (int i = 0; i &lt; groupNum; i++) &#123; float res = 0; int choiseNum; cin &gt;&gt; choiseNum; //cout &lt;&lt; \"choiseNum:\" &lt;&lt; choiseNum &lt;&lt; endl; int b; float c; for (int j = 0; j &lt; choiseNum; j++) &#123; cin &gt;&gt; b; //cout &lt;&lt; \"b:\" &lt;&lt; b &lt;&lt; endl; cin &gt;&gt; c; //cout &lt;&lt; \"c:\" &lt;&lt; c &lt;&lt; endl; float temp = (1 - c) / (b + 1 - c); res = max(res, temp); &#125; output.push_back(res); &#125; return output;&#125;int main()&#123; vector&lt;float&gt; res = compute(); for (int i = 0; i &lt; res.size(); i++) &#123; //cout &lt;&lt; res[i]; printf(\"%.5f\\n\", res[i]); &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/categories/Algorithm/"},{"name":"C++","slug":"Algorithm/C","permalink":"https://chasencenge.github.io/categories/Algorithm/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://chasencenge.github.io/tags/C/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://chasencenge.github.io/tags/Algorithm/"}]},{"title":"游戏客户端面经知识点","slug":"游戏客户端面经知识点","date":"2020-07-24T05:40:54.000Z","updated":"2020-07-24T05:43:25.394Z","comments":true,"path":"2020/07/24/游戏客户端面经知识点/","link":"","permalink":"https://chasencenge.github.io/2020/07/24/游戏客户端面经知识点/","excerpt":"","text":"","categories":[{"name":"Unity","slug":"Unity","permalink":"https://chasencenge.github.io/categories/Unity/"},{"name":"Unreal","slug":"Unity/Unreal","permalink":"https://chasencenge.github.io/categories/Unity/Unreal/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://chasencenge.github.io/tags/Unity/"},{"name":"Unreal","slug":"Unreal","permalink":"https://chasencenge.github.io/tags/Unreal/"}]},{"title":"Unity项目对接到Laya","slug":"Unity项目对接到Laya","date":"2020-07-21T09:29:24.000Z","updated":"2020-07-24T02:30:25.993Z","comments":true,"path":"2020/07/21/Unity项目对接到Laya/","link":"","permalink":"https://chasencenge.github.io/2020/07/21/Unity项目对接到Laya/","excerpt":"","text":"Unity APIGameObject.FindWithTag通过Tag名找到游戏对象 1ring = GameObject.FindWithTag(&quot;ring&quot;) FindWithTag 返回一个标记为 tag 的活动 GameObject。如果未找到 GameObject，则返回 null。 Find 按 name 查找 GameObject，然后返回它。 RigidbodyRigidbody是刚体，可以为游戏对象赋予物理属性，向对象添加 Rigidbody 组件后，其运动将受到 Unity 物理引擎的控制。即使不添加任何代码，Rigidbody 对象也受到向下的重力，并在与其他对象碰撞时作出反应（需有适当的collider） position 刚体的位置 rotation 刚体的旋转 useGravity 控制重力是否影响该刚体 angularVelocity 刚体的角速度矢量（以弧度/秒为单位） velocity 刚体的速度矢量 AddForce 向 Rigidbody 添加力 Sleep 强制刚体进入睡眠状态至少一帧 AddTorque 向刚体添加扭矩 Quaternion在API中的UnityEngine-&gt;classes，四元数 12Vector3 dir = hoopPoint.position - ballPoint.position;Quaternion wantedRotation = Quaternion.LookRotation(dir); Quaternion.LookRotation(dir)使用指定的 forward 和 upwards 方向创建旋转 AngleAxis 创建一个围绕 axis 旋转 angle 度的旋转 LookRotation 使用指定的 forward 和 upwards 方向创建旋转 GameObject.GetComponentGameObject.GetComponent() 在UnityEngine-&gt;classes-&gt;GameObject 返回 GameObject 中类型为 type 的所有组件 示例： 12345678void Start()&#123; Component[] hingeJoints; hingeJoints = GetComponents(typeof(HingeJoint)); foreach (HingeJoint joint in hingeJoints) joint.useSpring = false;&#125; ForceMode位于UnityEngine-&gt;Enumerations 使用 ForceMode 指定如何使用 Rigidbody.AddForce 来施加力。 AddForce 函数可定义自己的力矢量，以及选择如何将此力施加于 GameObject（此 GameObject 必须附加有 Rigidbody 组件），从而影响您的 GameObject 的移动方式。 Force 向此刚体添加连续力，使用其质量 Acceleration 向此刚体添加连续加速度，忽略其质量 Impulse 向此刚体添加瞬时力冲击，考虑其质量 VelocityChange 向此刚体添加瞬时速度变化，忽略其质量 transform对象的位置、旋转和缩放 每个变换都可以有一个父级，使得能够分层应用位置、旋转和缩放 parent 变换的父级 position 世界空间中的变换位置 rotation 一个四元数，用于存储变换在世界空间中的旋转 localEulerAngles 以欧拉角表示的相对于父变换旋转的旋转（以度为单位） localPosition 相对于父变换的变换位置 localRotation 相对于父级变换旋转的变换旋转 localScale 相对于父对象的变换缩放 childCount 父变换具有的子项数 Camera.ScreenPointToRay1Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition); Physics.Raycast参数： origin 射线在世界坐标系中的起点 direction 射线的方向 maxDistance 射线应检查碰撞的最大距离 layerMask 层遮罩，用于在投射射线时有选择地忽略碰撞体 queryTriggerInteraction 指定该查询是否应该命中触发器 bool 如果射线与任何碰撞体相交，返回 true，否则为 false。 RaycastHit用于从射线投射获取信息的结构 barycentricCoordinate 命中的三角形的重心坐标 collider 命中的 Collider distance 从射线原点到撞击点的距离 lightmapCoord 撞击点处的 UV 光照贴图坐标 normal 射线命中的表面的法线 point 世界空间中射线命中碰撞体的撞击点 rigidbody 命中的碰撞体的 Rigidbody。如果该碰撞体未附加到刚体，则值为 /null/ textureCoord 碰撞位置处的 UV 纹理坐标 textureCoord2 撞击点处的辅助 UV 纹理坐标 transform 命中的刚体或碰撞体的 Transform triangleIndex 命中的三角形的索引 Collider所有碰撞体的基类 BoxCollider、SphereCollider、CapsuleCollider、MeshCollider、PhysicMaterial、Rigidbody 如果在游戏过程中需要移动具有 Collider 的对象，还应将 Rigidbody 组件附加到该对象。如果不想使该对象与其他对象进行物理交互，可将 Rigidbody 设置为运动刚体 变量： attachedRigidbody 碰撞体附加到的刚体 bounds 碰撞体的世界空间包围体积（只读） contactOffset 该碰撞体的接触偏移值 enabled 启用的 Collider 将与其他 Collider 碰撞，禁用的 Collider 不会这样 isTrigger 碰撞体是不是触发器 material 碰撞体使用的材质 sharedMaterial 该碰撞体的共享物理材质 消息： OnCollisionEnter 当该碰撞体/刚体已开始接触另一个刚体/碰撞体时，调用 OnCollisionEnter OnCollisionExit 当该碰撞体/刚体已停止接触另一个刚体/碰撞体时，调用 OnCollisionExit OnCollisionStay 对应正在接触刚体/碰撞体的每一个碰撞体/刚体，每帧调用一次 OnCollisionStay OnTriggerEnter 当 Collider other 事件进入该触发器时调用 OnTriggerEnter OnTriggerExit 当 Collider other 已停止接触该触发器时调用 OnTriggerExit OnTriggerStay 对于正在接触该触发器的每个其他 Collider，“几乎”所有帧都调用 OnTriggerStay。此函数位于物理计时器上，因此它不必运行每个帧 继承的成员变量： gameObject 此组件附加到的游戏对象。始终将组件附加到游戏对象 tag 此游戏对象的标签 transform 附加到此 GameObject 的 Transform hideFlags 该对象应该隐藏、随场景一起保存还是由用户修改 name 对象的名称 公共函数： BroadcastMessage 调用此游戏对象或其任何子项中的每个 MonoBehaviour 上名为 methodName 的方法 CompareTag 此游戏对象是否使用 tag 进行了标记 GetComponent 如果游戏对象附加了类型为 type 的组件，则将其返回，否则返回 null GetComponentInChildren 使用深度首次搜索返回 GameObject 或其任何子项中类型为 type 的组件 GetComponentInParent 返回 GameObject 或其任何父项中类型为 type 的组件 GetComponents 返回 GameObject 中类型为 type 的所有组件 GetComponentsInChildren 返回 GameObject 或其任何子项中类型为 type 的所有组件 GetComponentsInParent 返回 GameObject 或其任何父项中类型为 type 的所有组件 SendMessage 调用此游戏对象中的每个 MonoBehaviour 上名为 methodName 的方法 SendMessageUpwards 调用此游戏对象中的每个 MonoBehaviour 上或此行为的每个父级上名为 methodName 的方法 GetInstanceID 返回对象的实例 ID ToString 返回 GameObject 的名称 静态函数： Destroy 删除 GameObject、组件或资源 DestroyImmediate 立即销毁对象 /obj/。强烈建议您改用 Destroy DontDestroyOnLoad 在加载新的 Scene 时，请勿销毁 Object FindObjectOfType 返回第一个类型为 type 的已加载的激活对象 FindObjectsOfType 返回所有类型为 type 的已加载的激活对象的列表 Instantiate 克隆 original 对象并返回克隆对象 C#outout同ref一样，都是有一级地址传递的，也就是，带有这两个修饰符的参数，如果被修改了原来的值，将以新的值作为他的值（在函数执行完毕后，该参数的值将返回给函数调用中使用的变量，有点像C++ &amp;） 在函数中使用out参数时，必须将其看成尚未赋值。也就是说调用代码可以把已赋值的变量用作out参数，但在函数执行时该变量的值会丢失，所以就算在函数外已经初始化，在函数内也要重新初始化 示例： // 第一行hit不用初始化，参数中hit前加out，尽管Physics.Raycast返回bool，hit已在其中赋值，所以下一个if语句中hit可以调用其对象的属性方法 123456789101112131415RaycastHit hit;if (Physics.Raycast(ray, out hit, 1000, 1 &lt;&lt; 8)) &#123; if (hit.collider.gameObject.tag == &quot;Basketball&quot; &amp;&amp; !hit.collider.gameObject.GetComponent&lt;BSKBall&gt;().IsShooting()) &#123; currentBall = hit.collider.gameObject; Rigidbody r = currentBall.GetComponent&lt;Rigidbody&gt;(); r.isKinematic = true; Vector3 touchPoint = Camera.main.ScreenToWorldPoint(Input.mousePosition + new Vector3(0, 0, depth)); touchPoint.x = Mathf.Clamp(touchPoint.x, leftEdge.transform.position.x + 0.29f, rightEdge.transform.position.x - 0.29f); touchPoint.y = selectBallPosY; currentBall.transform.position = touchPoint; &#125; &#125; Unity坐标四种坐标：世界坐标(World Space)：游戏物体在创造的世界中的坐标 transfrom.position获得的是物体相对于世界坐标的位置 transfrom.localPosition获得的是物体相对于父物体坐标的位置 屏幕坐标(Screen Space)：以像素记 视口坐标(Viewport Space)：将屏幕坐标单位化 坐标转换：物体B相对于物体A的局部坐标：A.transform.InverseTransformPoint(B) 屏幕坐标转世界坐标：Camera.main.ScreenToWorldPoint 12Vector3 mousePos = Input.mousePosition;Vector3 screenToWorld = Camera.main.ScreenToWorldPoint(new Vector3(mousePos.x, mousePos.y, -Camera.main.transform.position.z)); 世界坐标转屏幕坐标：Camera.main.WorldToScreenPoint 1Vector3 worldToScreen = Camera.main.WorldToScreenPoint(transform.position); Mathf.Clamp在给定的最小浮点值和最大浮点值之间钳制给定值。如果在最小和最大范围内，则返回给定值 如果给定的浮点值小于最小值，则返回最小值。如果给定值大于最大值，则返回最大值。使用 Clamp 可将某个值限制为最小值和最大值定义的某个范围内 变量 gameObject 此组件附加到的游戏对象。始终将组件附加到游戏对象。 tag 此游戏对象的标签。 transform 附加到此 GameObject 的 Transform。 公共函数 BroadcastMessage 调用此游戏对象或其任何子项中的每个 MonoBehaviour 上名为 methodName 的方法。 CompareTag 此游戏对象是否使用 tag 进行了标记？ GetComponent 如果游戏对象附加了类型为 type 的组件，则将其返回，否则返回 null。 GetComponentInChildren 使用深度首次搜索返回 GameObject 或其任何子项中类型为 type 的组件。 GetComponentInParent 返回 GameObject 或其任何父项中类型为 type 的组件。 GetComponents 返回 GameObject 中类型为 type 的所有组件。 GetComponentsInChildren 返回 GameObject 或其任何子项中类型为 type 的所有组件。 GetComponentsInParent 返回 GameObject 或其任何父项中类型为 type 的所有组件。 SendMessage 调用此游戏对象中的每个 MonoBehaviour 上名为 methodName 的方法。 SendMessageUpwards 调用此游戏对象中的每个 MonoBehaviour 上或此行为的每个父级上名为 methodName 的方法。 继承的成员变量 hideFlags 该对象应该隐藏、随场景一起保存还是由用户修改？ name 对象的名称。 公共函数 GetInstanceID 返回对象的实例 ID。 ToString 返回 GameObject 的名称。 Component附加到 GameObject 的所有内容的基本类 注：代码不会直接创建 Component，而是编写脚本代码，然后将该脚本附加到GameObject ResourcesResources 类允许您查找和访问资源等对象 在编辑器中，Resources.FindObjectsOfTypeAll 可用于定位资源和场景对象 通过 Resources.Load 函数，可访问 Assets 文件夹中处于任意位置的名为“Resources”的文件夹中的所有资源。 可以存在多个“Resources”文件夹，加载对象时，将对每个文件夹进行检查 注意：Assets 中的 Resources 文件夹需要在使用前创建。创建新项目时，不会创建该文件夹 静态函数：（函数调用的结果不会访问或者修改任何对象（非static）数据成员，这样的成员声明为静态成员函数比较好） FindObjectsOfTypeAll 返回所有类型为 type 的对象的列表。 Load 加载存储在 Resources 文件夹中的 path 处的资源。 LoadAll 加载位于 Resources 文件夹中的 path 处的文件夹中的所有资源，或加载位于该处的文件。 LoadAsync 异步加载存储在 Resources 文件夹中的 path 处的资源。 UnloadAsset 从内存中卸载 /assetToUnload/。 UnloadUnusedAssets 卸载未使用的资源。 Laya APIRigidbody3D对应于Unity中Rigidbody.AddForce，Rigidbody.AddTorque， Laya提供的类为Rigidbody3D，对应的方法为Rigidbody3D.applyForce，Rigidbody3D.applyTorque 12345applyForce(force: Vector3, localOffset?: Vector3): voidapplyImpulse(impulse: Vector3, localOffset?: Vector3): voidapplyTorque(torque: Vector3): void","categories":[{"name":"Unity","slug":"Unity","permalink":"https://chasencenge.github.io/categories/Unity/"},{"name":"Laya","slug":"Unity/Laya","permalink":"https://chasencenge.github.io/categories/Unity/Laya/"},{"name":"C#","slug":"Unity/Laya/C","permalink":"https://chasencenge.github.io/categories/Unity/Laya/C/"},{"name":"TypeScript","slug":"Unity/Laya/C/TypeScript","permalink":"https://chasencenge.github.io/categories/Unity/Laya/C/TypeScript/"}],"tags":[{"name":"Laya","slug":"Laya","permalink":"https://chasencenge.github.io/tags/Laya/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://chasencenge.github.io/tags/TypeScript/"},{"name":"Unity","slug":"Unity","permalink":"https://chasencenge.github.io/tags/Unity/"},{"name":"C#","slug":"C","permalink":"https://chasencenge.github.io/tags/C/"}]},{"title":"Python实现Lora节点拓扑自动规划","slug":"Python实现Lora节点拓扑自动规划","date":"2020-07-20T02:57:58.000Z","updated":"2020-07-27T19:14:15.897Z","comments":true,"path":"2020/07/20/Python实现Lora节点拓扑自动规划/","link":"","permalink":"https://chasencenge.github.io/2020/07/20/Python实现Lora节点拓扑自动规划/","excerpt":"","text":"NodeClass.py:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252# 小记：# 先不考虑中继节点在classB模式下发Beacon的能耗# 能量效率的计算公式是否有问题？只考虑发包的能耗和时间# energyConsumption需统一成自己在lifetime中的能量消耗推导，不再用论文中笼统的折线图值# 注意区分self.sendTo.index和一些函数中的node.index的区别，前者使用的场景在确定节点拓扑之后，后者使用在确定节点拓扑之前的一些遍历情况import mathimport numpy as np# python中的public、private和protected是通过变量名前的下划线标识的，保护类型一个下划线，私有类型两个下划线class Node: def __init__(self, name, locX, locY, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, isGateway=0, whichSet=0, index=0): # 默认缺省值isGateway=0 self.name = name self.payload = _payload self.bandW = _bandW self.c = _c self.pi = _pi self.beta = _beta self.whiteNoise = _whiteNoise self.dutyCycle = _dutyCycle self.batteryE = _batteryE # 每确定要多为另一个节点进行中继，dataGen需要更新添加帮忙转发的数据量 self.dataGen = _dataGen self.cycleT = _cycleT self.transRadioE = _transRadioE self.recvRadioE = _recvRadioE self.spareRadioE = _spareRadioE self.offRadioE = _offRadioE self.onMcuE = _onMcuE self.offMcuE = _offMcuE # 注意和dataGen的区别，这个变量是节点发送给节点/网关的总数据量，带有中继数据 self.dataSend = _dataGen self.lifeT = 0.0 self.cycleE = 0.0 self.symbleT = 0.0 self.pktT = 0.0 self.transT = 0.0 self.recvT = 0.0 self.spareT = 0.0 self.airtime = 0.0 self.goodput = 0.0 # 用于MST中判断节点在哪个集合中,初始集合为0，MST集合为1 self.whichSet = whichSet # 标识一个“节点”是否是网关，输入中第一个“点”为网关，坐标[0, 0] self.isGateway = isGateway self.locX = locX self.locY = locY # 给节点一个索引标识 self.index = index self.relayNum = 0 # 存放了此节点通往其他节点时使用的参数值 self.spreadFactor = [7 for i in range(nodeNum)] self.transPower = [13 for i in range(nodeNum)] self.channel = [1 for i in range(nodeNum)] self.codingRate = [5 for i in range(nodeNum)] self.pdr = 0.0 # 标识此节点的数据直接发送给哪个节点，为Node类型 self.sendTo = self # 标识此节点帮助哪些节点进行数据转发 self.relayFrom = [] # 标识此节点工作在哪个class下，class会影响cycleE self.workClass = 'A' # self._prop = [] def distNode(self, node): dist = math.pow((math.pow((self.locX - node.locX), 2) + math.pow((self.locY - node.locY), 2)), 0.5) # print(self.locX) # print(self.locY) # print(node.locX) # print(node.locY) # print('Distance of ' + self.name + ' to ' + node.name + ' = ' + str(dist)) return dist # 8个信道，从902.1开始每次加0.2 def freq(self, node): frequency = 902.1 + 0.2 * self.channel[node.index] frequency *= math.pow(10, 6) # print('Frequency of channel ' + str(self.channel[node.index]) + ' = ' + str(frequency)) return frequency # Rayleigh fading channel def g(self): reyleigh = np.random.exponential(1.0, size=None) # print(self.name + ' return rayleigh fading channel g of: ' + str(reyleigh)) return reyleigh # 此为论文中的折线图值观测值实现的能耗函数，现替换成计算式方式实现 # energy consumption, unit is mW def enerConsump(self, node): energyPacket = [[40, 50], [50, 67], [65, 85], [95, 105], [100, 125], [110, 135]] clsP = 0 if self.transPower[node.index] &lt;= 15: cls_p = 0 else: cls_p = 1 clsS = self.spreadFactor[node.index] - 7 # rst = energy_packet[cls_s][cls_p] * 0.001 rst = energyPacket[clsS][clsP] # print(\"ec(line 70, unit is mW):\", rst) name = self.name sf = str(self.spreadFactor[node.index]) tp = str(self.transPower[node.index]) # 只是为了下一行不超长... # print('Energy Consumption of ' + name + ' with sf=' + sf + ', tp=' + tp + ' is: ' + str(rst)) return rst # 公式计算方式求energy consumption # def enerConsump(self): def th(self, si): if si == 7: return -6 elif si == 8: return -9 elif si == 9: return -12 elif si == 10: return -15 elif si == 11: return -17.5 elif si == 12: return -20 def ss(self, si): if si == 7: return -123 elif si == 8: return -126 elif si == 9: return -129 elif si == 10: return -132 elif si == 11: return -134.5 elif si == 12: return -137 def tomWatt(self, dBm): mWatt = math.pow(10, (dBm / 10)) # print(self.name + ' dBm to mWatt is: ' + str(mWatt)) return mWatt # 如果有relay，EE计算为payload * pdr1 * pdr2 / (energyInTime1 + energyInTime2) def energyEffi(self, node): tempVar = (8 * self.payload - 4 * self.spreadFactor[node.index] + 28 + 16) / (4 * self.spreadFactor[node.index]) time = (20.25 + max(math.ceil(tempVar) * self.channel[node.index], 0)) * 2 ** self.spreadFactor[node.index] / self.bandW energyInTime = time * self.enerConsump(node) energyEfficiency = self.payload * self.selfToNodePdr(node) / energyInTime # print('EnergyEfficiency of ' + self.name + ' is: ' + str(energyEfficiency)) return energyEfficiency def energyIntime(self, node): tempVar = (8 * self.payload - 4 * self.spreadFactor[node.index] + 28 + 16) / (4 * self.spreadFactor[node.index]) time = (20.25 + max(math.ceil(tempVar) * self.channel[node.index], 0)) * 2 ** self.spreadFactor[ node.index] / self.bandW energyInTime = time * self.enerConsump(node) return energyInTime def energyEffiRelay(self, node1, node2): tempVar1 = (8 * self.payload - 4 * self.spreadFactor[node1.index] + 28 + 16) / (4 * self.spreadFactor[node1.index]) time1 = (20.25 + max(math.ceil(tempVar1) * self.channel[node1.index], 0)) * 2 ** self.spreadFactor[node1.index] / self.bandW energyInTime1 = time1 * self.enerConsump(node1) tempVar2 = (8 * node1.payload - 4 * node1.spreadFactor[node2.index] + 28 + 16) / ( 4 * node1.spreadFactor[node2.index]) time2 = (20.25 + max(math.ceil(tempVar2) * node1.channel[node2.index], 0)) * 2 ** node1.spreadFactor[ node2.index] / node1.bandW energyInTime2 = time2 * node1.enerConsump(node2) energyEfficiency = self.payload * self.selfToNodePdr(node1) * node1.selfToNodePdr(node2) / (energyInTime1 + energyInTime2) return energyEfficiency def relayPdr(self): if(self.isGateway == 1): return 1 else: temp = self.sendTo.relayPdr() * self.selfToNodePdr(self.sendTo) return temp def relayEnergyInTime(self): if(self.isGateway == 1): return 0 else: temp = self.sendTo.relayEnergyInTime() + self.energyIntime(self.sendTo) return temp # 将设备重叠数考虑进来，重叠、channel会降低pdr def selfToNodePdr(self, node): # tempVal1是路径损失函数 tempVar1 = (self.c / (4 * self.pi * self.freq(node) * self.distNode(node))) ** self.beta # print('tempVar1:', tempVar1) # whiteNoise对pdr的影响大 tempVar2 = (self.tomWatt(self.th(self.spreadFactor[node.index])) * self.whiteNoise + self.tomWatt( self.ss(self.spreadFactor[node.index]))) # print('tempVar2:', tempVar2) # 这地方还是有问题！！！！为什么是/1000/1000，对比注释行 # pdr = math.exp(-math.pow(tempVar2 / (self.tomWatt(self.transPower) * tempVar1), 0.5)) pdr = math.exp(-math.pow(tempVar2 / (self.transPower[node.index] * tempVar1), 0.5) / 1000 / 1000) # print('Pdr of ' + self.name + ' to ' + node.name + ' is: ' + str(pdr)) return pdr # 主文件里先确定sendTo谁，再更新transT值 def updateTransT(self): self.symbleT = math.pow(2, self.spreadFactor[self.sendTo.index]) / self.bandW tempVal1 = 8 * self.payload - 4 * self.spreadFactor[self.sendTo.index] + 28 + 16 tempVal2 = 20.25 + max(math.ceil(tempVal1 / (4 * self.spreadFactor[self.sendTo.index])) * self.codingRate[self.sendTo.index], 0) self.pktT = self.symbleT * tempVal2 # 计算transT # 此节点将数据（包括自己的和中转的）发给其将要发至的节点时的pdr pdr = self.selfToNodePdr(self.sendTo) if pdr != 0: if self.relayFrom: for child in self.relayFrom: # 根据中继了哪些节点来更新dataSend的数据量，dataSend是此节点总共发送的数据量 # 若此节点非中继节点，则dataSend == dataGen self.dataSend += child.dataGen self.transT = self.pktT * self.cycleT / self.dataSend / pdr else: self.transT = 10000 return self.transT # 确定在self.relayFrom中添加完所有的远端节点后再进行更新 def updateRecvT(self): # 计算recvT，此时间包括自身发送时的class A模式的部分和中继时class B模式的recv time # 没考虑作为发送端时的recvT，因为发送时工作在classA，只在发送数据的时候顺便开一个窗口接收数据，暂时不知道窗口总时长 if self.relayFrom: if self.relayFrom: for child in self.relayFrom: self.recvT += child.transT print('Update transT of ' + self.name + ' to: ' + str(self.recvT)) return self.recvT def lifetime(self): # 设置transRadioE级别（87和120） if self.transPower[self.sendTo.index] &lt; 15: self.transRadioE = 3.3 * 87e-3 self.spareT = self.dutyCycle * self.cycleT - self.transT - self.recvT radioOnE = self.transT * self.transRadioE + self.recvT * self.recvRadioE + self.spareT * self.spareRadioE radioOffE = (1 - self.dutyCycle) * self.cycleT * self.offRadioE mcuE = self.cycleT * self.dutyCycle * self.onMcuE + self.cycleT * (1 - self.dutyCycle) * self.offMcuE self.cycleE = radioOnE + radioOffE + mcuE self.lifeT = self.cycleT * self.batteryE / self.cycleE / 3600 / 24 print('Lifetime of ' + self.name + ' is: ' + str(self.lifeT)) return self.lifeT def goodput(self): # 注意：goodput中计算的数据量用的是dataGen，而不是dataSend goodput = self.cycleT / self.dataGen * self.payload / self.transT print('Goodput of ' + self.name + ' is: ' + goodput) return goodput TopoWithMST.py:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310from MST.Node.NodeClass import Nodeimport randomimport matplotlib.pyplot as pltimport numpy as npimport mathimport scipy as syfrom scipy import statsimport xlsxwriter# 添加node要修改三个地方，node初始化，nodes列表添加该node，nodeNum值# 常量，全局变量均以“_”开头命名# _nodeNum = 6 # device number_payload = 4 # payload size of a packet, need to be modified_bandW = 125000_c = 3 * 10 ** 8_pi = 3.1415926_beta = 3 # path loss exponent, maybe a list, need to be init_whiteNoise = random.random() # gauss white noise_dutyCycle = 0.02_batteryE = 3.7 * 2 * 3600_dataGen = 2000# Radio耗电常量_cycleT = 3600 * 12_transRadioE = 3.3 * 120e-3 # 29, 87, 120_recvRadioE = 3.3 * 11.5e-3_spareRadioE = 3.3 * 1.6e-3_offRadioE = 3.3 * 1.5e-6# Known and Unknown... P10 MCU耗电情况_onMcuE = 23.48e-4_offMcuE = 174.65e-7sfRange = [7,8,9,10,11,12]tpRange = [13,14,15,16,17,18,19,20]chRange = [1,2,3,4,5,6,7,8]crRange = [5,6,7,8]nodeNum = 18# _node0是网关，所以isGateway=1, whichSet=1_node0 = Node('_node0', 0, 0, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, isGateway=1, whichSet=1)_node1 = Node('_node1', -2800, -500, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, index=1)_node2 = Node('_node2', 2500, 2700, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, index=2)_node3 = Node('_node3', 1000, 800, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, index=3)_node4 = Node('_node4', 2500, 0, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, index=4)_node5 = Node('_node5', 1000, 0, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, index=5)_node6 = Node('_node6', 1500, 2000, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, index=6)_node7 = Node('_node7', -800, 700, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, index=7)_node8 = Node('_node8', -600, -400, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, index=8)_node9 = Node('_node9', -1000, -1200, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, index=9)_node10 = Node('_node10', -1800, -2000, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, index=10)_node11 = Node('_node11', -2000, 1800, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, index=11)_node12 = Node('_node12', 1500, -2000, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, index=12)_node13 = Node('_node13', 500, -500, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, index=13)_node14 = Node('_node14', 1200, -1200, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, index=14)_node15 = Node('_node15', 2000, -2500, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, index=15)_node16 = Node('_node16', -2500, -2000, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, index=16)_node17 = Node('_node17', 2500, 1000, nodeNum, _payload, _bandW, _c, _pi, _beta, _whiteNoise, _dutyCycle, _batteryE, _dataGen, _cycleT, _transRadioE, _recvRadioE, _spareRadioE, _offRadioE, _onMcuE, _offMcuE, index=17)# 先求所有的边权（取所有sf，tp，cr选择中代价最小的）存储，再用MST连线（每次连线需根据isGateway确定代价是否叠加）划分集合，直到原本集合为空indexes= [i for i in range(nodeNum)]# print(indexes)nodes = [_node0, _node1, _node2, _node3, _node4, _node5, _node6, _node7, _node8, _node9, _node10, _node11, _node12, _node13, _node14, _node15, _node16, _node17]# 初始化代价矩阵costMatrix = [[0.0 for i in range(nodeNum)] for j in range(nodeNum)]# 注意python中不可用 energyEffiMatrix = costMatrix形式给矩阵赋值# 否则energyEffiMatrix的值会随costMatrix的变化而变化energyEffiMatrix = [[0.0 for i in range(nodeNum)] for p in range(nodeNum)]# 计算每条边的代价，存入代价矩阵（不过记得后面MST时代价会根据是否relay确定是否进行叠加）# 求每条边的代价实际上是先做预处理求最小代价，即遍历了可选的sf、tp、cr、# 需要考虑sf和ch相同导致的重叠,暂未添加# zip的使用for rowIndex, node in zip(indexes, nodes): for colIndex, coloum in zip(indexes, nodes): if node is not coloum: # 针对某一条边求cheapest代价 maxEE = 0 setSpreadFactor = 7 setTransPower = 13 setChannel = 1 setCodingRate =5 for sf in sfRange: for tp in tpRange: for ch in chRange: for cr in crRange: node.spreadFactor[coloum.index] = sf node.transPower[coloum.index] = tp node.channel[coloum.index] = ch node.codingRate[coloum.index] = cr tempEE = node.energyEffi(coloum) if(maxEE &lt; tempEE): maxEE = tempEE setSpreadFactor = sf setTransPower = tp setChannel = ch setCodingRate = cr node.spreadFactor[coloum.index] = setSpreadFactor node.transPower[coloum.index] = setTransPower node.channel[coloum.index] = setChannel node.codingRate[coloum.index] = setCodingRate costMatrix[rowIndex][colIndex] = maxEE else: costMatrix[rowIndex][colIndex] = 0.1for row in range(nodeNum): for col in range(nodeNum): energyEffiMatrix[row][col] = costMatrix[row][col]for n in range(0, nodeNum): print(costMatrix[n])# 代价是能量效率的倒数for row in range(nodeNum): for col in range(nodeNum): costMatrix[row][col] = 1 / costMatrix[row][col]print('cost statistic:')for n in range(0, nodeNum): print(costMatrix[n])# print(_node1.spreadFactor)# print(_node1.transPower)# print(_node1.channel)# print(_node1.codingRate)# 此部分仍有问题，需核对pdr和代价（能量效率EE）计算中各个参数对energy efficiency的影响toWhichIndexes= [i for i in range(nodeNum)]# u集合中的节点数uNodeNum = 1while(uNodeNum != nodeNum): minCost = 9999 addRelay = nodes[0] ifRelay = False nodeToUSet = nodes[0] backTrack = nodes[0] for nodeIndex in range(0, nodeNum): # minCost = 9999 # toWhichIndex为当前查看的v集合中的节点的index，可通过nodes列表反索引到相应的node # thisLineCost为单条边的cost，我们需要的是实际的cost（即带relay） # relay是在MST的过程中产生的 # 网关初始应在u集合，对应的whichSet=1 # addRelay = nodes[0] # ifRelay = False # nodeToUSet = nodes[0] for toWhichIndex, thisLineCost in zip(toWhichIndexes, costMatrix[nodeIndex]): # 一个节点属于u集合，一个节点属于v集合，才进行处理，否则不符合MST要求，进行下轮循环 # addRelay = nodes[0] # ifRelay = False # nodeToUSet = nodes[0] if (nodes[nodeIndex].whichSet == 1 and nodes[toWhichIndex].whichSet == 0): # if ((nodes[nodeIndex].whichSet == 1 and nodes[toWhichIndex].whichSet == 0) or # (nodes[nodeIndex].whichSet == 0 and nodes[toWhichIndex].whichSet == 1)): # 其中有一个是网关的话，说明与网关直接相连，thisLineCost即为realCost if (nodes[nodeIndex].isGateway == 1 or nodes[toWhichIndex].isGateway == 1): realCost = thisLineCost if realCost &lt; minCost: print('node:', nodes[nodeIndex].name, ' nodeTo:', nodes[toWhichIndex].name) backTrack = nodes[nodeIndex] ifRelay = False minCost = realCost nodeToUSet = nodes[toWhichIndex] # 所检索的边不是与网关直接相连，需要中继 else: # print(nodes[nodeIndex].name, nodes[toWhichIndex].name, thisLineCost, costMatrix[toWhichIndex][0], minCost) # 需要中继的，先把代价求倒数转换成EE，两段EE相加之后再求倒数得到整段的代价 # [0]代表中继节点到网关的代价，因为网关为矩阵的第一列 # cost计算方式1 # realCost = thisLineCost + costMatrix[nodeIndex][0] # cost计算方式2，见NodeClass中EE计算函数注释 # 这里energyEffiiRelay的实现实际应该是有递归，比如如果有两次relay，则 # payload * pdr1 * pdr2 * pdr3 / (energyInTime1 + energyInTime2 + energyInTime3)，怎么实现? # 分别实现一个pdr的递归和一个energyInTime的递归 energyEffiRelay = nodes[toWhichIndex].payload * nodes[toWhichIndex].selfToNodePdr(nodes[nodeIndex]) * nodes[nodeIndex].relayPdr() / (nodes[toWhichIndex].energyIntime(nodes[nodeIndex]) + nodes[nodeIndex].relayEnergyInTime()) realCost = 1 / energyEffiRelay if realCost &lt; minCost: # 如果12-0代价大于12-14-0，修改cost矩阵，将costMatrix[12][0]修改为12-14-0（经14中继）的代价 costMatrix[toWhichIndex][0] = realCost # print(minCost) print('node:', nodes[nodeIndex].name, ' nodeTo:', nodes[toWhichIndex].name) print(1 / thisLineCost) print(1 / costMatrix[nodeIndex][0]) print(realCost) backTrack = nodes[nodeIndex] addRelay = nodes[toWhichIndex] # node类型 ifRelay = True minCost = realCost nodeToUSet = nodes[toWhichIndex] # 如果有中继的拓扑选择，为中继点修改relayNum, relayFrom信息 if (ifRelay == True and addRelay): # addRelay.relayNum += 1 # addRelay.relayFrom.append(backTrack.name) backTrack.relayNum += 1 backTrack.relayFrom.append(addRelay.name) # 把新选择的节点添加到U集合 nodeToUSet.whichSet = 1 # 注意生成树的方向 # 到最后应该_node0(网关)的sendTo没什么用 nodeToUSet.sendTo = backTrack uNodeNum += 1 print('one loop.')for n in range(0, nodeNum): print(energyEffiMatrix[n]) print(costMatrix[n])# 测试结果for n in range(0, nodeNum): print(costMatrix[n])# 检查拓扑print('Topo statistic:')for n in range(0, nodeNum): print(nodes[n].name + ' send to ' + nodes[n].sendTo.name)print('nodes belong to which set:')# 检查集合setList = []for n in range(0, nodeNum): # print(nodes[n].whichSet) setList.append(nodes[n].whichSet)print(setList)# 检查每个节点的relayNum# relayNum技术规则还有问题print(' relay number statistic: ')for n in range(0, nodeNum): print(nodes[n].name + ' relay number: ' + str(nodes[n].relayNum))print('params choise:')for n in range(0, nodeNum): # 现有结果表明优先增大tp，增到最大才开始增加sf，即增大sf带来的代价远超增大tp print(nodes[n].name + ' sf: ' + str(nodes[n].spreadFactor) + ' tp:' + str(nodes[n].transPower) + ' cr:' + str(nodes[n].codingRate))print('relay:')for n in range(0, nodeNum): print(nodes[n].name , 'relay:', nodes[n].relayFrom)# 检查EEprint('EE origin:')for n in range(1, nodeNum): print(nodes[n].name, ' EE origin:', energyEffiMatrix[n][0])print('EE final:')for n in range(1, nodeNum): print(nodes[n].name, ' EE final:', 1 / costMatrix[n][0])# 绘图plt.subplot(121)for n in range(0, nodeNum): thisNodeLoc = [nodes[n].locX, nodes[n].locY] sendToNodeLoc = [nodes[n].sendTo.locX, nodes[n].sendTo.locY] plt.scatter(thisNodeLoc[0], thisNodeLoc[1], s=10, color='b') plt.plot([thisNodeLoc[0], sendToNodeLoc[0]], [thisNodeLoc[1], sendToNodeLoc[1]]) plt.annotate(thisNodeLoc, xy=(thisNodeLoc[0], thisNodeLoc[1]), xytext=(thisNodeLoc[0]+1, thisNodeLoc[1]+1))plt.xlim(-2800,2800)plt.ylim(-2800,2800)# 绘EE柱状图# subplot绘制子图plt.subplot(122)nodeNameList = []nodeEEOriginList = []nodeEEFinalList = []for n in range(0, nodeNum): nodeNameList.append(str(n)) nodeEEOriginList.append(energyEffiMatrix[n][0]) nodeEEFinalList.append(1 / costMatrix[n][0])total_width, n = 0.8, 2width = total_width / nplt.bar(indexes, nodeEEOriginList, width=width, label='1', fc='b')for i in range(len(indexes)): indexes[i] += widthplt.bar(indexes, nodeEEFinalList, width=width, label='2', tick_label=nodeNameList, fc='g')plt.legend()plt.show()","categories":[{"name":"Python","slug":"Python","permalink":"https://chasencenge.github.io/categories/Python/"},{"name":"Lora","slug":"Python/Lora","permalink":"https://chasencenge.github.io/categories/Python/Lora/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://chasencenge.github.io/tags/Python/"},{"name":"Lora","slug":"Lora","permalink":"https://chasencenge.github.io/tags/Lora/"}]},{"title":"hexo更换flex-block主题","slug":"hexo更换flex-block主题","date":"2020-07-17T03:00:22.000Z","updated":"2020-08-04T17:08:54.255Z","comments":true,"path":"2020/07/17/hexo更换flex-block主题/","link":"","permalink":"https://chasencenge.github.io/2020/07/17/hexo更换flex-block主题/","excerpt":"","text":"基础配置hexo/_config.yml文件中： 1theme: flex-block 为了能够正常显示图片，在hexo/_config.yml： 12# Writingpost_asset_folder: true 这样每次创建新文件时会生成一个asset文件夹，用到的图片素材均放在此同名文件夹中进行调用 还需安装相应插件： 1npm install https://github.com/CodeFalling/hexo-asset-image --save 在相应的.md文件中调用图片资源时，切记！！！！💊💊💊 调用图片资源的路径直接写图片文件名，默认路径已经切到相应同名文件夹下，不可使用绝对路径名！！！！ 修改新建文件时给出的默认Front-MatterFront-Matter说明 修改hexo/scaffolds下的： draft.md, page.md, post.md 修改方式见：https://github.com/miiiku/flex-block 添加代码高亮https://highlightjs.org/ 下载依赖： 1npm install highlight.js hexo/_config.yml: 12345678highlight: enable: true line_number: true auto_detect: false tab_replace: hljs: true # theme: railscasts theme: pojoaque 添加社交平台链接hexo/themes/flex-block/_config.yml: 12345678910111213social_icon: header_enable: true footer_enable: true icons: - &#123; type: email, value: 958198376@qq.com&#125; - &#123; type: github, value: https://github.com/CHAsencenge&#125; - &#123; type: google+, value: &#125; - &#123; type: ins, value: &#125; - &#123; type: twitter, value: &#125; - &#123; type: youtube, value: &#125; - &#123; type: weibo, value: https://weibo.com/u/5701921017&#125; - &#123; type: cloudmusic, value: https://music.163.com/#/user/home?id=92407481&#125; - &#123; type: zhihu, value: &#125; 修改主页标签显示（英文-&gt;中文）hexo/themes/flex-block/_config.yml: 修改其中的menu: 123456menu: 主页: / 关于: /about 友链: /links 标签: /tags 分类: /categories 添加友链页面并顺手放些要用的图片资源添加友链页面：(顺口一提，hexo new page 会生成与_post同级的文件夹) 1hexo new page links 在links/index.md中修改Front-matter，添加： 1type: links 确认hexo/themes/flex-block/_config.yml中是否有(左侧为标签显示，不重要，重要的是是否写了右侧的/links目录)： 1links: /links 存放友链数据在source目录下(与_post同级) ， 创建: _data文件夹 在source/_data下新建links.yml 一行一条友链数据，格式如下(现在links文件夹下创建Asset文件夹，存放相应的图片资源，并push到仓库，因为cover参数需要url，不能是本地路径，所以将资源推到仓库同时从仓库的对应url取图片资源作为cover)： 1234567891011121314151617181920- &#123; \"name\" : \"tianzixiao\", \"describe\" : \"测试\", \"link\" : \"Asset/tianzixiao.png\", \"cover\" : \"https://chasencenge.github.io/links/Asset/tianzixiao.png\" &#125;- &#123; \"name\" : \"cover1\", \"describe\" : \"测试\", \"link\" : \"Asset/cover1.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover1.jpg\" &#125;- &#123; \"name\" : \"cover2\", \"describe\" : \"测试\", \"link\" : \"Asset/cover2.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover2.jpg\" &#125;- &#123; \"name\" : \"cover3\", \"describe\" : \"测试\", \"link\" : \"Asset/cover3.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover3.jpg\" &#125;- &#123; \"name\" : \"cover4\", \"describe\" : \"测试\", \"link\" : \"Asset/cover4.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover4.jpg\" &#125;- &#123; \"name\" : \"cover5\", \"describe\" : \"测试\", \"link\" : \"Asset/cover5.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover5.jpg\" &#125;- &#123; \"name\" : \"cover6\", \"describe\" : \"测试\", \"link\" : \"Asset/cover6.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover6.jpg\" &#125;- &#123; \"name\" : \"cover7\", \"describe\" : \"测试\", \"link\" : \"Asset/cover7.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover7.jpg\" &#125;- &#123; \"name\" : \"cover8\", \"describe\" : \"测试\", \"link\" : \"Asset/cover8.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover8.jpg\" &#125;- &#123; \"name\" : \"cover9\", \"describe\" : \"测试\", \"link\" : \"Asset/cover9.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover9.jpg\" &#125;- &#123; \"name\" : \"cover10\", \"describe\" : \"测试\", \"link\" : \"Asset/cover10.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover10.jpg\" &#125;- &#123; \"name\" : \"cover11\", \"describe\" : \"测试\", \"link\" : \"Asset/cover11.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover11.jpg\" &#125;- &#123; \"name\" : \"cover12\", \"describe\" : \"测试\", \"link\" : \"Asset/cover12.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover12.jpg\" &#125;- &#123; \"name\" : \"cover13\", \"describe\" : \"测试\", \"link\" : \"Asset/cover13.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover13.jpg\" &#125;- &#123; \"name\" : \"cover14\", \"describe\" : \"测试\", \"link\" : \"Asset/cover14.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover14.jpg\" &#125;- &#123; \"name\" : \"cover15\", \"describe\" : \"测试\", \"link\" : \"Asset/cover15.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover15.jpg\" &#125;- &#123; \"name\" : \"cover16\", \"describe\" : \"测试\", \"link\" : \"Asset/cover16.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover16.jpg\" &#125;- &#123; \"name\" : \"cover17\", \"describe\" : \"测试\", \"link\" : \"Asset/cover17.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover17.jpg\" &#125;- &#123; \"name\" : \"cover18\", \"describe\" : \"测试\", \"link\" : \"Asset/cover18.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover18.jpg\" &#125;- &#123; \"name\" : \"cover19\", \"describe\" : \"测试\", \"link\" : \"Asset/cover19.jpg\", \"cover\" : \"https://chasencenge.github.io/links/Asset/cover19.jpg\" &#125; 修改主页bannerhexo/themes/flex-block/_config.yml: 1banner: https://chasencenge.github.io/links/Asset/cover19.jpg 关于card无法显示cover图片的问题在主页按F12查看页面bug，发现无法找到cover.jpg，对比其他文章页面，无error，说明主页card的图片寻径和文章页的cover寻径不同 在F12调试工具中-&gt;Application，对比主页和文章页查看，发现各自的image加载是在各自的index.html同级目录下，故将用到的所有文件资源复制到hexo/public目录下，但是此目录仅支持主页正常显示，翻页时会进入page2，page3等等，所以将所用到的card资源同样放置在hexo/public/page/2、hexo/public/page/3等目录下 btw，为了保证主页card显示的图片不冲突，以上目录下的图片不可重名，又由于以上目录的图片名需与hexo/source/_post中的每一篇的cover同名，故每个文章的asset-folder中的cover命名不要重名，文章front-matter同理 asset-folder的cover命名： front-matter的cover命名保证与asset-folder一致，并与hexo/public中的资源名称一致：1cover: cover22.jpg 添加鼠标拖拽如果没有拖拽移动的功能，代码部分无法通过鼠标拖拽看到右侧超出框宽的部分，页面很长时也无法通过拖拽快速下拉，只能用滚轮，很不方便 解决：打开flex-block文件夹，source/css/style.styl，将9-11行注释掉","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://chasencenge.github.io/categories/Hexo/"},{"name":"Environment","slug":"Hexo/Environment","permalink":"https://chasencenge.github.io/categories/Hexo/Environment/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://chasencenge.github.io/tags/Hexo/"}]},{"title":"Laya Basketball小游戏踩坑历程","slug":"Laya-Basketball小游戏踩坑历程","date":"2020-07-17T01:39:43.000Z","updated":"2020-07-24T09:06:45.280Z","comments":true,"path":"2020/07/17/Laya-Basketball小游戏踩坑历程/","link":"","permalink":"https://chasencenge.github.io/2020/07/17/Laya-Basketball小游戏踩坑历程/","excerpt":"Laya3D小项目中的踩坑历程","text":"Laya3D小项目中的踩坑历程 .lh or .ls测试Unity导出的Scene（仅包含3D球架）在导入Laya后的显示，发现若导出.lh文件，在Laya创建的Scene中挂载脚本运行时会报“cannot read ‘_addCamera’ of undefined”错误，解决此问题时选择重新导出.ls文件 相应脚本： 123456789101112131415161718import &#123; ui &#125; from \"./../ui/layaMaxUI\";export default class SmallScene extends Laya.Script &#123; constructor() &#123; super(); &#125; onEnable(): void &#123; Laya3D.init(0, 0); Laya.Stat.show(); Laya.stage.scaleMode = Laya.Stage.SCALE_FULL; Laya.stage.screenMode = Laya.Stage.SCREEN_NONE; Laya.Scene3D.load(\"res/Loading/LayaScene_SmallScene/Conventional/SmallScene.ls\", Laya.Handler.create(null, function(scene:Laya.Scene3D):void &#123; Laya.stage.addChild(scene) as Laya.Scene3D; &#125;)); &#125; onDisable(): void &#123; &#125;&#125;new SmallScene; 导出文件说明：ls — 场景文件： Json文件，包含场景中所有节点的数据信息，包含光照贴图信息lh — 层级文件： Json文件，包含场景中所有节点的数据信息，不包含光照贴图信息lt — 地形文件： Json文件，包含地形中的数据信息lm — 网格文件： 二进制文件，包含模型所有顶点的数据信息lmat — 材质文件： Json文件，包含光照，贴图，渲染模式等基本材质信息lsani — 蒙皮动画文件：二进制文件，包含骨骼动画帧率信息lrani — 刚体动画文件：二进制文件，包含刚体动画帧率信息lav — 新版动画节点文件：Json文件，只包含Animator组件下节点的数据信息lani — 新版动画文件：二进制文件，包含Animator动画帧率信息 Mesh Collider 和 Box Collider的选择：篮筐处有两个Trigger，一个在篮筐一个在篮网，篮筐环附近用Box Collider（元碰撞器），篮网用Mesh Collider（网格），后者渲染时消耗资源比前者大很多 如何进一步操作导入的Scene中的子对象？laya.display.Node 测试时在Laya.Scene3D.load的call中添加： 1console.log(\"scene.numChildren:\", scene.numChildren); 可在运行时查看scene中的子对象个数 其他类似操作代码如下： 123456789101112Laya.Scene3D.load(\"res/Loading/LayaScene_SmallScene/Conventional/SmallScene.ls\", Laya.Handler.create(null, function(scene:Laya.Scene3D):void &#123; //myScene = scene; Laya.stage.addChild(scene) as Laya.Scene3D; //var camera = new Laya.Camera(0, 3, 10); //scene.addChild(camera); console.log(\"scene.numChildren:\", scene.numChildren); let sprite:Laya.Sprite3D = new Laya.Sprite3D(); scene.addChildAt(sprite, 5); console.log(scene.getChildAt(3).name); console.log(scene.getChildAt(4).name); console.log(scene.getChildAt(5).name); &#125;)); 关于Laya.Handler.createHandler是事件处理器类 laya.utils.Handler create(caller:*, method:Fuction, args:Array = null, once:Boolean = true): Handler caller:* -执行域(this) method:Function -回调方法 args:Array -携带的参数 once:Boolean -是否只执行一次，默认为true 注意once后或者Handler.recover()后不要再使用此对象 流程GolbalDataScene -&gt; StartScene -&gt; LoadingScene -&gt; GameScene GolbalDataScene/GameStaticController/ConfigController中控制加载Assets/Resources/Config中的BallsData和StageData 一些说明每个Scene中的UIController是用相同的BSK Manager脚本，即，所有场景能用到的UI相关的管理控制都放在这个脚本，其他通用的Cotorller也如此 reset球的函数在BSKGameController -&gt; resetBalls，设置了篮球的初始化位置，Rotation，layer，放到balls列表（但是没有设置其物理属性如重力、碰撞） 给篮球（balls）获取BSKBall组件、添加刚体、并且siKinematic = true使物理影响刚体在BSKShooter中的Update函数中（Update每一帧都调用） 在Laya中创建的对应脚本的类型的选择要考虑Unity中对应脚本是否有Update等逐帧刷新的功能 对Unity中具有Update等逐帧刷新的Component（Monobehavior），在Laya中创建对应脚本所选类型要考虑是否有相同逐帧刷新的内置函数 BSKBall -&gt; Start函数： 1gameObject.GetComponent&lt;Renderer&gt;().material = BSKGameConfig.s_Instance.GetBallMaterial(); 篮球资源是如何加载进去的：在BSKGameController声明一个GameObject对象-BallPrefab，然后在Unity的Inspector中可以直接选取需要的“lanqiu”资源 将Unity中的Scene导入Laya时，games_bg不能导入，因为不支持Sprite Renderer","categories":[{"name":"Laya","slug":"Laya","permalink":"https://chasencenge.github.io/categories/Laya/"}],"tags":[{"name":"Laya","slug":"Laya","permalink":"https://chasencenge.github.io/tags/Laya/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://chasencenge.github.io/tags/TypeScript/"}]},{"title":"LoRa的三种class","slug":"LoRa的三种class","date":"2020-07-14T14:30:06.000Z","updated":"2020-07-20T02:36:29.406Z","comments":true,"path":"2020/07/14/LoRa的三种class/","link":"","permalink":"https://chasencenge.github.io/2020/07/14/LoRa的三种class/","excerpt":"LoRa class A, class B, class C三种工作模式","text":"LoRa class A, class B, class C三种工作模式 class AClass A 是 LoRaWAN 强制要求所有 LoRa 终端设备必须支持的通信模式。在Class A中，终端设备只在有数据需要处理或发送的时候才从休眠模式中醒来，并且一切通信都只能由发送终端设备主动发起，网关一直处于侦听模式。当发送终端设备进行一次发送（TX）之后，会等待时间T(RX_DELAY1)之后初始化一个接收窗口RX1，若RX1内发送终端设备未收到任何数据，则会在T_(RX_DELAY2)时间后再初始化一个接收窗口RX2，继续等待接收数据，窗口关闭后则进入睡眠模式。网关可在此窗口时间内向终端设备发送数据 接收窗口RX1一般是在上行后1秒开始，接收窗口RX2是在上行后2秒开始 终端有数据了，就上报，顺便收一下服务器下发的指令。终端没数据的时候，服务器下发不了指令 class BClass B 为需要双向交互的应用设计。在 Class A 的基础上增加了可以由网关主动唤醒发送终端设备的机制，网关每隔 T_Beacon 时间会发送一个 Beacon 来主动唤醒终端设备，在两个 Beacon 之间，终端设备的通信模式和 Class A 相同。通过 Class B 主动唤醒节点的方式，网关可以定期开启终端设备的下载和上传功能。相比 Class A，Class B 降低了数据的传输时延，但也增加了终端设备的能耗 有一个同步时隙beacon，还有一个固定周期的接收窗口ping时隙。(隔几十秒收一个数据。其他时候都在休眠) 终端和基站约定一个时间下发数据，终端和基站依靠beacon信号校对时间，确保约定的时间不会错位 ClassB的目的是使得节点具有在预定时间打开接收窗口（称之为ping slot）的能力。一个支持ClassB的网络，所有的网关都必须同步发送beacon class CClass C 用于时延要求高的应用，发送终端设备再发送完成之后会立即初始化接收窗口，若未收到任何数据，则会一直开启随后的RX2窗口持续侦听信道，用于接收网关返回的数据 在class A的基础上，在class A休眠期间，一直打开接收窗口RX2（几乎随时可以接收数据） BeaconLoRa一旦约定好了时间，基站就默认设备一定会在那个时间点接收，所以需要严格的时间同步。Beacon则是时间同步的最关键的地方 节点由ClassA切换到ClassB之前必须收到beacon，进入ClassB之后还需要周期搜索/接收beacon，从而同步时钟。Class B节点可能临时收不到beacon，此时节点要逐渐加宽beacon和ping的接收窗。如果收到beacon后2小时收不到新的beacon，节点需使用内部时钟保持同步","categories":[{"name":"LoRa","slug":"LoRa","permalink":"https://chasencenge.github.io/categories/LoRa/"}],"tags":[{"name":"LoRa","slug":"LoRa","permalink":"https://chasencenge.github.io/tags/LoRa/"}]},{"title":"C++.h和.cpp","slug":"C-h和-cpp","date":"2020-07-13T03:04:52.000Z","updated":"2020-07-20T02:27:33.402Z","comments":true,"path":"2020/07/13/C-h和-cpp/","link":"","permalink":"https://chasencenge.github.io/2020/07/13/C-h和-cpp/","excerpt":"C++的.h文件和.cpp文件各应该包含什么内容","text":"C++的.h文件和.cpp文件各应该包含什么内容 .h文件类的声明，成员函数声明… 记得在头部添加： 123#ifndef XXXX_H //这里如果头文件名为LoraNode.h, 则写为LORANODE_H#define XXXX_H#pragma once //这个一般在创建头文件的时候会自动添加 尾部添加： 1#endif 目的是为了防止重复编译而报错 .cpp文件填写类成员函数的定义 首先引用头文件 1#include \"xxxx.h\" 注：不用再重写class Name{}，否则会报错为class重定义，直接使用::进行外部定义类成员函数即可 例： 123double LoraNode::th(si)&#123;...&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://chasencenge.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://chasencenge.github.io/tags/C/"}]},{"title":"将Unity场景导入到LayaAir","slug":"将Unity场景导入到LayaAir","date":"2020-07-09T01:02:46.000Z","updated":"2020-07-20T02:40:39.069Z","comments":true,"path":"2020/07/09/将Unity场景导入到LayaAir/","link":"","permalink":"https://chasencenge.github.io/2020/07/09/将Unity场景导入到LayaAir/","excerpt":"","text":"将U3D插件拖拽到Unity项目的Assets目录下，会自动在项目中import LayaAir3D选项 LayaAir3d-&gt;Export Tool中可以导出Unity Scene 导出到laya工程下的bin-&gt;res文件夹 LayaAir3D-&gt;Help-&gt;Tutorial可看哪些是能够兼容的 骨骼动画： spine骨骼动画工具 骨骼动画: 把动画打散, 通过工具，调骨骼的运动等来形成动画spine是一个非常流行的2D骨骼动画制作工具spine 动画美术人员导出3个文件: (1) .png文件:动画的”骨骼”的图片集; (2).atlas文件: 每个骨骼在图片集里面位置，大小; (3).json文件: 骨骼动画的anim控制文件,以及骨骼位置等信息;骨骼动画导入: 直接把三个文件拷贝到项目的资源目录下即可;使用骨骼动画 2种方式: (1) 直接拖动到场景; (2) 创建一个节点来添加sp.Skeleton组件; Unity的骨骼动画：Unity导入骨骼动画时需要的源文件也是spine导出的： .atlas .json .png三个文件，不过需要将.atlas重命名为.atlas.txt Laya的骨骼动画：Laya的骨骼动画在导入的时候是直接对接Spine导出的骨骼动画格式的，即.atlas .json .png三个文件","categories":[{"name":"Laya","slug":"Laya","permalink":"https://chasencenge.github.io/categories/Laya/"},{"name":"Environment","slug":"Laya/Environment","permalink":"https://chasencenge.github.io/categories/Laya/Environment/"}],"tags":[{"name":"Laya","slug":"Laya","permalink":"https://chasencenge.github.io/tags/Laya/"},{"name":"Environment","slug":"Environment","permalink":"https://chasencenge.github.io/tags/Environment/"}]},{"title":"为Sublime添加TypeScript高亮支持","slug":"为Sublime添加TypeScript高亮支持","date":"2020-07-09T00:50:23.000Z","updated":"2020-07-20T02:43:30.256Z","comments":true,"path":"2020/07/09/为Sublime添加TypeScript高亮支持/","link":"","permalink":"https://chasencenge.github.io/2020/07/09/为Sublime添加TypeScript高亮支持/","excerpt":"","text":"首先在cmd或者Git CMD安装typescript编译支持：npm install -g typescript 若出现npm ERR! code EINTEGRITY报错： npm cache verify 打开sublime安装package control：在sublime中ctrl+shift+p打开命令面板 输入ip查找Package Control: Installl Package 打开package control安装TypeScript：打开preference-&gt;package control，然后继续查找TypeScript进行安装","categories":[{"name":"Laya","slug":"Laya","permalink":"https://chasencenge.github.io/categories/Laya/"}],"tags":[{"name":"Environment","slug":"Environment","permalink":"https://chasencenge.github.io/tags/Environment/"}]},{"title":"UnitySprite","slug":"UnitySprite","date":"2020-07-08T01:35:52.000Z","updated":"2020-07-20T02:39:25.922Z","comments":true,"path":"2020/07/08/UnitySprite/","link":"","permalink":"https://chasencenge.github.io/2020/07/08/UnitySprite/","excerpt":"Sprite相关","text":"Sprite相关 Sprite RendererFlip：勾选后图片会在X或Y轴方向上翻转 Material:材质，默认是Sprites - Default，场景中的灯光不会影响到图片，改为Default - Diffuse，灯光可以照亮图片 Draw Mode：绘图模式, 普通，拉伸，平铺 Sorting Layer：分类层，控制图片的渲染顺序，点开Sorting Layer，越靠下的越后渲染，越在最前面，挡住后面的图片 Order In Layer：在同一层中的次序，当图片在同一个层下时，设置此数值可以再次控制渲染顺序 Mask Interaction：遮罩交互 打包图集Editor-&gt;Project Settings-&gt;Editor下面有sprite packer的模式。Disabled表示不启用它，Enabled For Builds 表示只有打包的时候才会启用它，Always Enabled 表示永远启用它。 这里的启用它就表示是否将小图自动打成图集。 .prefab文件 .prefab文件在Unity引擎中，扮演着配置文件的作用，用它将多个组件关联在了一起，组成了一个整体，默认是一个二进制文件 .meta文件新的资源导入Unity时，Unity会自动做下面这件事： 1.分配唯一ID 2.创建.meta文件 3.处理资源 .meta文件包含内容： guid：分配的唯一ID存在这里 MonoImporter：它的数据是不同的ImprotSetting数据，比如Mode Improter，Audio Improter等等，对照Inspector面板就可以看懂每行数据","categories":[{"name":"Unity","slug":"Unity","permalink":"https://chasencenge.github.io/categories/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://chasencenge.github.io/tags/Unity/"},{"name":"Sprite","slug":"Sprite","permalink":"https://chasencenge.github.io/tags/Sprite/"}]},{"title":"ProjectTiny爬坑记录","slug":"ProjectTiny爬坑记录","date":"2020-07-07T13:23:22.000Z","updated":"2020-07-20T02:37:18.401Z","comments":true,"path":"2020/07/07/ProjectTiny爬坑记录/","link":"","permalink":"https://chasencenge.github.io/2020/07/07/ProjectTiny爬坑记录/","excerpt":"","text":"","categories":[{"name":"Tiny","slug":"Tiny","permalink":"https://chasencenge.github.io/categories/Tiny/"},{"name":"Unity","slug":"Tiny/Unity","permalink":"https://chasencenge.github.io/categories/Tiny/Unity/"}],"tags":[{"name":"Tiny","slug":"Tiny","permalink":"https://chasencenge.github.io/tags/Tiny/"},{"name":"Unity","slug":"Unity","permalink":"https://chasencenge.github.io/tags/Unity/"}]},{"title":"ProjectTinyWorkshop核心知识点","slug":"ProjectTinyWorkshop核心知识点","date":"2020-07-07T13:03:53.000Z","updated":"2020-07-17T09:52:44.170Z","comments":true,"path":"2020/07/07/ProjectTinyWorkshop核心知识点/","link":"","permalink":"https://chasencenge.github.io/2020/07/07/ProjectTinyWorkshop核心知识点/","excerpt":"ECS & Monobehaviours","text":"ECS & Monobehaviours Monobehaviours: C#类，引用类型，数据分散在内存中，当数据取回时，系统需要遍历内存去寻找，操作时不需要的数据也被处理 ECS: 使用值类型，数据会在内存中紧密地装在一块(chunk)，仅处理需要操作的数据 Entities只是帮助我们找到(component)数据的handle Components举例：(Component只是模块化的数据) 123456789101112struct Health : IComponentData&#123; int current; int max;&#125;struct Sprite2D : IComponentData&#123; Entity image; Rect imageRegion; Vector2 pivot;&#125; Entities举例： 比如某个Entity 1有四个组件(Component)，LocalPosition组件，Sprite2DRenderer组件，Health组件，Player组件（这里没有行为，行为由系统（System）给出） Systems不在乎它处理的生命值是玩家的生命值还是一个兽人或者哥布林的生命值 Systems包括两部分，一是query，帮我找到这个数据，那个数据…，找到了之后对数据的action 用System的方式筛选要操作的rntities: 123456789101112public override void OnUpdate()&#123; var dt = Scheduler.DeltaTime(); ForEach( LocalPosition MoveToTarget Not : Frozen =&gt; //注意查询时的这种筛选，用Not &#123; //actions &#125; );&#125;","categories":[{"name":"Project Tiny","slug":"Project-Tiny","permalink":"https://chasencenge.github.io/categories/Project-Tiny/"}],"tags":[{"name":"DOTS","slug":"DOTS","permalink":"https://chasencenge.github.io/tags/DOTS/"}]},{"title":"Unity DOTS(直播笔记)","slug":"UnityDOTS(直播笔记)","date":"2020-07-07T12:52:13.000Z","updated":"2020-07-20T02:38:44.294Z","comments":true,"path":"2020/07/07/UnityDOTS(直播笔记)/","link":"","permalink":"https://chasencenge.github.io/2020/07/07/UnityDOTS(直播笔记)/","excerpt":"ECS优化缓存行-- ECS和传统游戏对象-- 原型Archtype-- 栈帧-- 组件与共享组件-- ECS实例-- 汇编指令-- SIMD-- Burst编译器-- Unity.mathematics数学库-- Job多线程计算-- 系统生命周期--","text":"ECS优化缓存行-- ECS和传统游戏对象-- 原型Archtype-- 栈帧-- 组件与共享组件-- ECS实例-- 汇编指令-- SIMD-- Burst编译器-- Unity.mathematics数学库-- Job多线程计算-- 系统生命周期-- ECS优化缓存行：怎样提高缓冲区命中率，每个对象只加载xy坐标和旋转一共12b，那么一个缓存行能存五个对象，浪费64-21*5 = 4b ECS和传统游戏对象：ECS：Entity（实体）、Component（组件）、System（系统） 传统： 12345678public class Game : MonoBehaviour&#123; public int x; private void Update() &#123; x++; &#125;&#125; ECS： 123456789101112131415public struct GameComponentData : IComponentData // 组件 //结构体只保存数据，不能写逻辑&#123; public int x;&#125;public class MyGameSystem : ComponentSystem //在System里找关心的组件&#123; protected override void OnUpdate() &#123; this.Entities.ForEach((ref GameComponentData data) =&gt; &#123; data.x++; &#125;); &#125;&#125; 原型Archtype：即使不同的实体Entity，只要组件相同都会保存在原型ArcheType。 ArcheType是16KB的数组容器。 栈帧：栈上会保留值类型数据和指向堆的指针。 组件与共享组件：值类型组件和共享类型组件。 System可以找到它关心的组件去遍历。 Component System在Main Thread，Job Component System(JCS)可以在多线程。 Main Thread–JCS &gt;&gt;&gt; Worker Thread–Job, Job, Job…… JobSystem应用：ECS实例：ArcheType Chunk容量16KB，包含Trees #1, Trees #2, Rocks #1, Big Enemies #1, Small Enemies #1, Small Enemies #2, Query出符合条件的实体组件，大敌人、小敌人统一Update（相比Rocks，Trees更感兴趣） 汇编指令：mov指令：内存中数据传到寄存器/寄存器数据传到另一寄存器 mov ax 8 数据-&gt;寄存器 mov ax bx 寄存器-&gt;寄存器 SIMD：没听懂用来干嘛 SIMD指令优化总结： 避免代码出现分支预测（会打断SIMD的向量化指令），使用math.select和math.lerp代替分支预测 使用float4 bool4等代替float bool 使用m128自己组织128位数据 编译后尽量使用v开头指令，结尾尽量是ps指令而不是ss指令 Burst编译器：Burst只支持值类型数据的编译，不支持引用类型数据编译（因为C#的GC做的不好）。 Burst编译器是以LLVM为基础的后端编译技术。 怎么启动Burst编译器？在Job上面加上[BurstCompile]，如果在Job外怎么工作呢？使用有一个限制是需要静态方法 12345678910111213141516[BurstCompile]public class MyClass&#123; [BurstCompile] public static float add(float a, float b) &#123; return a * b; &#125; [BurstCompile] &#123; public static unsafe void dot(float3* a, float3* b, float* c) &#123; *c = math.dot(*a, *b); &#125; &#125;&#125; Unity.mathematics数学库：提供矢量类型（float4 float3…）可直接映射到硬件SIMD寄存器 Math类也提供了直接映射到硬件SIMD寄存器 原本CPU一个一个计算的有了SIMD可以一次性计算 Job多线程计算：12345678910111213141516171819202122[BurstCompile]public struct MyJob1 : IJob&#123; [ReadOnly] public int left; [ReadOnly] public int right; [WriteOnly] public NativeArray&lt;int&gt; @out; public Execute() &#123; @out[0] = left * right; &#125;&#125;private void Start()&#123; MyJob1 myJob = new MyJob1(); myJob.left = 2; myJob.right = 3; myJob.@out = new NativeArray&lt;int&gt;(1, Allocator.TempJob); myJob.Schedule().Complete(); //在一个子线程中计算并且等待完成 Debug.Log(myJob.@out[0]); // log 6; myJob.@out.Dispose();&#125; 1234567891011121314151617181920212223// IJobFor[BurstCompile]public struct MyJob2 : IJobFor&#123; public NativeArray&lt;int&gt; left; [ReadOnly] public NativeArra&lt;int&gt; right; public void Execute(int index) &#123; left[index] = left[index] * right[index]; //输出线程ID和当前执行的索引 Debug.Log(System.Threading.Thread.CurrentThread.ManagedThreadId + &quot;,&quot; + index); &#125;&#125;private void start()&#123; MyJob2 myJob = new MyJob2(); myJob.left = new NativeArray&lt;int&gt;(100, Allocator.TempJob); myJob.right = new NativeArray&lt;int&gt;(100, Allocator.TempJob); myJob.Schedule(myJob.left.Length, new JobHandle()).Complete(); //实际上是在一个子线程里面开了个for循环，Schedule是在一个子线程中执行，可以保证顺序 myJob.left.Dispose(); myJob.right.Dispose();&#125; Schedule和ScheduleParallel对比： 12//ScheduleParallel可以在多个子线程中并行运行，不保证顺序myJob.ScheduleParallel(myJob.left.Length, 64, new JobHandle()).Complete(); IJobFor和IJobParallelFor 1234567891011121314151617181920212223[BurstCompile]public struct MyJob2 : IJobParallelFor&#123; public NativeArray&lt;int&gt; left; [ReadOnly] public NativeArra&lt;int&gt; right; public void Execute(int index) &#123; left[index] = left[index] * right[index]; //输出线程ID和当前执行的索引 Debug.Log(System.Threading.Thread.CurrentThread.ManagedThreadId + &quot;,&quot; + index); &#125;&#125;private void start()&#123; MyJob2 myJob = new MyJob2(); myJob.left = new NativeArray&lt;int&gt;(100, Allocator.TempJob); myJob.right = new NativeArray&lt;int&gt;(100, Allocator.TempJob); //因为接口是IJobParallelFor，这里的Schedule就完全是并行执行不保证顺序了(注意参数有些不同，多了个“64”) myJob.Schedule(myJob.left.Length, 64, new JobHandle()).Complete(); myJob.left.Dispose(); myJob.right.Dispose();&#125; Complete是实现在主线程等待执行的结果 myJob.Schedule和myJob.Run对比：Schedule是在多核子线程中并行计算，Run是完全在主线程执行 Job的处理依赖关系： 我有Job1和Job2，怎么并行执行快一些？ 1234567891011121314151617MyJob2 myJob1 = new MyJob2();MyJob3 myJob2 = new MyJob3();//同时并行执行myJob1.Schedule(100, 64);myJob2.Schedule(100, 64);//Job1执行完毕后再并行执行Job2//缺点是要在主线程等待Job1结束(因为用了Complete())myJob1.Schedule(100, 64).Complete();myJob2.Schedule(100, 64); //设置Job2依赖Job1，这样不需要在主线程等待//JobHandle和依赖项：调用Schedule方法时会返回JobHandle，可以用Job1的JobHandle作为Job2的依赖项JobHandle jobHandle = new JobHandle();JobHandle scheduleJobDependencyJob = myJob1.Schedule(100, 64, jobHandle);myJob2.Schedule(100, 64, scheduleJobDependencyJob).Complete(); 设计模式-组合模式：系统生命周期：OnCreate(), OnStartRunning(), OnUpdate(), OnStopRunning(), OnDestory()","categories":[{"name":"Unity","slug":"Unity","permalink":"https://chasencenge.github.io/categories/Unity/"}],"tags":[{"name":"DOTS","slug":"DOTS","permalink":"https://chasencenge.github.io/tags/DOTS/"}]},{"title":"本地代码提交至git","slug":"本地代码提交至git","date":"2019-11-20T15:02:36.000Z","updated":"2020-07-20T02:40:13.092Z","comments":true,"path":"2019/11/20/本地代码提交至git/","link":"","permalink":"https://chasencenge.github.io/2019/11/20/本地代码提交至git/","excerpt":"本地更新如何提交至GitHub","text":"本地更新如何提交至GitHub for first use1234567git init ***init .git*** git status ***check files to be added to the local repository*** git add xxx ***add files to repo*** git commit -m &quot;commit description&quot; ***commit to repo*** git remote add origin git@github.com:mobinets/hyblora.git ***link local repo to github*** git pull --rebase origin master ***pull = fetch + merge*** git push -u origin master ***upload*** not first use repo123git add xxx git commit -m &quot;commit discription&quot; git push -u origin master","categories":[{"name":"Git","slug":"Git","permalink":"https://chasencenge.github.io/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://chasencenge.github.io/tags/git/"}]},{"title":"ParticalFilter(粒子滤波算法)","slug":"ParticalFilter(粒子滤波算法)","date":"2019-09-23T05:36:58.000Z","updated":"2020-07-20T02:36:54.957Z","comments":true,"path":"2019/09/23/ParticalFilter(粒子滤波算法)/","link":"","permalink":"https://chasencenge.github.io/2019/09/23/ParticalFilter(粒子滤波算法)/","excerpt":"粒子滤波算法","text":"粒子滤波算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182import numpy as npimport scipy as scipyfrom numpy.random import uniformimport scipy.statsnp.set_printoptions(threshold=3)np.set_printoptions(suppress=True)import cv2def drawLines(img, points, r, g, b): cv2.polylines(img, [np.int32(points)], isClosed=False, color=(r, g, b))def drawCross(img, center, r, g, b): d = 5 t = 2 LINE_AA = cv2.LINE_AA if cv2.__version__[0] == '3' else cv2.CV_AA color = (r, g, b) ctrx = center[0,0] ctry = center[0,1] cv2.line(img, (ctrx - d, ctry - d), (ctrx + d, ctry + d), color, t, LINE_AA) cv2.line(img, (ctrx + d, ctry - d), (ctrx - d, ctry + d), color, t, LINE_AA) def mouseCallback(event, x, y, flags,null): global center global trajectory global previous_x global previous_y global zs center=np.array([[x,y]]) trajectory=np.vstack((trajectory,np.array([x,y]))) #noise=sensorSigma * np.random.randn(1,2) + sensorMu if previous_x &gt;0: heading=np.arctan2(np.array([y-previous_y]), np.array([previous_x-x ])) if heading&gt;0: heading=-(heading-np.pi) else: heading=-(np.pi+heading) distance=np.linalg.norm(np.array([[previous_x,previous_y]])-np.array([[x,y]]) ,axis=1) std=np.array([2,4]) u=np.array([heading,distance]) predict(particles, u, std, dt=1.) zs = (np.linalg.norm(landmarks - center, axis=1) + (np.random.randn(NL) * sensor_std_err)) update(particles, weights, z=zs, R=50, landmarks=landmarks) indexes = systematic_resample(weights) resample_from_index(particles, weights, indexes) previous_x=x previous_y=y WIDTH=800HEIGHT=600WINDOW_NAME=\"Particle Filter\"#sensorMu=0#sensorSigma=3sensor_std_err=5def create_uniform_particles(x_range, y_range, N): particles = np.empty((N, 2)) particles[:, 0] = uniform(x_range[0], x_range[1], size=N) particles[:, 1] = uniform(y_range[0], y_range[1], size=N) return particlesdef predict(particles, u, std, dt=1.): N = len(particles) dist = (u[1] * dt) + (np.random.randn(N) * std[1]) particles[:, 0] += np.cos(u[0]) * dist particles[:, 1] += np.sin(u[0]) * dist def update(particles, weights, z, R, landmarks): weights.fill(1.) for i, landmark in enumerate(landmarks): distance=np.power((particles[:,0] - landmark[0])**2 +(particles[:,1] - landmark[1])**2,0.5) weights *= scipy.stats.norm(distance, R).pdf(z[i]) weights += 1.e-300 # avoid round-off to zero weights /= sum(weights) def neff(weights): return 1. / np.sum(np.square(weights))def systematic_resample(weights): N = len(weights) positions = (np.arange(N) + np.random.random()) / N indexes = np.zeros(N, 'i') cumulative_sum = np.cumsum(weights) i, j = 0, 0 while i &lt; N and j&lt;N: if positions[i] &lt; cumulative_sum[j]: indexes[i] = j i += 1 else: j += 1 return indexes def estimate(particles, weights): pos = particles[:, 0:1] mean = np.average(pos, weights=weights, axis=0) var = np.average((pos - mean)**2, weights=weights, axis=0) return mean, vardef resample_from_index(particles, weights, indexes): particles[:] = particles[indexes] weights[:] = weights[indexes] weights /= np.sum(weights) x_range=np.array([0,800])y_range=np.array([0,600])#Number of partcilesN=400landmarks=np.array([ [144,73], [410,13], [336,175], [718,159], [178,484], [665,464] ])NL = len(landmarks)particles=create_uniform_particles(x_range, y_range, N)weights = np.array([1.0]*N)# Create a black image, a window and bind the function to windowimg = np.zeros((HEIGHT,WIDTH,3), np.uint8)cv2.namedWindow(WINDOW_NAME)cv2.setMouseCallback(WINDOW_NAME,mouseCallback)center=np.array([[-10,-10]])trajectory=np.zeros(shape=(0,2))robot_pos=np.zeros(shape=(0,2))previous_x=-1previous_y=-1DELAY_MSEC=50while(1): cv2.imshow(WINDOW_NAME,img) img = np.zeros((HEIGHT,WIDTH,3), np.uint8) drawLines(img, trajectory, 0, 255, 0) drawCross(img, center, r=255, g=0, b=0) #landmarks for landmark in landmarks: cv2.circle(img,tuple(landmark),10,(255,0,0),-1) #draw_particles: for particle in particles: cv2.circle(img,tuple((int(particle[0]),int(particle[1]))),1,(255,255,255),-1) if cv2.waitKey(DELAY_MSEC) &amp; 0xFF == 27: break cv2.circle(img,(10,10),10,(255,0,0),-1) cv2.circle(img,(10,30),3,(255,255,255),-1) cv2.putText(img,\"Landmarks\",(30,20),1,1.0,(255,0,0)) cv2.putText(img,\"Particles\",(30,40),1,1.0,(255,255,255)) cv2.putText(img,\"Robot Trajectory(Ground truth)\",(30,60),1,1.0,(0,255,0)) drawLines(img, np.array([[10,55],[25,55]]), 0, 255, 0) cv2.destroyAllWindows() 如何安装依赖并运行打开anaconda prompt 1234conda create -n Filters python=3conda activate Filtersconda install -c menpo opencv3conda install numpy scipy matplotlib sympy cd python_codepython partical.pypython partical_v2.py","categories":[{"name":"Python","slug":"Python","permalink":"https://chasencenge.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://chasencenge.github.io/tags/Python/"}]},{"title":"Hexo发布","slug":"Hexo发布","date":"2019-09-14T15:52:50.000Z","updated":"2020-07-20T02:28:34.779Z","comments":true,"path":"2019/09/14/Hexo发布/","link":"","permalink":"https://chasencenge.github.io/2019/09/14/Hexo发布/","excerpt":"如何发布Hexo博客","text":"如何发布Hexo博客 hexo文件夹中，git bash here hexo new ‘’ hexo clean hexo g hexo s hexo d","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://chasencenge.github.io/tags/hexo/"}]},{"title":"Python---yield关键字","slug":"Python的yield关键字","date":"2019-07-25T06:59:22.000Z","updated":"2020-07-20T02:54:05.198Z","comments":true,"path":"2019/07/25/Python的yield关键字/","link":"","permalink":"https://chasencenge.github.io/2019/07/25/Python的yield关键字/","excerpt":"python中yield关键字的用法","text":"python中yield关键字的用法 迭代(iteration)与可迭代(iterable)使用容器时逐个获取元素的过程为迭代。 哪些类型是可迭代的 python中的顺序类型： list, tuple(元组，列表可修改元组不可修改，列表用中括号元组用小括号), string. dict, set, file. 某类对象提供了 __iter__() 或者 __getitem__() 方法. 迭代器对迭代器不断调用next()方法，可依次获取下一个元素，迭代器__iter__()方法返回迭代器自身，因此迭代器也是可迭代的。 迭代器协议(iterator protocol)一个容器提供__iter__()方法，该方法能返回一个能逐个访问容器内所有元素的迭代器，则该容器实现了迭代器协议。 python处理for循环的过程12for x in something: print(x) 处理for循环首先调用内建函数iter(something),内建函数调用something.__iter__(),返回something对应的迭代器，然后for循环会调用内建函数next()，作用在迭代器上获取迭代器的下一个元素，并赋值给x 生成器函数(generaor function)和生成器(generator)如果一个函数包含 yield 表达式，那么它是一个生成器函数；调用它会返回一个特殊的迭代器，称为生成器。 生成器函数被调用后，其函数体内的代码并不会立即执行，而是返回一个生成器（generator-iterator）。当返回的生成器调用成员方法时，相应的生成器函数中的代码才会执行。 “下一个yield表达式”调用 generator.next() 时，生成器函数会从当前位置开始执行到下一个 yield 表达式。这里的「下一个」指的是执行逻辑的下一个。 12345678910111213141516def f123(): yield 1 yield 2 yield 3for item in f123(): # 1, 2, and 3, will be printed print(item)def f13(): yield 1 while False: yield 2 yield 3for item in f13(): # 1 and 3, will be printed print(item) 使用 send() 方法与生成器函数通信12345678910def func(): x = 1 while True: y = (yield x) x += ygeniter = func()geniter.next() # 1geniter.send(3) # 4geniter.send(10)# 14 生成器函数 func 用 yield 表达式，将处理好的 x 发送给生成器的调用者；与此同时，生成器的调用者通过 send 函数，将外部信息作为生成器函数内部的 yield 表达式的值，保存在 y 当中，并参与后续的处理。 yield的好处顺序访问容器内的前五个元素： way1:获取所有元素然后取前五 way2:逐个迭代，至第五个元素 假设对于一个func(),返回值为列表，调用者对其返回值只有逐个迭代： 若等函数生成所有元素可能需要很长时间 使用yield把func()变成一个生成器函数，每次产生一个元素，可以节省开销","categories":[{"name":"Python","slug":"Python","permalink":"https://chasencenge.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://chasencenge.github.io/tags/Python/"}]},{"title":"Gradle相关知识(转载自Bonker)","slug":"Gradle相关知识(转载自Bonker)","date":"2019-07-18T08:38:29.000Z","updated":"2020-07-20T02:27:58.584Z","comments":true,"path":"2019/07/18/Gradle相关知识(转载自Bonker)/","link":"","permalink":"https://chasencenge.github.io/2019/07/18/Gradle相关知识(转载自Bonker)/","excerpt":"关于Android开发中的Gradle","text":"关于Android开发中的Gradle (转载自Bonker）原文链接：https://www.cnblogs.com/Bonker/p/5619458.html 什么是Gradle简单的说，Gradle是一个构建工具，它是用来帮助我们构建app的，构建包括编译、打包等过程。我们可以为Gradle指定构建规则，然后它就会根据我们的“命令”自动为我们构建app。Android Studio中默认就使用Gradle来完成应用的构建。有些同学可能会有疑问：”我用AS不记得给Gradle指定过什么构建规则呀，最后不还是能搞出来个apk。“ 实际上，app的构建过程是大同小异的，有一些过程是”通用“的，也就是每个app的构建都要经历一些公共步骤。因此，在我们在创建工程时，Android Studio自动帮我们生成了一些通用构建规则，很多时候我们甚至完全不用修改这些规则就能完成我们app的构建。 有些时候，我们会有一些个性化的构建需求，比如我们引入了第三方库，或者我们想要在通用构建过程中做一些其他的事情，这时我们就要自己在系统默认构建规则上做一些修改。这时候我们就要自己向Gradle”下命令“了，这时候我们就需要用Gradle能听懂的话了，也就是Groovy。Groovy是一种基于JVM的动态语言，关于它的具体介绍，感兴趣的同学可以文末参考”延伸阅读“部分给出的链接。 我们在开头处提到“Gradle是一种构建工具”。实际上，当我们想要更灵活的构建过程时，Gradle就成为了一个编程框架——我们可以通过编程让构建过程按我们的意愿进行。也就是说，当我们把Gradle作为构建工具使用时，我们只需要掌握它的配置脚本的基本写法就OK了；而当我们需要对构建流程进行高度定制时，就务必要掌握Groovy等相关知识了。限于篇幅，本文只从构建工具使用者的角度来介绍Gradle的一些最佳实践，在文末“延伸阅读”部分给出了几篇高质量的深入介绍Gradle的文章，其中包含了Groovy等知识的介绍。 Gradle的基本组分Project与Task在Gradle中，每一个待构建的工程是一个Project，构建一个Project需要执行一系列Task，比如编译、打包这些构建过程的子过程都对应着一个Task。具体来说，一个apk文件的构建包含以下Task：Java源码编译、资源文件编译、Lint检查、打包以生成最终的apk文件等等。 插件插件的核心工作有两个：一是定义Task；而是执行Task。也就是说，我们想让Gradle能正常工作，完成整个构建流程中的一系列Task的执行，必须导入合适的插件，这些插件中定义了构建Project中的一系列Task，并且负责执行相应的Task。 在新建工程的app模块的build.gradle文件的第一行，往往都是如下这句： apply plugin: ‘com.android.application’这句话的意思就是应用“com.android.application“这个插件来构建app模块，app模块就是Gradle中的一个Project。也就是说，这个插件负责定义并执行Java源码编译、资源文件编译、打包等一系列Task。实际上”com.android.application”整个插件中定义了如下4个顶级任务： assemble: 构建项目的输出（apk） check: 进行校验工作 build: 执行assemble任务与check任务 clean: 清除项目的输出 当我们执行一个任务时，会自动执行它所依赖的任务。比如，执行assemble任务会执行assembleDebug任务和assembleRelease任务，这是因为一个Android项目至少要有debug和release这两个版本的输出。 Gradle配置文件我们在Android Studio中新建一个工程，可以得到如下的工程结构图： 上面我们说过，Android Studio中的一个Module即为Gradle中的一个Project。上图的app目录下，存在一个build.gradle文件，代表了app Module的构建脚本，它定义了应用于本模块的构建规则。我们可以看到，工程根目录下也存在一个build.gradle文件，它代表了整个工程的构建，其中定义了适用于这个工程中所有模块的构建规则。 接下来我们介绍一下上图中其他几个Gradle配置文件： gradle.properties: 从它的名字可以看出，这个文件中定义了一系列“属性”。实际上，这个文件中定义了一系列供build.gradle使用的常量，比如keystore的存储路径、keyalias等等。 gradlew与gradlew.bat: gradlew为Linux下的shell脚本，gradlew.bat是Windows下的批处理文件。gradlew是gradle wrapper的缩写，也就是说它对gradle的命令进行了包装，比如我们进入到指定Module目录并执行“gradlew.bat assemble”即可完成对当前Module的构建（Windows系统下）。 local.properties: 从名字就可以看出来，这个文件中定义了一些本地属性，比如SDK的路径。 settings.gradle: 假如我们的项目包含了不只一个Module时，我们想要一次性构建所有Module以完成整个项目的构建，这时我们需要用到这个文件。比如我们的项目包含了ModuleA和ModuleB这两个模块，则这个文件中会包含这样的语句：include ‘:ModuleA’, ‘:ModuleB’。 构建脚本首先我们来看一下工程目录下的build.gradle，它指定了真个整个项目的构建规则，它的内容如下： &#123;123456789101112131415 repositories &#123; jcenter() //构建脚本中所依赖的库都在jcenter仓库下载 &#125; dependencies &#123; //指定了gradle插件的版本 classpath &apos;com.android.tools.build:gradle:1.5.0&apos; &#125;&#125;allprojects &#123; repositories &#123; //当前项目所有模块所依赖的库都在jcenter仓库下载 jcenter() &#125;&#125; 我们再来简单介绍下app模块的build.gradle的内容： 12345678910111213141516171819202122232425262728//加载用于构建Android项目的插件apply plugin: &apos;com.android.application&apos;android &#123; //构建Android项目使用的配置 compileSdkVersion 23 //指定编译项目时使用的SDK版本 buildToolsVersion &quot;23.0.1&quot; //指定构建工具的版本 defaultConfig &#123; applicationId &quot;com.absfree.debugframwork&quot; //包名 minSdkVersion 15 //指定支持的最小SDK版本 targetSdkVersion 23 //针对的目标SDK版本 versionCode 1 versionName &quot;1.0&quot; &#125; buildTypes &#123; //针对不同的构建版本进行一些设置 release &#123; //对release版本进行的设置 minifyEnabled false //是否开启混淆 proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; //指定混淆文件的位置 &#125; &#125;&#125;dependencies &#123; //指定当前模块的依赖 compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) testCompile &apos;junit:junit:4.12&apos; compile &apos;com.android.support:appcompat-v7:23.1.1&apos; compile &apos;com.android.support:design:23.1.1&apos;&#125; 常见配置整个工程的build.gradle通常不需我们改动，这里我们介绍下一些对模块目录下build.gradle文件的常见配置。 依赖第三方库当我们的项目中用到了了一些第三方库时，我们就需要进行一些配置，以保证能正确导入相关依赖。设置方法很简单，比如我们在app模块中中用到了Fresco，只需要在build.gradle文件中的dependencies块添加如下语句： 1234dependencies &#123; ... compile &apos;com.facebook.fresco:fresco:0.11.0&apos;&#125; 这样一来，Gradle会自动从jcenter仓库下载我们所需的第三方库并导入到项目中。 导入本地jar包在使用第三方库时，除了像上面那样从jcenter仓库下载，我们还可以导入本地的jar包。配置方法也很简单，只需要先把jar文件添加到app\\libs目录下，然后在相应jar文件上单击右键，选择“Ad As Library”。然后在build.gradle的dependencies块下添加如下语句： compile files(‘libs/xxx.jar’)实际上我们可以看到，系统为我们创建的build.gradle中就已经包含了如下语句： compile fileTree(dir: ‘libs’, include: [‘*.jar’]) 这句话的意思是，将libs目录下的所有jar包都导入。所以实际上我们只需要把jar包添加到libs目录下并“Ad As Library”即可。 依赖其它模块假设我们的项目包含了多个模块，并且app模块依赖other模块，那么我们只需app\\build.gradle的denpendencies块下添加如下语句： compile project(‘:other’) 构建输出为aar文件通常我们构建的输出目标都是apk文件，但如果我们的当前项目时Android Library，我们的目标输出就是aar文件。要想达到这个目的也很容易，只需要把build.gradle的第一句改为如下： apply plugin:’com.android.library’这话表示我们使用的插件不再是构建Android应用的插件，而是构建Android Library的插件，这个插件定义并执行用于构建Android Library的一系列Task。 自动移除不再使用的资源只需进行如下配置： 1234567891011android &#123; ... &#125; buildTypes &#123; release &#123; ... shrinkResources true ... &#125; &#125;&#125; 忽略Lint错误在我们构建Android项目的过程中，有时候会由于Lint错误而终止。当这些错误来自第三方库中时，我们往往想要忽略这些错误从而继续构建进程。这时候，我们可以只需进行如下配置： 123456android &#123; ... lintOptions &#123; abortOnError false &#125;&#125; 集成签名配置在构建release版本的Android项目时，每次都手动导入签名文件，键入密码、keyalias等信息十分麻烦。通过将签名配置集成到构建脚本中，我们就不必每次构建发行版本时都手动设置了。具体配置如下： 1234567891011121314151617signingConfigs &#123; myConfig &#123; //将&quot;xx&quot;替换为自己的签名文件信息 storeFile file(&quot;xx.jks&quot;) storePassword &quot;xx&quot; keyAlias &quot;xx&quot; keyPassword &quot;xx&quot; &#125;&#125;android &#123; buildTypes &#123; release &#123; signingConfig signingConfigs.myConfig //在release块中加入这行 ... &#125; &#125; ...&#125; 真实开发中，我们不应该把密码等信息直接写到build.gradle中，更好的做法是放在gradle.properties中设置： 1234RELEASE_STOREFILE=xxx.jks RELEASE_STORE_PASSWORD = xxxRELEASE_KEY_ALIAS=xxxRELEASE_KEY_PASSWORD=xxx 然后在build.gradle中直接引用即可： 12345678signingConfigs &#123; myConfig &#123; storeFilefile(RELEASE_STOREFILE) storePassword RELEASE_STORE_PASSWORD keyAlias RELEASE_KEY_ALIAS keyPassword RELEASE_KEY_PASSWORD &#125;&#125; 关于Gradle的其他配置方法大家可以参考“延伸阅读”部分的“Gradle最佳实践”。","categories":[{"name":"Android","slug":"Android","permalink":"https://chasencenge.github.io/categories/Android/"}],"tags":[{"name":"Gradle","slug":"Gradle","permalink":"https://chasencenge.github.io/tags/Gradle/"}]},{"title":"Linux远程登录及服务器配置","slug":"Linux远程登录","date":"2019-07-17T13:45:43.000Z","updated":"2020-07-20T02:35:41.509Z","comments":true,"path":"2019/07/17/Linux远程登录/","link":"","permalink":"https://chasencenge.github.io/2019/07/17/Linux远程登录/","excerpt":"Linux远程登录及服务器配置","text":"Linux远程登录及服务器配置 ##Linux远程登录原理安装telnet远程客户端登录工具的客户机通过23（默认）端口连接到Linux服务器，通过telnet将远程客户机上命令传到服务器执行并反馈。###telnet软件包安装sudo apt-get install inetutils-telnetd(ubuntu没有默认安装Telnet软件包)","categories":[{"name":"Linux","slug":"Linux","permalink":"https://chasencenge.github.io/categories/Linux/"}],"tags":[{"name":"远程登录","slug":"远程登录","permalink":"https://chasencenge.github.io/tags/远程登录/"}]},{"title":"可见光认证相关","slug":"可见光认证","date":"2019-07-05T03:09:43.000Z","updated":"2020-07-20T02:41:01.059Z","comments":true,"path":"2019/07/05/可见光认证/","link":"","permalink":"https://chasencenge.github.io/2019/07/05/可见光认证/","excerpt":"基于可见光的无线网络认证","text":"基于可见光的无线网络认证 2019-07-05 802.1x认证过程： 当用户有访问网络需求时打开802.1X客户端程序，输入已经申请、登记过的用户名和密码，发起连接请求（EAPOL-Start报文）。此时，客户端程序将发出请求认证的报文给设备端，开始启动一次认证过程。 设备端收到请求认证的数据帧后，将发出一个请求帧（EAP-Request/Identity报文）要求用户的客户端程序发送输入的用户名。 客户端程序响应设备端发出的请求，将用户名信息通过数据帧（EAP-Response/Identity报文）发送给设备端。设备端将客户端发送的数据帧经过封包处理后（RADIUS Access-Request报文）送给认证服务器进行处理。 RADIUS服务器收到设备端转发的用户名信息后，将该信息与数据库中的用户名表对比，找到该用户名对应的密码信息，用随机生成的一个加密字对它进行加密处理，同时也将此加密字通过RADIUS Access-Challenge报文发送给设备端，由设备端转发给客户端程序。 客户端程序收到由设备端传来的加密字（EAP-Request/MD5 Challenge报文）后，用该加密字对密码部分进行加密处理（此种加密算法通常是不可逆的），生成EAP-Response/MD5 Challenge报文，并通过设备端传给认证服务器。 RADIUS服务器将收到的已加密的密码信息（RADIUS Access-Request报文）和本地经过加密运算后的密码信息进行对比，如果相同，则认为该用户为合法用户，反馈认证通过的消息（RADIUS Access-Accept报文和EAP-Success报文）。 设备收到认证通过消息后将端口改为授权状态，允许用户通过端口访问网络。在此期间，设备端会通过向客户端定期发送握手报文的方法，对用户的在线情况进行监测。缺省情况下，两次握手请求报文都得不到客户端应答，设备端就会让用户下线，防止用户因为异常原因下线而设备无法感知。 客户端也可以发送EAPOL-Logoff报文给设备端，主动要求下线。设备端把端口状态从授权状态改变成未授权状态，并向客户端发送EAP-Failure报文。 关于WiFidog：Portal认证，通常也会叫Web认证，未认证用户上网时，设备强制用户登录到特定站点，用户可以免费访问其中的服务。当用户需要使用互联网中的其它信息时，必须在门户网站进行认证，只有认证通过后才可以使用互联网资源。现金很多中国移动CMCC、中国联通、中国电信ChinaNet的WIFI都使用这种认证接入方式。 在OpenWRT上实现Portal认证，实际上早已有解决方案： chillispot，但原维护作者停止更新，被chillispot.info接管继续开发； coova-chilli，它是基于chillispot开发拓展的，功能最为强大；可以去官方看一下Coova-chilli； wifidog，前两个由于原维护作者停止更新，笔者也没有深入研究，重点钻研了wifidog，Wifidog也是OpenWRT和DD-WRT中实现Portal比较出名的。但是，Wifidog只是实现AP认证网关，需要配合外部的Portal服务器才能使用，Portal主要是提供认证所需的WEB页面且实现认证计费等的功能。虽然这也有很多商用解决方案，例如wiwiz、wifiap等，但是这些商业解决方案的目标都是盈利，即使可以免费使用，免费账号的功能和权限都受到了很大的限制，例如不能自定义页面，Web认证页面有广告等等。有条件的人可能打算自己搭建Portal服务器，但是看看Wifidog的官方Wiki，对搭建过程实在是难以理解。后来，笔者发现网络上还有一个 authpuppy方案 ，官方网站 www.authpuppy.org ，是一个已实现好的Wifidog认证服务器，里面包含各种插件供你使用，官方的安装过程也很简单，如果你懂的HTML和面向对象编程的相关知识且拥有一个服务器，可以自行修改认证页面，使用authpuppy也是一个不错的方案。 如何 自行编写一个轻量级的Web Portal认证服务器 ： Wifidog的工作原理： 客户端发出初始化请求，比如访问 www.dqrun.com 。 网关的防火墙规则将这个请求重定向到本地网关的端口上。这个端口是Wifidog监听的端口。 Wfidog提供一个HTTP重定向回复，重定向到Web认证页面，重定向的Url的Querystring中包含了Gateway的ID，Gateway的FQDN以及其他的信息。 用户向认证服务器发出认证请求 1234gw_id=[GatewayID, default: “default”]gw_address=[GatewayAddress, internal IP of router]gw_port=[GatewayPort, port that wifidog Gateway is listening on]url=[user requested url]； 网关返回一个（可以是自定义的）splash（也称作“登录”）页面。 用户提供他的凭据信息，比如用户名和密码。 成功认证的话，客户端将会被重定向到网关的自己的web页面上，并且带有一个认证凭据（一个一次性的token），内容比如：http://GatewayIP:GatewayPort/wifidog/auth?token=[auth token]； 用户就是用获取到的凭据访问网关。 网关去认证服务器询问token的有效性。 认证服务器确认token的有效性。 网关发送重定向给客户端，以从认证服务器上获取 成功提示页面，重定向到 http://portal_server:port/portal_script 这个位置。 认证服务器通知客户请求成功，可以上网了。 待完成工作：装wifidog ，配置:1）监听端口 2)服务器地址 3）5个脚本的地址(login, portal, msg, ping, auth) 配置方法：远程登陆openwrt: ssh root@192.168.1.1， 然后修改/etc/wifidog.conf文件。 将笔记本搭建成服务器 添加对LED的频率提取功能 实现动态调节LED频率,将此功能添加至系统 2019/07/08 路由器刷openwrt系统恢复出厂：断电后，先按住reset再通电。登陆192.168.1.1（breed web），先点“恢复出厂”，选择“openwrt”；再点击“更新固件”，选中已下载好的openwrt镜像，进行固件更新。 解决路由器联网问题 设置密码：点击Go to password configuration...，敲入2遍新的路由器密码，点击页面最下面的 保存执行按钮，密码修改即时生效。 设置主机名和时区：System菜单的system进去，主机名改为自己希望的名称，时区设置为Asia/Shanghai，保存。 联网设置 :点击菜单Network中的第二项，可以选择2G或5G无线网络连接WIFI，按 scan扫描按钮，稍等出现列表中，选择自己(想通过这个路由连接)的WIFI，输入密码，按提交，然后稍等，按保存执行。 ubuntu16.04编译OpenWrt环境搭建： ubuntu下OpenWrt编译环境需要安装很多组件：sudo apt-get install gccsudo apt-get install g++sudo apt-get install binutilssudo apt-get install patchsudo apt-get install bzip2sudo apt-get install flexsudo apt-get install bisonsudo apt-get install makesudo apt-get install autoconfsudo apt-get install gettextsudo apt-get install texinfosudo apt-get install unzipsudo apt-get install sharutilssudo apt-get install subversionsudo apt-get install libncurses5-devsudo apt-get install ncurses-termsudo apt-get install zlib1g-devsudo apt-get install subversionsudo apt-get install git-coresudo apt-get install gawksudo apt-get install asciidocsudo apt-get install libz-dev当然安装之前最好先更新下组件包：sudo apt-get update逐个安装… 新建一个openwrt目录，使用命令：mkdir openwrtsudo chmod 777 openwrt接下来的所有命令都在/openwrt目录下运行 下载OpenWrt源码:git clone git://git.openwrt.org/openwrt/openwrt.git 添加软件扩展包：cd /home/ngmi/openwrt/openwrt/cp feeds.conf.default feeds.conf(将feeds.conf.default修改为feeds.conf) 更新扩展，安装扩展：./scripts/feeds update -a./scripts/feeds install -a 测试下编译环境，使用命令：make defconfig make menuconfig如果一切正常，会出现一个配置菜单，可以选择要编译的固件平台、型号，还能选择固件中要添加的功能和组件，至此编译环境就搭建好了。 在OpenWrt的路由器上安装Wifidog应用程序 在OpenWrt系统的源码文件下，编辑feeds.conf.default文件vim feeds.conf.default在其中增加一行：src-git wifidog https://github.com/wifidog/wifidog-gateway.git 然后更新，再安装：./scripts/feeds update -a./scripts/feeds install -a 终端执行编译命令make menuconfig 在Network/captive portals/下选择wifidog 就有选择 WiFiDog 这一项了 2019/07/09 配置服务器中遇到的问题问题： python3 manage.py runserver 0.0.0.0:8000123456789101112131415161718Traceback (most recent call last): File &quot;manage.py&quot;, line 22, in &lt;module&gt; execute_from_command_line(sys.argv) File &quot;/usr/local/lib/python3.5/dist-packages/django/core/management/__init__.py&quot;, line 381, in execute_from_command_line utility.execute() File &quot;/usr/local/lib/python3.5/dist-packages/django/core/management/__init__.py&quot;, line 375, in execute self.fetch_command(subcommand).run_from_argv(self.argv) File &quot;/usr/local/lib/python3.5/dist-packages/django/core/management/base.py&quot;, line 323, in run_from_argv self.execute(*args, **cmd_options) File &quot;/usr/local/lib/python3.5/dist-packages/django/core/management/commands/runserver.py&quot;, line 60, in execute super().execute(*args, **options) File &quot;/usr/local/lib/python3.5/dist-packages/django/core/management/base.py&quot;, line 364, in execute output = self.handle(*args, **options) File &quot;/home/ngmi/lightFreq-master/my_wifi_auth_server/django_pdb/management/commands/runserver.py&quot;, line 59, in handle and middleware not in settings.MIDDLEWARE_CLASSES): File &quot;/usr/local/lib/python3.5/dist-packages/django/conf/__init__.py&quot;, line 80, in __getattr__ val = getattr(self._wrapped, name)AttributeError: &apos;Settings&apos; object has no attribute &apos;MIDDLEWARE_CLASSES&apos; 解决方法： 1234middleware = 'django_pdb.middleware.PdbMiddleware' if ((pdb_option or settings.DEBUG) and middleware not in settings.MIDDLEWARE): settings.MIDDLEWARE += (middleware,) 由于Django版本的问题，需要将（lightFreq-master/my_wifi_auth_server/django_pdb/management/conmands/runserver.py）以上代码中原本的MIDDLEWARE_CLASSES改为MIDDLEWARE。 问题： HTTP_HOST header: '0.0.0.0:8000'. You may need to add '0.0.0.0' to ALLOWED_HOSTS.12Bad Request: /[09/Jul/2019 14:14:40] &quot;GET / HTTP/1.1&quot; 400 66219 进入http://0.0.0.0:8000页面显示Invalid…解决办法：将lightFreq-master/my_wifi_auth_server/Auth_server/settings.py文件中ALLOWED_HOSTS = [&#39;192.168.1.162&#39;,&#39;127.0.0.1&#39;]修改为ALLOWED_HOSTS = [&#39;*&#39;]","categories":[{"name":"Light Frequency Authenticate","slug":"Light-Frequency-Authenticate","permalink":"https://chasencenge.github.io/categories/Light-Frequency-Authenticate/"}],"tags":[{"name":"lightFre","slug":"lightFre","permalink":"https://chasencenge.github.io/tags/lightFre/"}]},{"title":"为Hexo的Next主题添加计数功能","slug":"为Hexo的Next主题添加计数功能","date":"2019-07-03T10:22:33.000Z","updated":"2020-07-20T02:43:23.877Z","comments":true,"path":"2019/07/03/为Hexo的Next主题添加计数功能/","link":"","permalink":"https://chasencenge.github.io/2019/07/03/为Hexo的Next主题添加计数功能/","excerpt":"blog中添加wordcount功能","text":"blog中添加wordcount功能 1.在根目录git bash： npm install hexo-wordcount --save 2.在主题配置文件(hexo\\themes\\next\\config.yml)中打开wordcount功能 # Post wordcount display settings # Dependencies: https://github.com/willin/hexo-wordcount post_wordcount: item_text: true wordcount: true min2read: true totalcount: true separated_meta: true3.修改 hexo\\themes\\next\\layout\\post.swig，将下面代码复制到文件中： &lt;span title=&quot;{{ __('post.wordcount') }}&quot;&gt; {{ wordcount(post.content) }} 字 &lt;/span&gt; &lt;span title=&quot;{{ __('post.min2read') }}&quot;&gt; {{ min2read(post.content) }} 分钟 &lt;/span&gt;","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://chasencenge.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://chasencenge.github.io/tags/Hexo/"}]}]}